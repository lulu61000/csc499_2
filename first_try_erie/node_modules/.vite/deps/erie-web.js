import {
  ascending,
  bin,
  csvParse,
  descending,
  deviation,
  extent,
  format,
  linear2 as linear,
  log,
  ordinal,
  pow,
  quantileSorted,
  sqrt,
  symlog,
  time,
  timeFormat,
  tsvParse
} from "./chunk-UG6VGJXW.js";
import {
  __export
} from "./chunk-7U33LM2Z.js";

// node_modules/erie-web/src/classes/erie-util.js
function deepcopy(o) {
  return JSON.parse(JSON.stringify(o || null));
}
function isInstanceOf(o, c) {
  return (o == null ? void 0 : o.constructor) == c;
}
function isInstanceOfByName(o, c) {
  var _a5;
  return ((_a5 = o == null ? void 0 : o.constructor) == null ? void 0 : _a5.name) === c;
}
function isArrayOf(o, c) {
  if (isInstanceOf(o, Array)) {
    if (isInstanceOf(c, Array)) {
      return o.every((d) => c.includes(d.constructor));
    } else {
      return o.every((d) => isInstanceOf(d, c));
    }
  } else {
    return false;
  }
}

// node_modules/erie-web/src/classes/erie-datasets.js
var Datasets = class {
  constructor() {
    this.datsets = [];
  }
  add(ds) {
    if (!ds.constructor == Dataset) {
      throw new Error(`Wrong dataset object ${ds.constructor.name}}`);
    }
    this.datsets.push(ds.clone());
    return this;
  }
  get(name2) {
    var _a5, _b2, _c2;
    if (name2) {
      return (_b2 = (_a5 = this.datasets) == null ? void 0 : _a5.filter((d) => d.name === name2)) == null ? void 0 : _b2[0];
    } else {
      return (_c2 = this.datasets) == null ? void 0 : _c2.map((d) => d.get());
    }
  }
  clone() {
    var _a5;
    return (_a5 = this.datasets) == null ? void 0 : _a5.map((d) => d.clone());
  }
};
var Dataset = class _Dataset {
  constructor(name2) {
    this.name(name2);
    this.data = new Data();
    if (!name2) {
      throw new Error("A Dataset must be created with a name.");
    }
  }
  name(n2) {
    if (isInstanceOf(n2, String)) {
      this._name = n2;
    } else {
      throw new TypeError("A name for a Dataset must be String.");
    }
    return this;
  }
  set(t2, v) {
    this.data.set(t2, v);
    return this;
  }
  get() {
    return {
      name: this._name,
      data: this.data.get()
    };
  }
  clone() {
    let _c2 = new _Dataset(this._name);
    if (_c2)
      _c2.data = this.data.clone();
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-data.js
var Values = "values";
var Url = "url";
var Name = "name";
var AllowedDataTypes = [Values, Url, Name];
var Data = class _Data {
  constructor() {
    this.type = "unset";
    this.values = null;
    this.url = null;
    this.name = null;
  }
  set(type, e) {
    if (isInstanceOf(type, Dataset)) {
      this.type = Name;
      this.name = type._name;
    } else if (!AllowedDataTypes.includes(type)) {
      throw new TypeError(`Unspported data type ${type}}. It must be either one of ${AllowedDataTypes.join(", ")}.`);
    } else {
      if (type === Values) {
        this.type = Values;
        this.values = e;
      } else if (type === Url) {
        this.type = Url;
        this.url = e;
      } else if (type === Name) {
        this.type = Name;
        this.name = e;
      }
    }
    return this;
  }
  get() {
    return {
      type: this.type,
      values: deepcopy(this.values),
      url: this.url,
      name: this.name
    };
  }
  clone() {
    let _c2 = new _Data();
    _c2.type = this.type;
    if (this.type === Values) {
      _c2.values = deepcopy(this.values);
    } else if (this.type === Url) {
      _c2.url = this.url;
    } else if (this.type === Name) {
      _c2.name = this.name;
    }
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-transform-aggregate.js
var COUNT = "count";
var VALID = "valid";
var DISTINCT = "distinct";
var MEAN = "mean";
var AVG = "average";
var MODE = "mode";
var MEDIAN = "median";
var QUANTILE = "quantile";
var STDEV = "stdev";
var STDEVP = "stdevp";
var VARIANCE = "variance";
var VARIANCEP = "variancep";
var SUM = "sum";
var PRODUCT = "product";
var MAX = "max";
var MIN = "min";
var CORR = "corr";
var COVARIANCE = "covariance";
var COVARIANCEP = "covariancep";
var ZeroOPs = [
  COUNT
];
var SingleOps = [
  VALID,
  DISTINCT,
  MEAN,
  AVG,
  MODE,
  MEDIAN,
  QUANTILE,
  STDEV,
  STDEVP,
  VARIANCE,
  VARIANCEP,
  SUM,
  PRODUCT,
  MAX,
  MIN
];
var DoubleOps = [
  CORR,
  COVARIANCE,
  COVARIANCEP
];
var Aggregate = class _Aggregate {
  constructor() {
    this.aggregate = [];
    this._groupby = [];
  }
  add(op, field, as, p) {
    if (ZeroOPs.includes(op)) {
      if ((field == null ? void 0 : field.constructor.name) !== "String") {
        throw new Error('"as" is not provided.');
      }
      this.aggregate.push({
        op,
        as: field
      });
    } else if (SingleOps.includes(op)) {
      if (field === void 0 || (field == null ? void 0 : field.constructor.name) !== "String") {
        throw new Error('"field" is not properly provided.');
      }
      if (as === void 0 || (as == null ? void 0 : as.constructor.name) !== "String") {
        throw new Error('"as" is not properly provided.');
      }
      if (op === QUANTILE) {
        if (p === void 0) {
          console.warn("p is not provided, so is set as 0.5.");
          p = 0.5;
        }
        this.aggregate.push({
          op,
          field,
          as,
          p
        });
      } else {
        this.aggregate.push({
          op,
          field,
          as
        });
      }
    } else if (DoubleOps.includes(op)) {
      if (field === void 0 || (field == null ? void 0 : field.constructor.name) !== "Array" || (field == null ? void 0 : field.length) != 2 || !field.every((f) => (f == null ? void 0 : f.constructor.name) !== "String")) {
        throw new Error('"field" is not properly provided.');
      }
      if (as === void 0 || (as == null ? void 0 : as.constructor.name) !== "String") {
        throw new Error('"as" is not properly provided.');
      }
      this.aggregate.push({
        op,
        field: [...field],
        as
      });
    } else {
      throw new Error(`Unsupported operation type: ${op}`);
    }
    return this;
  }
  groupby(...args) {
    if (args.length == 1 && args[0].constructor.name === "Array" && args[0].every((a) => a.constructor.name === "String")) {
      this._groupby = [...args[0]];
    } else if (args.length >= 1 && args.every((a) => a.constructor.name === "String")) {
      this._groupby = [...args];
    }
    return this;
  }
  get() {
    return {
      aggregate: deepcopy(this.aggregate),
      groupby: deepcopy(this._groupby)
    };
  }
  clone() {
    let _c2 = new _Aggregate();
    _c2.aggregate = deepcopy(this.aggregate);
    _c2._groupby = deepcopy(this._groupby);
  }
};

// node_modules/erie-web/src/classes/erie-transform-bin.js
var Bin = class _Bin {
  constructor(bin2) {
    this._bin = bin2;
    this._as = bin2 + "__bin";
    this._end = bin2 + "__bin_end";
    this._nice = true;
    this._maxbins = 10;
    this._step;
    this._exact;
  }
  as(start, end) {
    if ((start == null ? void 0 : start.constructor.name) === "String" && (end == null ? void 0 : end.constructor.name) === "String") {
      this._as = start;
      this._end = end;
    } else {
      throw new TypeError("Bin 'as' (start, end) value should be Strings");
    }
    return this;
  }
  nice(v) {
    if ((v == null ? void 0 : v.constructor.name) === "Boolean") {
      this._nice = v;
    } else {
      throw new TypeError("Bin 'nice' value should be Boolean");
    }
    return this;
  }
  maxbins(v) {
    if ((v == null ? void 0 : v.constructor.name) === "Number" && Math.round(v) == v) {
      this._maxbins = v;
    } else {
      throw new TypeError("Bin 'maxbins' should be an integer.");
    }
    return this;
  }
  step(v) {
    if ((v == null ? void 0 : v.constructor.name) === "Number") {
      this._step = v;
    } else {
      throw new TypeError("Bin 'step' value should be a Number");
    }
    return this;
  }
  exact(v) {
    if ((v == null ? void 0 : v.constructor.name) === "Array" && v.every((d) => d.constructor.name === "Number")) {
      this._exact = v;
    } else {
      throw new TypeError("Bin 'exact; value should be an array of Numbers.");
    }
    return this;
  }
  get() {
    return {
      bin: this._bin,
      as: this._as,
      end: this._end,
      nice: this._nice,
      maxbins: this._maxbins,
      step: this._step,
      exact: deepcopy(this._exact)
    };
  }
  clone() {
    let _c2 = new _Bin(this._bin);
    _c2._as = this._as;
    _c2._end = this._end;
    _c2._nice = this._nice;
    _c2._maxbins = this._maxbins;
    _c2._step = this._step;
    _c2._exact = [...this._exact];
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-transform-calculate.js
var Calculate = class _Calculate {
  constructor(c, a) {
    this._calculate = "";
    this._as;
    if (c)
      this.calculate(c);
    if (a)
      this.as(a);
  }
  calculate(c) {
    if (isInstanceOf(c, String)) {
      this._calculate = c;
    } else {
      throw new TypeError("Calculate 'calculate' should be a String.");
    }
    return this;
  }
  as(c) {
    if (isInstanceOf(c, String)) {
      this._as = c;
    } else {
      throw new TypeError("Calculate 'as' should be a String.");
    }
    return this;
  }
  get() {
    return {
      calculate: this._calculate,
      as: this._as
    };
  }
  clone() {
    let _c2 = new _Calculate();
    if (this._calculate)
      _c2.calculate(this._calculate);
    if (this._as)
      _c2.as(this._as);
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-transform-density.js
var Density = class _Density {
  constructor(field) {
    this._density;
    this._groupby = [];
    this._cumulative = false;
    this._counts = false;
    this._bandwidth;
    this._extent;
    this._minsteps = 25;
    this._maxsteps = 200;
    this._steps;
    this._as = ["value", "density"];
    if (field)
      this.field(field);
  }
  field(f) {
    if (isInstanceOf(f, String)) {
      this._density = f;
    } else {
      throw new TypeError("Density 'field' (density) value should be a String.");
    }
    return this;
  }
  extent(a) {
    if (isInstanceOf(a, Array) && a.length == 2 && a.every((d) => isInstanceOf(d, Number))) {
      this._extent = [...a];
    } else {
      throw new TypeError("Density 'extent' should be an Array of two Numbers.");
    }
    return this;
  }
  groupby(g) {
    if (isInstanceOf(g, Array) && g.every((d) => isInstanceOf(d, String))) {
      this._groupby = [...g];
    } else {
      throw new TypeError("Density 'groupby' should be an Array of Strings.");
    }
    return this;
  }
  cumulative(v) {
    if (isInstanceOf(v, Boolean)) {
      this._cumulative = v;
    } else {
      throw new TypeError("Density 'cumulative' must be Boolean.");
    }
    return this;
  }
  counts(v) {
    if (isInstanceOf(v, Boolean)) {
      this._counts = v;
    } else {
      throw new TypeError("Density 'counts' must be Boolean.");
    }
    return this;
  }
  bandwidth(v) {
    if (isInstanceOf(v, Number)) {
      this._bandwidth = v;
    } else {
      throw new TypeError("Density 'bandwidth' should be a Number.");
    }
    return this;
  }
  minsteps(v) {
    if (isInstanceOf(v, Number)) {
      this._minsteps = v;
    } else {
      throw new TypeError("Density 'minsteps' should be a Number.");
    }
    return this;
  }
  maxsteps(v) {
    if (isInstanceOf(v, Number)) {
      this._maxsteps = v;
    } else {
      throw new TypeError("Density 'maxsteps' should be a Number.");
    }
    return this;
  }
  steps(v) {
    if (isInstanceOf(v, Number)) {
      this._steps = v;
    } else {
      throw new TypeError("Density 'steps' should be a Number.");
    }
    return this;
  }
  as(a) {
    if (isInstanceOf(a, Array) && a.length == 2 && a.every((d) => isInstanceOf(d, String))) {
      this._as = [...a];
    } else {
      throw new TypeError("Density 'as' should be an Array of two Strings.");
    }
    return this;
  }
  get() {
    return {
      density: this._density,
      extent: [...this._extent],
      groupby: [...this._groupby],
      cumulative: this._cumulative,
      counts: this._counts,
      bandwidth: this._bandwidth,
      minsteps: this._minsteps,
      maxsteps: this._maxsteps,
      steps: this._steps,
      as: [...this._as]
    };
  }
  clone() {
    let _c2 = new _Density(this._density);
    _c2._density = this._density;
    _c2._extent = [...this._extent];
    if (this._groupby)
      _c2._groupby = [...this._groupby];
    _c2._cumulative = this._cumulative;
    _c2._counts = this._counts;
    _c2._bandwidth = this._bandwidth;
    _c2._minsteps = this._minsteps;
    _c2._maxsteps = this._maxsteps;
    _c2._steps = this._steps;
    if (this._as)
      _c2._as = [...this._as];
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-transform-filter.js
var Filter = class _Filter {
  constructor(filter) {
    this._filter = "";
    this.filter(filter);
  }
  filter(f) {
    if (isInstanceOf(f, String)) {
      this._filter = f;
    } else {
      throw new TypeError("Filter 'filter' should be a String.");
    }
    return this;
  }
  get() {
    return {
      filter: this._filter
    };
  }
  clone() {
    let _c2 = new _Filter(this._filter);
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-transform-fold.js
var Fold = class _Fold {
  constructor(f, b) {
    this._fold = [];
    this._by;
    this._exclude = false;
    this._as = ["key", "value"];
    if (f)
      this.fold(f);
    if (b)
      this.by(b);
  }
  fold(f) {
    if (isInstanceOf(f, Array) && f.every((d) => isInstanceOf(d, String))) {
      this._fold = [...f];
    } else {
      throw new TypeError("Fold 'fold' should be an Array of Strings.");
    }
    return this;
  }
  by(b) {
    if (isInstanceOf(b, String)) {
      this._by = b;
    } else {
      throw new TypeError("Fold 'by' should be a String.");
    }
    return this;
  }
  exclude(e) {
    if (isInstanceOf(e, Boolean)) {
      this._exclude = e;
    } else {
      throw new TypeError("Fold 'exclude' should be Boolean.");
    }
    return this;
  }
  as(a) {
    if (isInstanceOf(a, Array) && a.length == 2 && a.every((d) => isInstanceOf(d, String))) {
      this._as = [...a];
    } else {
      throw new TypeError("Fold 'fold' should be an Array of two Strings.");
    }
    return this;
  }
  get() {
    return {
      fold: this._fold,
      by: this._by,
      exclude: this._exclude,
      as: this._as
    };
  }
  clone() {
    let _c2 = new _Fold();
    if (this._fold)
      _c2._fold = deepcopy(this._fold);
    if (this._by)
      _c2._by = deepcopy(this._by);
    if (this._exclude)
      _c2._exclude = deepcopy(this._exclude);
    if (this._as)
      _c2._as = deepcopy(this._as);
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-transform.js
var SupportedTransforms = [
  Aggregate.name,
  Bin.name,
  Calculate.name,
  Density.name,
  Filter.name,
  Fold.name
];
var Transform = class _Transform {
  constructor() {
    this.transform = [];
  }
  add(tf) {
    if (isInstanceOf(tf, Aggregate) || isInstanceOf(tf, Bin) || isInstanceOf(tf, Filter) || isInstanceOf(tf, Calculate) || isInstanceOf(tf, Density) || isInstanceOf(tf, Fold)) {
      this.transform.push(tf);
    } else {
      throw new TypeError(`A transform item must be created using a proper Erie's Transform classes: ${SupportedTransforms.join(", ")}.`);
    }
    return this;
  }
  get() {
    return this.transform.map((tf) => tf.get());
  }
  clone() {
    let c = new _Transform();
    this.transform.forEach((tf) => c.add(tf.clone()));
    return c;
  }
};

// node_modules/erie-web/src/classes/erie-synth.js
var FM = "FM";
var AM = "AM";
var SINE = "sine";
var SQUARE = "square";
var SAWTOOTH = "sawtooth";
var TRIANGLE = "triangle";
var SynthTypes = [FM, AM];
var OscTypes = [SINE, SQUARE, SAWTOOTH, TRIANGLE];
var SynthTone2 = class _SynthTone {
  constructor(name2) {
    this._name;
    if (!name2) {
      throw new Error("A sampled tone must have a name.");
    }
    this.name(name2);
    this._type = "FM";
    this._carrierType = "sine";
    this._carrierPitch = 220;
    this._carrierDetune = 0;
    this._modulatorType = "sine";
    this._modulatorPitch = 440;
    this._modulatorVolume = 0.2;
    this._modulation = 1;
    this._harmonicity = 1;
    this._attackTime = 0;
    this._releaseTime = 0;
  }
  name(n2) {
    if (isInstanceOf(n2, String)) {
      this._name = n2;
    } else {
      throw new TypeError("The name of a synth tone must be String.");
    }
    return this;
  }
  type(t2) {
    if (SynthTypes.includes(t2)) {
      this._type = t2;
    } else {
      throw new TypeError(`The type of a synth tone must be either one of ${SynthTypes.join(", ")}.`);
    }
    return this;
  }
  carrierType(t2) {
    if (OscTypes.includes(t2)) {
      this._carrierType = t2;
    } else {
      throw new TypeError(`The type of a synth carrier must be either one of ${OscTypes.join(", ")}.`);
    }
    return this;
  }
  carrierPitch(p) {
    if (isInstanceOf(p, Number)) {
      this._carrierPitch = p;
    } else {
      throw new TypeError(`The pitch of a synth carrier must be Number.`);
    }
    return this;
  }
  carrierDetune(p) {
    if (isInstanceOf(p, Number) && p >= -1200 && p <= 1200) {
      this._carrierDetune = p;
    } else {
      throw new TypeError(`The detune of a synth carrier must be Number and within [-1200, 1200].`);
    }
    return this;
  }
  modulatorType(t2) {
    if (OscTypes.includes(t2)) {
      this._modulatorType = t2;
    } else {
      throw new TypeError(`The type of a synth modulator must be either one of ${OscTypes.join(", ")}.`);
    }
    return this;
  }
  modulatorPitch(p) {
    if (isInstanceOf(p, Number)) {
      this._modulatorPitch = p;
    } else {
      throw new TypeError(`The pitch of a synth modulator must be Number.`);
    }
    return this;
  }
  modulatorVolume(p) {
    if (isInstanceOf(p, Number) && p >= 0 && p <= 1) {
      this.modulatorVolume = p;
    } else {
      throw new TypeError(`The volume of a synth modulator must be Number and within [0, 1].`);
    }
    return this;
  }
  modulation(p) {
    if (this._type === AM) {
      console.warn("Moudlation index for an AM synth will be ignored.");
    }
    if (isInstanceOf(p, Number) && p > 0) {
      this._modulation = p;
    } else {
      throw new TypeError(`The moudlation index of a synth tone must be Number and greater than 0.`);
    }
    return this;
  }
  harmonicity(p) {
    if (this._type === FM) {
      console.warn("Harmonicity for an FM synth will be ignored.");
    }
    if (isInstanceOf(p, Number) && p > 0) {
      this._harmonicity = p;
    } else {
      throw new TypeError(`The harmonicity of a synth tone must be Number and greater than 0.`);
    }
    return this;
  }
  attackTime(p) {
    if (isInstanceOf(p, Number) && p > 0) {
      this._attackTime = p;
    } else {
      throw new TypeError(`The attack time of a synth tone must be Number and greater than -.`);
    }
    return this;
  }
  releaseTime(p) {
    if (isInstanceOf(p, Number) && p > 0) {
      this._releaseTime = p;
    } else {
      throw new TypeError(`The release time of a synth tone must be Number and greater than -.`);
    }
    return this;
  }
  get() {
    return {
      name: this._name,
      type: this._type,
      carrierType: this._carrierType,
      carrierPitch: this._carrierPitch,
      carrierDetune: this._carrierDetune,
      modulatorType: this._modulatorType,
      modulatorPitch: this._modulatorPitch,
      modulatorVolume: this._modulatorVolume,
      modulation: this._modulation,
      harmonicity: this._harmonicity,
      attackTime: this._attackTime,
      releaseTime: this._releaseTime
    };
  }
  clone() {
    let _c2 = new _SynthTone(this._name);
    _c2._type = this._type;
    _c2._carrierType = this._carrierType;
    _c2._carrierPitch = this._carrierPitch;
    _c2._carrierDetune = this._carrierDetune;
    _c2._modulatorType = this._modulatorType;
    _c2._modulatorPitch = this._modulatorPitch;
    _c2._modulatorVolume = this._modulatorVolume;
    _c2._modulation = this._modulation;
    _c2._harmonicity = this._harmonicity;
    _c2._attackTime = this._attackTime;
    _c2._releaseTime = this._releaseTime;
    return _c2;
  }
};
var Synth = class _Synth {
  constructor() {
    this.synth = [];
  }
  add(a) {
    if (isInstanceOf(a, SynthTone2)) {
      this.synth.push(a);
    } else {
      throw new TypeError("A synth tone must be created using SynthTone class.");
    }
    return this;
  }
  get() {
    return this.synth.map((d) => d.get());
  }
  clone() {
    let _c2 = new _Synth();
    _c2.synth = this.synth.map((d) => d.clone());
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-sampling.js
function scaleKeyCheck(key2) {
  return key2.match(/^[C][0-7]$/);
}
var SampledTone = class _SampledTone {
  constructor(name2, s) {
    this._name;
    this._sample = {};
    if (!name2) {
      throw new Error("A sampled tone must have a name.");
    }
    if (!s) {
      throw new Error("A sampled tone must have a sampling object.");
    }
    this.setName(name2);
    this.setSample(s);
  }
  setName(n2) {
    if (isInstanceOf(n2, String)) {
      this._name = n2;
    } else {
      throw new TypeError("The name of a sampled tone must be String.");
    }
    return this;
  }
  setSample(s) {
    Object.keys(s).forEach((k) => {
      if (k === "mono") {
        this._sample.mono = s[k];
      } else if (!scaleKeyCheck(k)) {
        throw new TypeError('The key of a sampling object should be "C" + "0-7".');
      } else {
        this._sample[k] = s[k];
      }
    });
    return this;
  }
  get() {
    return {
      name: this._name,
      sample: deepcopy(this._sample || {})
    };
  }
  clone() {
    let _c2 = new _SampledTone(this._name, deepcopy(this._sample || {}));
    return _c2;
  }
};
var Sampling = class _Sampling {
  constructor() {
    this.sampling = [];
  }
  add(a) {
    if (isInstanceOf(a, SampledTone)) {
      this.sampling.push(a);
    } else {
      throw new TypeError("A sampled tone must be created using SampledTone class.");
    }
    return this;
  }
  get() {
    return this.sampling.map((d) => d.get());
  }
  clone() {
    let _c2 = new _Sampling();
    _c2.sampling = this.sampling.map((d) => d.clone());
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-wave.js
var WaveTone = class {
  constructor(name2, defs) {
    this._name;
    if (!name2) {
      throw new Error("A sampled tone must have a name.");
    }
    this.setName(name2);
    this._disableNormalization = false;
    this._real = [];
    this._imag = [];
    if (defs) {
      this.wave(defs);
    }
  }
  setName(n2) {
    if (isInstanceOf(n2, String)) {
      this._name = n2;
    } else {
      throw new TypeError("The name of a synth tone must be String.");
    }
    return this;
  }
  real(r) {
    if (isArrayOf(r, Number)) {
      this._real = r;
    } else {
      throw new TypeError('The "real" property (sine terms) of a periodic wave must be an Array of Numbers.');
    }
    return this;
  }
  imag(a) {
    if (isArrayOf(a, Number)) {
      this._imag = a;
    } else {
      throw new TypeError('The "imag" property (cosine terms) of a periodic wave must be an Array of Numbers.');
    }
    return this;
  }
  wave(w) {
    if (isInstanceOf(w, Object) && w.real && w.imag) {
      this.real(w.real);
      this.imag(w.imag);
    } else {
      throw new TypeError('The definition a periodic wave must consist of "real" (sine terms) and "imag" (cosine terms) properties.');
    }
    return this;
  }
  disableNormalization(v) {
    if (isInstanceOf(v, Boolean)) {
      this._disableNormalization = v;
    } else {
      throw new TypeError(`The 'disableNormalization' value should be a Boolean.`);
    }
    return this;
  }
  get() {
    return {
      name: this._name,
      real: [...this._real],
      imag: [...this._imag],
      disableNormalization: this._disableNormalization
    };
  }
  clone() {
    let _c2 = new SynthTone(this._name);
    _c2._real = [...this._real];
    _c2._imag = [...this._imag];
    _c2._disableNormalization = this._disableNormalization;
    return _c2;
  }
};
var Wave = class _Wave {
  constructor() {
    this.wave = [];
  }
  add(a) {
    if (isInstanceOf(a, WaveTone)) {
      this.wave.push(a);
    } else {
      throw new TypeError("A wave tone must be created using WaveTone class.");
    }
    return this;
  }
  get() {
    return this.wave.map((d) => d.get());
  }
  clone() {
    let _c2 = new _Wave();
    _c2.wave = this.wave.map((d) => d.clone());
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-tone.js
var Tone = class _Tone {
  constructor(type, c) {
    this._type = "default";
    this._continued = false;
    if (type)
      this.set(type);
    else
      this.set("default");
    if (c !== void 0)
      this.continued(c);
    this._filter = [];
  }
  set(t2) {
    if (isInstanceOf(t2, SampledTone)) {
      this._type = t2._name;
    } else if (isInstanceOf(t2, SynthTone2)) {
      this._type = t2._name;
    } else if (isInstanceOf(t2, WaveTone)) {
      this._type = t2._name;
    } else if (isInstanceOf(t2, String)) {
      this.type(t2);
    }
  }
  type(t2) {
    if (isInstanceOf(t2, String)) {
      this._type = t2;
    } else {
      throw new TypeError("Tone type should be a String.");
    }
    return this;
  }
  continued(c) {
    if (isInstanceOf(c, Boolean)) {
      this._continued = c;
    } else {
      throw new TypeError("Tone 'continued' should be Boolean.");
    }
    return this;
  }
  addFilter(t2) {
    if (isInstanceOf(t2, String)) {
      this._filter.push(t2);
    } else if (isArrayOf(t2, String)) {
      this._filter.push(...t2);
    } else {
      throw new TypeError("Tone filter should be a String or String Array.");
    }
    return this;
  }
  get() {
    return {
      type: this._type,
      continued: this._continued,
      filter: [...this._filter]
    };
  }
  clone() {
    let _c2 = new _Tone(this._type, this._continued);
    _c2.addFilter(this._filter);
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-tick.js
var Tick = class _Tick {
  constructor(name2) {
    if (name2)
      this.setName(name2);
    else {
      throw new Error("A tick definition must have a name.");
    }
    this._interval = 0.5;
    this._playAtTime0 = true;
    this._oscType = "sine";
    this._pitch = 150;
    this._loudness = 0.4;
  }
  setName(n2) {
    if (isInstanceOf(n2, String)) {
      this._name = n2;
    } else {
      throw new TypeError("The name of a synth tone must be String.");
    }
    return this;
  }
  interval(t2) {
    if (isInstanceOf(n, Number) && n > 0) {
      this._interval = t2;
    } else {
      throw new TypeError("A tick interval must be a Number and greater than 0.");
    }
    return this;
  }
  playAtTime0(t2) {
    if (isInstanceOf(n, Boolean)) {
      this._playAtTime0 = t2;
    } else {
      throw new TypeError('A tick "playAtTime0" must be Boolean.');
    }
    return this;
  }
  oscType(t2) {
    if (OscTypes.includes(t2)) {
      this._oscType = t2;
    } else {
      throw new TypeError(`A tick oscillator type must be either one of ${OscTypes.join(", ")}.`);
    }
    return this;
  }
  pitch(t2) {
    if (isInstanceOf(n, Number) && n > 0) {
      this._pitch = t2;
    } else {
      throw new TypeError("A tick pitch must be a Number and greater than 0.");
    }
    return this;
  }
  loudness(t2) {
    if (isInstanceOf(n, Number) && n >= 0 && n <= 1) {
      this._loudness = t2;
    } else {
      throw new TypeError("A tick loudness must be a Number and between 0 and 1.");
    }
    return this;
  }
  get() {
    return {
      name: this._name,
      interval: this._interval,
      playAtTime0: this._playAtTime0,
      oscType: this._oscType,
      pitch: this._pitch,
      loudness: this._loudness
    };
  }
  clone() {
    let _c2 = new _Tick(this._name);
    _c2.interval(this._interval);
    _c2.pitch(this._playAtTime0);
    _c2.oscType(this._oscType);
    _c2.pitch(this._pitch);
    _c2.loudness(this._loudness);
    return _c2;
  }
};
var TickList = class {
  constructor() {
    this.tick = [];
  }
  add(a) {
    if (isInstanceOf(a, Tick)) {
      this.tick.push(a);
    } else {
      throw new TypeError("A tick definition must be created using Tick class.");
    }
    return this;
  }
  get() {
    return this.tick.map((d) => d.get());
  }
  clone() {
    let _c2 = new Tick();
    _c2.tick = this.tick.map((d) => d.clone());
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-channel-constants.js
var TIME_chn = "time";
var TIME2_chn = "time2";
var DUR_chn = "duration";
var TAPCNT_chn = "tapCount";
var TAPSPD_chn = "tapSpeed";
var POST_REVERB_chn = "postReverb";
var PITCH_chn = "pitch";
var LOUDNESS_chn = "loudness";
var PAN_chn = "pan";
var SPEECH_BEFORE_chn = "speechBefore";
var SPEECH_AFTER_chn = "speechAfter";
var TIMBRE_chn = "timbre";
var MODULATION_chn = "modulation";
var HARMONICITY_chn = "harmonicity";
var DETUNE_chn = "detune";
var REPEAT_chn = "repeat";

// node_modules/erie-web/src/classes/erie-channel.js
var QUANT = "quantitative";
var ORD = "ordinal";
var NOM = "nominal";
var TMP = "temporal";
var STATIC = "static";
var SupportedEncodingTypes = [QUANT, ORD, NOM, TMP, STATIC];
var POS2 = "positive";
var NEG = "negative";
var SupportedPolarity = [POS2, NEG];
var RampMethods = [true, false, "abrupt", "linear", "exponential"];
var SingleTapPosOptions = ["start", "middle", "end"];
var REL = "relative";
var ABS = "absolute";
var SIM = "simultaneous";
var TIMINGS = [REL, ABS, SIM];
var FormatTypes = ["number", "datetime"];
var Channel = class {
  constructor(f, t2) {
    this.defined = false;
    this._channel = void 0;
    this._field;
    this._type;
    if (f) {
      this.field(f, t2);
    }
    this._ramp = "linear";
    this._aggregate;
    this._bin;
    this._scale = {};
    this._condition;
    this._value;
    this._format;
    this._formatType;
  }
  set(c) {
    if (isInstanceOfByName(c, `TimeChannel`) || isInstanceOfByName(c, `Time2Channel`) || isInstanceOfByName(c, `DurationChannel`) || isInstanceOfByName(c, `TapSpeedChannel`) || isInstanceOfByName(c, `TapCountChannel`) || isInstanceOfByName(c, `PitchChannel`) || isInstanceOfByName(c, `DetuneChannel`) || isInstanceOfByName(c, `LoudnessChannel`) || isInstanceOfByName(c, `PanChannel`) || isInstanceOfByName(c, `PostReverbChannel`) || isInstanceOfByName(c, `SpeechBeforeChannel`) || isInstanceOfByName(c, `SpeechAfterChannel`) || isInstanceOfByName(c, `RepeatChannel`) || isInstanceOfByName(c, `ModulationChannel`) || isInstanceOfByName(c, `HarmonicityChannel`) || isInstanceOfByName(c, `Channel`)) {
      let g = c.get();
      Object.assign(this, g);
    }
  }
  field(f, t2) {
    if (f === void 0) {
      this._field = void 0;
    } else if (isInstanceOf(f, String)) {
      this._field = f;
    } else if (this._channel === REPEAT_chn && isArrayOf(f, String)) {
      this._field = f;
    } else {
      throw new TypeError("A field for an encoding channel must be a String.");
    }
    if (t2)
      this.type(t2);
    this.defined = true;
    return this;
  }
  type(t2) {
    if (isInstanceOf(t2, String) && SupportedEncodingTypes.includes(t2)) {
      this._type = t2;
    } else {
      throw new TypeError(`A type for an encoding channel must be a String and either one of ${SupportedEncodingTypes.join(", ")}.`);
    }
    return this;
  }
  ramp(r) {
    if (RampMethods.includes(r)) {
      if (isInstanceOf(r, String)) {
        this._ramp = r;
      } else {
        this._ramp = r ? "linear" : "abrupt";
      }
    } else {
      throw new TypeError(`A ramping method for an encoding channel must be either one of ${RampMethods.join(", ")}.`);
    }
  }
  aggregate(op) {
    if (ZeroOPs.includes(op)) {
      if (this._field) {
        console.warn("A count aggregate will drop the existing field.");
      }
      this._aggregate = op;
      this._type = QUANT;
      this.defined = true;
    } else if (SingleOps.includes(op)) {
      this._aggregate = op;
      this._type = QUANT;
      this.defined = true;
    } else if (DoubleOps.includes(op)) {
      throw new TypeError("An aggregate operation for two fields cannot be declared here.");
    } else {
      throw new TypeError(`The provided operation ${op} is not supported.`);
    }
    return this;
  }
  bin(...args) {
    let is_bin, nice, maxbins, step, exact;
    if (args.length == 1) {
      if (isInstanceOf(args[0], Boolean)) {
        is_bin = args[0];
      } else if (isArrayOf(args[0], Number)) {
        is_bin = true;
        exact = args[0];
      }
    } else if (args.length >= 2 && args.length <= 3) {
      is_bin = true;
      [maxbins, nice, step] = args;
    } else {
      throw new TypeError(`Wrong argumetn is provided for a channel's bin.`);
    }
    this._bin = is_bin;
    if (maxbins || nice || step) {
      this._bin = {
        maxbins,
        nice,
        step
      };
    }
    this.defined = true;
    return this;
  }
  scale(p, v) {
    if (p === "domain" && isInstanceOf(v, Array)) {
      this._scale.domain = [...v];
    } else if (p === "range" && isInstanceOf(v, Object) && v.field) {
      this._scale.range = deepcopy(v);
    } else if (p === "range" && isInstanceOf(v, Array)) {
      if (v.every(this.validator)) {
        this._scale.range = [...v];
        if (this._scale.times !== void 0 || this._scale.maxDistinct !== void 0) {
          console.warn("Existing scale settings will be ignored.");
          this._scale.times = void 0;
          this._scale.maxDistinct = void 0;
        }
      } else {
        throw new TypeError("Unsupported value type");
      }
    } else if (p === "order" && isInstanceOf(v, Array)) {
      this._scale.order = v;
    } else if (p === "polarity" && SupportedPolarity.includes(v)) {
      this._scale.polarity = v;
    } else if (p === "maxDistinct" && isInstanceOf(v, Boolean)) {
      this._scale.maxDistinct = v;
      if (this._scale.range !== void 0 || this._scale.times !== void 0) {
        console.warn("Existing scale settings will be ignored.");
        this._scale.range = void 0;
        this._scale.times = void 0;
      }
    } else if (p === "times" && isInstanceOf(v, Number)) {
      this._scale.times = v;
      if (this._scale.range !== void 0 || this._scale.maxDistinct !== void 0) {
        console.warn("Existing scale settings will be ignored.");
        this._scale.range = void 0;
        this._scale.maxDistinct = void 0;
      }
    } else if (p === "zero" && isInstanceOf(v, Boolean)) {
      this._scale.zero = v;
    } else if (p === "description" && (isInstanceOf(v, String) || v == null)) {
      this._scale.description = v;
    } else if (p === "title" && (isInstanceOf(v, String) || v == null)) {
      this._scale.title = v;
    } else if (this._channel === TIME_chn && p === "length" && isInstanceOf(v, Number)) {
      this._scale.length = v;
    } else if ([TIME_chn, TAPCNT_chn, TAPSPD_chn].includes(this._channel) && p === "band" && isInstanceOf(v, Number)) {
      this._scale.band = v;
    } else if (this._channel === TIME_chn && p === "timing" && TIMINGS.includes(v)) {
      this._scale.timing = v;
    } else if (this._channel === TAPSPD_chn && p === "singleTappingPosition" && SingleTapPosOptions.includes(v)) {
      this._scale.timing = v;
    } else {
      throw new Error("The provide key and value is not a supported scale option.");
    }
    this.defined = true;
    return this;
  }
  addCondition(c, o) {
    if (isInstanceOf(c, String) && o !== void 0) {
      if (!this._condition)
        this._condition = [];
      this._condition.push({
        test: c,
        value: o
      });
      if (this._type !== STATIC) {
        console.warn("The type of this channel is changed to static, and the scales will be droped.");
        this._type = STATIC;
        this._scale = {};
      }
    } else {
      throw new Error("The provide condition and value is not a supported condition.");
    }
    this.defined = true;
    return this;
  }
  addConditions(c) {
    for (const cond of c) {
      if (cond.test && cond.value)
        this.addCondition(cond.test, cond.value);
    }
    this.defined = true;
    return this;
  }
  getConditions() {
    return this._condition ? deepcopy(this._condition) : this._condition;
  }
  removeCondition(i2) {
    if (isInstanceOf(this._condition, Array)) {
      this._condition.splice(i2, 1);
    }
  }
  resetCondition() {
    return this._condition = void 0;
  }
  value(v) {
    if (this.validator(v)) {
      this._value = v;
      if (this._type !== STATIC) {
        console.warn("The type of this channel is changed to static, and the scales will be droped.");
        this._type = STATIC;
        this._scale = {};
        this._field = void 0;
        this._aggregate = void 0;
        this._bin = void 0;
      }
    } else {
      throw new TypeError("Unsupported value type");
    }
    this.defined = true;
    return this;
  }
  speech(v) {
    if (this._channel === REPEAT_chn) {
      if (isInstanceOf(v, Boolean)) {
        this._speech = v;
      } else {
        throw new TypeError('The "speech" option for a channel must be Boolean.');
      }
    } else {
      throw new Error("Speech option is only for a repeat channel.");
    }
    this.defined = true;
    return this;
  }
  tick(k, v) {
    if (this._channel === TIME_chn) {
      if (isInstanceOf(k, String)) {
        if (!this._tick)
          this._tick = {};
        if (k === "name" && isInstanceOf(v, String)) {
          this._tick.name = v;
        } else if (k === "interval" && isInstanceOf(v, Number)) {
          this._tick.interval = v;
        } else if (k === "playAtTime0" && isInstanceOf(v, Boolean)) {
          this._tick.playAtTime0 = v;
        } else if (k === "oscType" && OscTypes.includes(v)) {
          this._tick.playAtTime0 = v;
        } else if (k === "pitch" && isInstanceOf(v, Number)) {
          this._tick.pitch = v;
        } else if (k === "loudness" && isInstanceOf(v, Number) && 0 <= v && v <= 1) {
          this._tick.loudness = v;
        }
      } else if (isInstanceOf(k, Tick)) {
        this._tick = { name: k._name };
      } else {
        throw new TypeError('The "speech" option for a channel must be Boolean.');
      }
    } else {
      throw new Error("Speech option is only for a time channel.");
    }
    this.defined = true;
    return this;
  }
  format(f, t2) {
    if (f && t2 && isInstanceOf(f, String) && FormatTypes.includes(t2)) {
      this._format = f;
      this._formatType = t2;
    } else if (f && isInstanceOf(f, String)) {
      this._format = f;
    } else {
      throw new TypeError(`The "format" should be a String and "formatType" should be either ${FormatTypes.join(", ")}.`);
    }
  }
  formatType(t2) {
    if (FormatTypes.includes(t2)) {
      this._formatType = t2;
    } else {
      throw new TypeError(`The "formatType" should be either ${FormatTypes.join(", ")}.`);
    }
  }
  get() {
    let o = {
      type: this._type,
      field: this._field,
      channel: this._channel,
      aggregate: this._aggregate,
      bin: this._bin ? deepcopy(this._bin) : this._bin,
      scale: this._scale ? deepcopy(this._scale) : this._scale,
      value: this._value,
      condition: this._condition ? deepcopy(this._condition) : this._condition,
      ramp: this._ramp,
      defined: this.defined
    };
    if (this._channel === TIME_chn) {
      o.tick = this._tick ? deepcopy(this._tick) : this._tick;
    }
    if (this._channel === REPEAT_chn) {
      o.tick = this._speech;
    }
    return o;
  }
  validator(v) {
    return true;
  }
  clone() {
    let _c2 = new this.constructor();
    let _g2 = this.get();
    Object.keys(_g2).forEach((k) => {
      if (k !== "defined") {
        _c2["_" + k] = _g2[k];
      } else {
        _c2.defined = _g2[k];
      }
    });
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-config.js
var Config = class _Config {
  constructor() {
    this._config = {
      speechRate: 1.75,
      skipScaleSpeech: false,
      skipDescription: false,
      skipTitle: false,
      overlayScaleConsistency: true,
      forceOverlayScaleConsistency: false,
      sequenceScaleConsistency: true,
      forceSequenceScaleConsistency: false
    };
  }
  set(k, v) {
    if (configValidator(k, v)) {
      this._config[k] = v;
    } else {
      throw TypeError(`Wrong value type for ${k}.`);
    }
    return this;
  }
  get() {
    return deepcopy(this._config);
  }
  clone() {
    let _c2 = new _Config();
    let g = this.get();
    Object.keys(g).forEach((k) => {
      _c2.set(k, g[k]);
    });
  }
};
function configValidator(k, v) {
  if (k === "speechRate")
    return isInstanceOf(v, Number) && v > 0;
  else if (k === "skipScaleSpeech")
    return isInstanceOf(v, Boolean);
  else if (k === "skipDescription")
    return isInstanceOf(v, Boolean);
  else if (k === "skipTitle")
    return isInstanceOf(v, Boolean);
  else if (k === "overlayScaleConsistency")
    return isInstanceOf(v, Boolean);
  else if (k === "forceOverlayScaleConsistency")
    return isInstanceOf(v, Boolean);
  else if (k === "sequenceScaleConsistency")
    return isInstanceOf(v, Boolean);
  else if (k === "forceSequenceScaleConsistency")
    return isInstanceOf(v, Boolean);
  else
    return true;
}

// node_modules/erie-web/src/classes/erie-channels.js
var TimeChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = TIME_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v >= 0;
  }
};
var Time2Channel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = TIME2_chn;
  }
};
var DurationChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = DUR_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v >= 0;
  }
};
var MAX_LIMIT_TAP_SPEED = 7;
var TapSpeedChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = TAPSPD_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v >= 0 && v <= MAX_LIMIT_TAP_SPEED;
  }
};
var TapCountChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = TAPCNT_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v >= 0;
  }
};
var MAX_LIMIT_PITCH = 3e3;
var PitchChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = PITCH_chn;
    this.roundToNote = false;
  }
  roundToNote(v) {
    if (isInstanceOf(v, Boolean)) {
      this.roundToNote = v;
    } else {
      throw new TypeError("Round-to-note for a pitch channel must be Boolean");
    }
    return this;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v >= 0 && v <= MAX_LIMIT_PITCH || isInstanceOf(v, String) && v.match(/^[A-F][0-9]$/gi);
  }
};
var DetuneChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = DETUNE_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v >= -1200 && v <= 1200;
  }
};
var LoudnessChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = LOUDNESS_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number);
  }
};
var PanChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = PAN_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v >= -1 && v <= 1;
  }
};
var PostReverbChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = POST_REVERB_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v >= 0;
  }
};
var SpeechBeforeChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = SPEECH_BEFORE_chn;
  }
};
var SpeechAfterChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = SPEECH_AFTER_chn;
  }
};
var RepeatChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = REPEAT_chn;
  }
};
var ModulationChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = MODULATION_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v > 0;
  }
};
var HarmonicityChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = HARMONICITY_chn;
  }
  validator(v) {
    return isInstanceOf(v, Number) && v > 0;
  }
};
var TimbreChannel = class extends Channel {
  constructor(f, t2) {
    super(f, t2);
    this._channel = TIMBRE_chn;
  }
  validator(v) {
    return isInstanceOf(v, String);
  }
};

// node_modules/erie-web/src/classes/erie-stream.js
var Stream = class _Stream {
  constructor() {
    this.data = new Data();
    this.datasets = new Datasets();
    this.transform = new Transform();
    this.synth = new Synth();
    this.sampling = new Sampling();
    this.wave = new Wave();
    this.tone = new Tone();
    this.tick = new TickList();
    this.encoding = {
      [TIME_chn]: new TimeChannel(),
      [TIME2_chn]: new Time2Channel(),
      [DUR_chn]: new DurationChannel(),
      [TAPCNT_chn]: new TapCountChannel(),
      [TAPSPD_chn]: new TapSpeedChannel(),
      [POST_REVERB_chn]: new PostReverbChannel(),
      [PITCH_chn]: new PitchChannel(),
      [DETUNE_chn]: new DetuneChannel(),
      [LOUDNESS_chn]: new LoudnessChannel(),
      [PAN_chn]: new PanChannel(),
      [SPEECH_BEFORE_chn]: new SpeechBeforeChannel(),
      [SPEECH_AFTER_chn]: new SpeechAfterChannel(),
      [TIMBRE_chn]: new TimbreChannel(),
      [REPEAT_chn]: new RepeatChannel(),
      [MODULATION_chn]: new ModulationChannel(),
      [HARMONICITY_chn]: new HarmonicityChannel()
    };
    this.config = new Config();
  }
  name(n2) {
    if (isInstanceOf(n2, String)) {
      this._name = n2;
    } else {
      throw new TypeError("An stream name must be a String.");
    }
    return this;
  }
  title(n2) {
    if (isInstanceOf(n2, String)) {
      this._title = n2;
    } else {
      throw new TypeError("An stream title must be a String.");
    }
    return this;
  }
  description(n2) {
    if (isInstanceOf(n2, String)) {
      this._description = n2;
    } else {
      throw new TypeError("An stream description must be a String.");
    }
    return this;
  }
  get() {
    var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    let g = {
      name: this._name,
      title: this._title,
      description: this._description,
      data: (_a5 = this.data) == null ? void 0 : _a5.get(),
      datasets: (_b2 = this.datasets) == null ? void 0 : _b2.get(),
      transform: this.transform.get(),
      tick: (_c2 = this.tick) == null ? void 0 : _c2.get(),
      synth: (_d2 = this.synth) == null ? void 0 : _d2.get(),
      sampling: (_e2 = this.sampling) == null ? void 0 : _e2.get(),
      wave: (_f2 = this.wave) == null ? void 0 : _f2.get(),
      tone: (_g2 = this.tone) == null ? void 0 : _g2.get(),
      encoding: {},
      config: (_h2 = this.config) == null ? void 0 : _h2.get()
    };
    Object.keys(this.encoding).forEach((chn) => {
      if (this.encoding[chn].defined) {
        g.encoding[chn] = this.encoding[chn].get();
      }
    });
    return g;
  }
  clone() {
    let _c2 = new _Stream();
    _c2._name = this._name;
    _c2._title = this._title;
    _c2._description = this._description;
    _c2.data = this.data.clone();
    _c2.datasets = this.datasets.clone();
    _c2.transform = this.transform.clone();
    _c2.synth = this.synth.clone();
    _c2.sampling = this.sampling.clone();
    _c2.wave = this.wave.clone();
    _c2.tone = this.tone.clone();
    _c2.encoding = {};
    Object.keys(this.encoding).forEach((chn) => {
      if (this.encoding[chn].defined) {
        _c2.encoding[chn] = this.encoding[chn].clone();
      }
    });
    _c2.config = this.config.clone();
    return _c2;
  }
};

// node_modules/erie-web/src/classes/erie-overlay.js
var Overlay = class {
  constructor(...a) {
    let args = [...a];
    if (isInstanceOf(args[0], String)) {
      this.name(args[0]);
      args.splice(0, 1);
    }
    this.overlay = [];
    if (isArrayOf(args[0], Stream)) {
      this.addStreams(args[0]);
    } else if (isArrayOf(args, Stream)) {
      this.addStreams(args);
    }
    this.datasets = new Datasets();
    this.transform = new Transform();
    this.data = new Data();
    this.sampling = new Sampling();
    this.synth = new Synth();
    this.wave = new Wave();
    this.tick = new TickList();
    this.config = new Config();
  }
  name(n2) {
    if (isInstanceOf(n2, String)) {
      this._name = n2;
    } else {
      throw new TypeError("An overlay name must be a String.");
    }
    return this;
  }
  title(n2) {
    if (isInstanceOf(n2, String)) {
      this._title = n2;
    } else {
      throw new TypeError("An overlay title must be a String.");
    }
    return this;
  }
  description(n2) {
    if (isInstanceOf(n2, String)) {
      this._description = n2;
    } else {
      throw new TypeError("An overlay description must be a String.");
    }
    return this;
  }
  stream(i2) {
    return this.overlay[i2];
  }
  remove(i2) {
    this.overlay.splice(i2, 1);
    return this;
  }
  add(s) {
    if (isInstanceOf(s, Stream)) {
      let clone = s.clone();
      let cloned_datasets = clone.datasets;
      if (cloned_datasets && cloned_datasets.length > 0) {
        for (const ds of cloned_datasets) {
          this.datasets.add(ds);
        }
      }
      clone.datasets = null;
      let cloned_ticks = clone.tick;
      if (cloned_ticks && cloned_ticks.length > 0) {
        for (const ds of cloned_ticks) {
          this.tick.add(ds);
        }
      }
      clone.tick = null;
      let cloned_samples = clone.sampling;
      if (cloned_samples && cloned_samples.length > 0) {
        for (const ds of cloned_samples) {
          this.sampling.add(ds);
        }
      }
      clone.sampling = null;
      let cloned_synths = clone.synth;
      if (cloned_synths && cloned_synths.length > 0) {
        for (const ds of cloned_synths) {
          this.synth.add(ds);
        }
      }
      clone.synth = null;
      let cloned_waves = clone.wave;
      if (cloned_waves && cloned_waves.length > 0) {
        for (const ds of cloned_waves) {
          this.wave.add(ds);
        }
      }
      clone.wave = null;
      this.overlay.push(clone);
    }
    return this;
  }
  addStreams(ss) {
    for (const s of ss) {
      this.add(s);
    }
    return this;
  }
  get() {
    let g = {
      name: this._name,
      title: this._title,
      description: this._description,
      data: this.data.get(),
      datasets: this.datasets.get(),
      transform: this.transform.get(),
      tick: this.tick.get(),
      synth: this.synth.get(),
      sampling: this.sampling.get(),
      wave: this.wave.get(),
      overlay: this.overlay.map((d) => d.get()),
      config: this.config.get()
    };
    return g;
  }
  clone() {
    let _c2 = new Sequence();
    _c2._name = this._name;
    _c2._title = this._title;
    _c2._description = this._description;
    _c2.data = this.data.clone();
    _c2.datasets = this.datasets.clone();
    _c2.transform = this.transform.clone();
    _c2.synth = this.synth.clone();
    _c2.sampling = this.sampling.clone();
    _c2.wave = this.wave.clone();
    _c2.overlay = this.overlay.map((d) => d.clone());
    _c2.config = this.config.clone();
  }
};

// node_modules/erie-web/src/classes/erie-sequence.js
var Sequence2 = class _Sequence {
  constructor(...a) {
    let args = [...a];
    if (isInstanceOf(args[0], String)) {
      this.setName(args[0]);
      args.splice(0, 1);
    }
    this.sequence = [];
    if (isArrayOf(args[0], [Stream, Overlay])) {
      this.addStreams(args[0]);
    } else if (isArrayOf(args, [Stream, Overlay])) {
      this.addStreams(args);
    }
    this.datasets = new Datasets();
    this.transform = new Transform();
    this.data = new Data();
    this.sampling = new Sampling();
    this.synth = new Synth();
    this.wave = new Wave();
    this.tick = new TickList();
    this.config = new Config();
  }
  name(n2) {
    if (isInstanceOf(n2, String)) {
      this._name = n2;
    } else {
      throw new TypeError("A stream name must be a String.");
    }
    return this;
  }
  title(n2) {
    if (isInstanceOf(n2, String)) {
      this._title = n2;
    } else {
      throw new TypeError("A stream title must be a String.");
    }
    return this;
  }
  description(n2) {
    if (isInstanceOf(n2, String)) {
      this._description = n2;
    } else {
      throw new TypeError("A stream description must be a String.");
    }
    return this;
  }
  stream(i2) {
    return this.sequence[i2];
  }
  remove(i2) {
    this.sequence.splice(i2, 1);
    return this;
  }
  add(s) {
    if (isInstanceOf(s, Stream) || isInstanceOf(s, Overlay)) {
      let clone = s.clone();
      let cloned_datasets = clone.datasets;
      if (cloned_datasets && cloned_datasets.length > 0) {
        for (const ds of cloned_datasets) {
          this.datasets.add(ds);
        }
      }
      clone.datasets = null;
      let cloned_ticks = clone.tick;
      if (cloned_ticks && cloned_ticks.length > 0) {
        for (const ds of cloned_ticks) {
          this.tick.add(ds);
        }
      }
      clone.tick = null;
      let cloned_samples = clone.sampling;
      if (cloned_samples && cloned_samples.length > 0) {
        for (const ds of cloned_samples) {
          this.sampling.add(ds);
        }
      }
      clone.sampling = null;
      let cloned_synths = clone.synth;
      if (cloned_synths && cloned_synths.length > 0) {
        for (const ds of cloned_synths) {
          this.synth.add(ds);
        }
      }
      clone.synth = null;
      let cloned_waves = clone.wave;
      if (cloned_waves && cloned_waves.length > 0) {
        for (const ds of cloned_waves) {
          this.wave.add(ds);
        }
      }
      clone.wave = null;
      this.sequence.push(clone);
    }
    return this;
  }
  addStreams(ss) {
    for (const s of ss) {
      this.add(s);
    }
    return this;
  }
  get() {
    let g = {
      name: this._name,
      title: this._title,
      description: this._description,
      data: this.data.get(),
      datasets: this.datasets.get(),
      transform: this.transform.get(),
      tick: this.tick.get(),
      synth: this.synth.get(),
      sampling: this.sampling.get(),
      wave: this.wave.get(),
      sequence: this.sequence.map((d) => d.get()),
      config: this.config.get()
    };
    return g;
  }
  clone() {
    let _c2 = new _Sequence();
    _c2._name = this._name;
    _c2._title = this._title;
    _c2._description = this._description;
    _c2.data = this.data.clone();
    _c2.datasets = this.datasets.clone();
    _c2.transform = this.transform.clone();
    _c2.synth = this.synth.clone();
    _c2.sampling = this.sampling.clone();
    _c2.wave = this.wave.clone();
    _c2.sequence = this.sequence.map((d) => d.clone());
    _c2.config = this.config.clone();
  }
};

// node_modules/erie-web/src/classes/erie-audio-filter.js
var ErieFilters = {};
function registerFilter(name2, filter, encoder3, finisher) {
  ErieFilters[name2] = { filter, encoder: encoder3, finisher };
}

// node_modules/erie-web/src/util/audio-graph-speech.js
async function playSystemSpeech(sound, config) {
  return new Promise((resolve2, reject) => {
    var synth = window.speechSynthesis;
    var utterance = new SpeechSynthesisUtterance(sound.speech);
    if ((config == null ? void 0 : config.speechRate) !== void 0)
      utterance.rate = config == null ? void 0 : config.speechRate;
    else if ((sound == null ? void 0 : sound.speechRate) !== void 0)
      utterance.rate = sound == null ? void 0 : sound.speechRate;
    synth.speak(utterance);
    utterance.onend = () => {
      resolve2();
    };
  });
}
async function notifyStop(config) {
  await playSystemSpeech({ speech: "Stopped.", speechRate: config == null ? void 0 : config.speechRate });
  return;
}
async function notifyPause(config) {
  await playSystemSpeech({ speech: "Paused.", speechRate: config == null ? void 0 : config.speechRate });
  return;
}
async function notifyResume(config) {
  await playSystemSpeech({ speech: "Resumeing", speechRate: config == null ? void 0 : config.speechRate });
  return;
}

// node_modules/erie-web/src/player/audio-graph-instrument-sample.js
var SupportedInstruments = ["piano", "pianoElec", "violin", "metal", "guitar", "hithat", "snare", "highKick", "lowKick", "clap"];
var MultiNoteInstruments = ["piano", "pianoElec", "violin", "metal", "guitar"];
var SingleNoteInstruments = ["hithat", "snare", "highKick", "lowKick", "clap"];
var noteFreqRange = [
  {
    octave: 0,
    c: 16.35,
    cs: 17.32,
    d: 18.35,
    ds: 19.45,
    e: 20.6,
    f: 21.83,
    fs: 23.12
  },
  {
    octave: 1,
    gf: 23.12,
    g: 24.5,
    af: 25.96,
    a: 27.5,
    bf: 29.14,
    b: 30.87,
    c: 32.7,
    cs: 34.65,
    d: 36.71,
    ds: 38.89,
    e: 41.2,
    f: 43.65,
    fs: 46.25
  },
  {
    octave: 2,
    gf: 46.25,
    g: 49,
    af: 51.91,
    a: 55,
    bf: 58.27,
    b: 61.74,
    c: 65.41,
    cs: 69.3,
    d: 73.42,
    ds: 77.78,
    e: 82.41,
    f: 87.31,
    fs: 92.5
  },
  {
    octave: 3,
    gf: 92.5,
    g: 98,
    af: 103.83,
    a: 110,
    bf: 116.54,
    b: 123.47,
    c: 130.81,
    cs: 138.59,
    d: 146.83,
    ds: 155.56,
    e: 164.81,
    f: 174.61,
    fs: 185
  },
  {
    octave: 4,
    gf: 185,
    g: 196,
    af: 207.65,
    a: 220,
    bf: 233.08,
    b: 246.94,
    c: 261.63,
    cs: 277.18,
    d: 293.66,
    ds: 311.13,
    e: 329.63,
    f: 349.23,
    fs: 369.99
  },
  {
    octave: 5,
    gf: 369.99,
    g: 392,
    af: 415.3,
    a: 440,
    bf: 466.16,
    b: 493.88,
    c: 523.25,
    cs: 554.37,
    d: 587.33,
    ds: 622.25,
    e: 659.25,
    f: 698.46,
    fs: 739.99
  },
  {
    octave: 6,
    gf: 739.99,
    g: 783.99,
    af: 830.61,
    a: 880,
    bf: 932.33,
    b: 987.77,
    c: 1046.5,
    cs: 1108.73,
    d: 1174.66,
    ds: 1244.51,
    e: 1318.51,
    f: 1396.91,
    fs: 1479.98
  },
  {
    octave: 7,
    gf: 1479.98,
    g: 1567.98,
    af: 1661.22,
    a: 1760,
    bf: 1864.66,
    b: 1975.53,
    c: 2093,
    cs: 2217.46,
    d: 2349.32,
    ds: 2489.02,
    e: 2637.02,
    f: 2793.83,
    fs: 2959.96
  }
];
var noteScaleOrder = ["gf", "g", "af", "a", "bf", "b", "c", "cs", "d", "ds", "e", "f", "fs"];
var detuneAmmount = {
  gf: -600,
  g: -500,
  af: -400,
  a: -300,
  bf: -200,
  b: -100,
  c: 0,
  cs: 100,
  d: 200,
  ds: 300,
  e: 400,
  f: 500,
  fs: 600
};
function roundToNote(freq, scales) {
  let min_diff = 5e3, min_diff_note;
  for (const noteName of noteScaleOrder) {
    let diff = Math.abs(scales[noteName] - freq);
    if (diff < min_diff) {
      min_diff = diff;
      min_diff_note = noteName;
    }
  }
  return {
    note_name: min_diff_note,
    prev_note: noteScaleOrder[noteScaleOrder.indexOf(min_diff_note) - 1],
    next_note: noteScaleOrder[noteScaleOrder.indexOf(min_diff_note) + 1],
    note_freq: scales[min_diff_note],
    detune: detuneAmmount[min_diff_note]
  };
}
function roundToNoteScale(freq) {
  let octave;
  for (const range2 of noteFreqRange) {
    if (range2.octave == 0 && range2.c <= freq && freq < range2.fs) {
      octave = range2;
    } else if (range2.octave == 7 && range2.gf <= freq && freq <= range2.fs) {
      octave = range2;
    } else if (range2.gf <= freq && freq < range2.fs) {
      octave = range2;
    }
  }
  if (octave !== void 0) {
    return roundToNote(freq, octave).note_freq;
  } else {
    console.warn(
      "Frequence out of scope. Max possible frequency is 2959.96 and min possible frequency is 16.35."
    );
    return null;
  }
}
function determineNoteRange(freq, config) {
  var _a5, _b2;
  let octave;
  for (const range2 of noteFreqRange) {
    if (range2.octave == 0 && range2.c <= freq && freq < range2.fs) {
      octave = range2;
    } else if (range2.octave == 7 && range2.gf <= freq && freq <= range2.fs) {
      octave = range2;
    } else if (range2.gf <= freq && freq < range2.fs) {
      octave = range2;
    }
  }
  if (octave !== void 0) {
    let rounded_note = roundToNote(freq, octave);
    if (config == null ? void 0 : config.round) {
      return {
        octave: octave.octave,
        original_freq: freq,
        freq: rounded_note.note_freq,
        note: rounded_note.note_name,
        detune: rounded_note.detune
      };
    } else {
      let detune_base = rounded_note.detune;
      let note_diff = rounded_note.note_freq - freq;
      let detune = 0;
      if (note_diff < 0) {
        let note_left = octave[rounded_note.prev_note];
        if (!rounded_note.prev_note) {
          note_left = (_a5 = noteFreqRange[octave.octave - 1]) == null ? void 0 : _a5.f;
        }
        detune = Math.round(-100 * Math.abs(note_diff / (note_left - rounded_note.note_freq))) + detune_base;
        if (!note_left) {
          detune = detune_base;
        }
      } else if (note_diff > 0) {
        let note_right = octave[rounded_note.next_note];
        if (!rounded_note.next_note) {
          note_right = (_b2 = noteFreqRange[octave.octave + 1]) == null ? void 0 : _b2.g;
        }
        detune = Math.round(100 * Math.abs(note_diff / (note_right - rounded_note.note_freq))) + detune_base;
        if (!note_right) {
          detune = detune_base;
        }
      } else {
        detune = detune_base;
      }
      return { octave: octave.octave, freq, detune };
    }
  } else {
    console.warn(
      "Frequence out of scope. Max possible frequency is 2959.96 and min possible frequency is 16.35."
    );
    return null;
  }
}
async function loadSamples(ctx, instrument_name, smaplingDef, baseUrl) {
  var _a5;
  let samples = {};
  if (MultiNoteInstruments.includes(instrument_name)) {
    for (const octave of noteFreqRange) {
      let sampleRes = await fetch(`${baseUrl || ""}audio_sample/${instrument_name}_c${octave.octave}.mp3`);
      let sampleBuffer = await sampleRes.arrayBuffer();
      let source2 = await ctx.decodeAudioData(sampleBuffer);
      samples[`C${octave.octave}`] = source2;
    }
    samples.multiNote = true;
  } else if (SingleNoteInstruments.includes(instrument_name)) {
    samples = await makeSingleScaleSamplingNode(ctx, `${baseUrl || ""}audio_sample/${instrument_name}.mp3`);
    samples.multiNote = false;
  } else if (smaplingDef[instrument_name]) {
    if ((_a5 = smaplingDef[instrument_name].sample) == null ? void 0 : _a5.mono) {
      try {
        samples = await makeSingleScaleSamplingNode(ctx, smaplingDef[instrument_name].sample.mono);
        samples.multiNote = false;
      } catch (e) {
        console.error(e);
      }
    } else {
      try {
        samples = await makeMultiScaleSamplingNode(ctx, smaplingDef[instrument_name].sample);
        samples.multiNote = true;
      } catch (e) {
        console.error(e);
      }
    }
  } else {
    console.warn(`The instrument "${instrument_name}" is not supported or sampled.`);
  }
  return samples;
}
async function makeMultiScaleSamplingNode(ctx, def) {
  let samples = {}, keys = Object.keys(def);
  if (!keys.every(scaleKeyCheck2)) {
    console.error("A sampling note must be 'C' in octave 0 to 7");
  }
  for (const key2 of keys) {
    let sampleRes = await fetch(def[key2]);
    let sampleBuffer = await sampleRes.arrayBuffer();
    let source2 = await ctx.decodeAudioData(sampleBuffer);
    samples[key2] = source2;
  }
  return samples;
}
async function makeSingleScaleSamplingNode(ctx, def) {
  let samples = {};
  let sampleRes = await fetch(def);
  let sampleBuffer = await sampleRes.arrayBuffer();
  let source2 = await ctx.decodeAudioData(sampleBuffer);
  samples.mono = source2;
  return samples;
}
function scaleKeyCheck2(key2) {
  return key2.match(/^[C][0-7]$/);
}

// node_modules/erie-web/src/util/audio-graph-util.js
function unique(arr) {
  return Array.from(new Set(arr));
}
function deepcopy2(i2) {
  return JSON.parse(JSON.stringify(i2));
}
function firstDefined(...vs) {
  for (let v of vs) {
    if (v !== void 0)
      return v;
  }
  return vs[vs.length - 1];
}
function aRange(s, e, incl) {
  let o = [];
  if (incl)
    e = e + 1;
  for (let i2 = s; i2 < e; i2++) {
    o.push(i2);
  }
  return o;
}
function round(n2, d) {
  let e = Math.pow(10, -d);
  return Math.round(n2 * e) / e;
}
var RidLetters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split("");
var NRidLetters = RidLetters.length - 1;
function genRid(n2) {
  if (!n2)
    n2 = 6;
  let rid = [];
  for (let i2 = 0; i2 < n2; i2++) {
    let k = Math.round(Math.random() * NRidLetters);
    rid.push(RidLetters[k]);
  }
  return rid.join("");
}
function getFirstDefined(...args) {
  for (const arg of args) {
    if (arg !== void 0)
      return arg;
  }
  return args[args.length - 1];
}
function asc(a, b) {
  if (typeof a === "number" && typeof b === "number")
    return a - b;
  else if ((a == null ? void 0 : a.constructor.name) === Date.name && (b == null ? void 0 : b.constructor.name) === Date.name)
    return a - b;
  else if (a == null ? void 0 : a.localeCompare)
    return a.localeCompare(b);
  else
    return a > b || 0;
}
function desc(a, b) {
  if (typeof a === "number" && typeof b === "number")
    return b - a;
  else if ((a == null ? void 0 : a.constructor.name) === Date.name && (b == null ? void 0 : b.constructor.name) === Date.name)
    return b - a;
  else if (b == null ? void 0 : b.localeCompare)
    return b.localeCompare(a);
  else
    return b > a || 0;
}

// node_modules/erie-web/src/tick/audio-graph-time-tick.js
var Def_Tick_Interval = 0.5;
var Def_Tick_Interval_Beat = 2;
var Def_Tick_Duration = 0.1;
var Def_Tick_Duration_Beat = 0.5;
var Def_Tick_Loudness = 0.4;
function makeTick(ctx, def, duration) {
  if (!def)
    return;
  else if (duration) {
    let tickPattern = [];
    let interval = round(def.interval, -2);
    let tickDur = def.band;
    tickDur = round(tickDur, -2);
    let pause = interval - tickDur;
    let count2 = Math.floor(duration / interval);
    let totalTime = 0;
    if (def.playAtTime0 === void 0)
      def.playAtTime0 = true;
    if (def.playAtTime0) {
      tickPattern.push({ tick: tickDur });
      totalTime += tickDur;
    }
    for (let i2 = 0; i2 < count2; i2++) {
      tickPattern.push({ pause });
      tickPattern.push({ tick: tickDur });
      totalTime += pause + tickDur;
    }
    if (duration > totalTime) {
      tickPattern.push({ pause: duration - totalTime });
    }
    let tickInst = makeInstrument(ctx, "default");
    tickInst.frequency.value = 150;
    if (def.pitch)
      tickInst.frequency.value = def.pitch;
    if (def.oscType)
      tickInst.type = def.oscType;
    let gain = ctx.createGain();
    tickInst.connect(gain);
    gain.connect(ctx.destination);
    gain.gain.setValueAtTime(0, ctx.currentTime);
    let acc = 0;
    for (const p of tickPattern) {
      if (p.tick) {
        gain.gain.setTargetAtTime(def.loudness || Def_Tick_Loudness, ctx.currentTime + acc, 0.015);
        acc += p.tick;
      } else if (p.pause) {
        gain.gain.setTargetAtTime(0, ctx.currentTime + acc, 0.015);
        acc += p.pause;
      }
    }
    return tickInst;
  }
}

// node_modules/erie-web/src/player/audio-graph-synth.js
var FM2 = "FM";
var AM2 = "AM";
var DefCarrierPitch = 220;
var DefModPitch = 440;
var DefaultModGainAM = 1;
var DefaultModGainFM = 100;
function makeSynth(ctx, definition) {
  let synth = new ErieSynth(ctx, definition.type || FM2);
  synth.generate(definition);
  return synth;
}
var ErieSynth = class {
  constructor(ctx, type) {
    this.ctx = ctx;
    this.frequency = new ErieSynthFrequency(this);
    this.onended;
    this.type = type;
  }
  generate(definition) {
    if (this.type === FM2) {
      this.generateFM(definition);
    } else if (this.type === AM2) {
      this.generateAM(definition);
    }
  }
  generateFM(definition) {
    this.initDef = definition;
    this.carrier = this.ctx.createOscillator();
    this.carrierPitch = definition.carrierPitch !== void 0 ? definition.carrierPitch : DefCarrierPitch;
    this.carrier.frequency.value = this.carrierPitch;
    this.carrier.type = definition.carrierType || "sine";
    this.carrierType = definition.carrierType || "sine";
    if (definition.carrierDetune) {
      this.carrierDetune = definition.carrierDetune;
      this.carrier.detune.value = definition.carrierDetune;
    }
    this.modulator = this.ctx.createOscillator();
    this.modulator.type = definition.modulatorType || "sine";
    this.modulatorType = definition.modulatorType || "sine";
    this.modulatorGain = this.ctx.createGain();
    this.modulatorVolume = definition.modulatorVolume !== void 0 ? definition.modulatorVolume : DefaultModGainFM;
    this.modulatorGain.gain.value = this.modulatorVolume;
    if (definition.modulatorPitch !== void 0) {
      this.modulatorPitch = definition.modulatorPitch;
    } else if (definition.modulation !== void 0) {
      this.modulation = definition.modulation;
      this.modulatorPitch = this.modulatorVolume / this.modulation;
    } else if (definition.harmonicity !== void 0) {
      this.modulatorPitch = definition.harmonicity * this.carrierPitch;
    } else if (this.carrierPitch !== void 0) {
      this.modulatorPitch = this.carrierPitch;
    } else {
      this.modulatorPitch = DefModPitch;
    }
    this.modulator.frequency.value = this.modulatorPitch;
    this.envelope = this.ctx.createGain();
    this.attackTime = definition.attackTime || 0.1;
    this.releaseTime = definition.releaseTime || 0.1;
    this.sustain = definition.sustain || 0.8;
    this.decayTime = definition.decayTime || 0.2;
    this.modulator.connect(this.modulatorGain);
    this.modulatorGain.connect(this.carrier.frequency);
    this.carrier.connect(this.envelope);
  }
  generateAM(definition) {
    this.initDef = definition;
    this.carrier = this.ctx.createOscillator();
    this.carrierPitch = definition.carrierPitch !== void 0 ? definition.carrierPitch : DefCarrierPitch;
    this.carrier.frequency.value = this.carrierPitch;
    this.carrier.type = definition.carrierType || "sine";
    this.carrierType = definition.carrierType || "sine";
    if (definition.carrierDetune) {
      this.carrierDetune = definition.carrierDetune;
      this.carrier.detune.value = definition.carrierDetune;
    }
    this.carrierVolume = definition.carrierVolume || 1;
    this.modulator = this.ctx.createOscillator();
    this.modulator.type = definition.modulatorType || "sine";
    this.modulatorType = definition.modulatorType || "sine";
    this.modulatorGain = this.ctx.createGain();
    if (definition.modulation !== void 0) {
      this.modulation = definition.modulation;
      this.modulatorVolume = (this.carrierVolume || 1) * this.modulation;
    } else {
      this.modulatorVolume = definition.modulatorVolume !== void 0 ? definition.modulatorVolume : DefaultModGainAM;
    }
    this.modulatorGain.gain.value = this.modulatorVolume;
    if (definition.modulatorPitch !== void 0) {
      this.modulatorPitch = definition.modulatorPitch;
    } else if (definition.harmonicity !== void 0) {
      this.modulatorPitch = definition.harmonicity * this.carrierPitch;
    } else if (this.carrierPitch !== void 0) {
      this.modulatorPitch = this.carrierPitch;
    } else {
      this.modulatorPitch = DefModPitch;
    }
    this.modulator.frequency.value = this.modulatorPitch;
    this.envelope = this.ctx.createGain();
    this.attackTime = definition.attackTime || 0.1;
    this.releaseTime = definition.releaseTime || 0.05;
    this.sustain = definition.sustain || 0.8;
    this.decayTime = definition.decayTime || 0.1;
    this.modulator.connect(this.modulatorGain);
    this.modulatorGain.connect(this.carrier.frequency);
    this.carrier.connect(this.envelope);
  }
  connect(node) {
    this.envelope.connect(node);
  }
  start(time2) {
    this.carrier.start(time2);
    this.modulator.start(time2);
  }
  stop(time2) {
    this.carrier.onended = this.onended;
    this.carrier.stop(time2 + this.attackTime + this.releaseTime);
    this.modulator.stop(time2 + this.attackTime + this.releaseTime);
  }
};
var ErieSynthFrequency = class {
  constructor(synther) {
    this.value = 440;
    this.automationRate = "a-rate";
    this.maxValue = 22050;
    this.minValue = -22055;
    this.synther = synther;
  }
  setValueAtTime(value, time2) {
    this.synther.carrier.frequency.setValueAtTime(value, time2);
  }
  setTargetAtTime(value, time2) {
    this.synther.carrier.frequency.setTargetAtTime(value, time2);
  }
};

// node_modules/erie-web/src/player/audio-graph-noise.js
var WhiteNoise = "whiteNoise";
var PinkNoise = "pinkNoise";
var BrownNoise = "brownNoise";
var NoiseTypes = [WhiteNoise, PinkNoise, BrownNoise];
function makeNoiseNode(ctx, type, duration, sound) {
  const bufferSize = ctx.sampleRate * duration;
  const noiseBuffer = new AudioBuffer({
    length: bufferSize,
    sampleRate: ctx.sampleRate
  });
  const data2 = noiseBuffer.getChannelData(0);
  let coeffs = { p0: 0, p1: 0, p2: 0, p3: 0, p4: 0, p5: 0, p6: 0, o: 0 };
  for (let i2 = 0; i2 < bufferSize; i2++) {
    if (type === PinkNoise) {
      PinkNoiseFunction(coeffs);
      data2[i2] = coeffs.o;
    } else if (type === BrownNoise) {
      BrownNoiseFunction(coeffs);
      data2[i2] = coeffs.o;
    } else {
      data2[i2] = WhiteNoiseFunction();
    }
  }
  const noise = ctx.createBufferSource();
  noise.buffer = noiseBuffer;
  return noise;
}
function WhiteNoiseFunction() {
  return Math.random() * 2 - 1;
}
function PinkNoiseFunction(c) {
  let w = WhiteNoiseFunction();
  c.p0 = 0.99886 * c.p0 + w * 0.0555179;
  c.p1 = 0.99332 * c.p1 + w * 0.0750759;
  c.p2 = 0.969 * c.p2 + w * 0.153852;
  c.p3 = 0.8665 * c.p3 + w * 0.3104856;
  c.p4 = 0.55 * c.p4 + w * 0.5329522;
  c.p5 = -0.7616 * c.p5 - w * 0.016898;
  c.o = c.p0 + c.p1 + c.p2 + c.p3 + c.p4 + c.p5 + c.p6 + w * 0.5362;
  c.o *= 0.11;
  c.p6 = w * 0.115926;
}
function BrownNoiseFunction(c) {
  let w = WhiteNoiseFunction();
  c.o = (c.p0 + 0.02 * w) / 1.02;
  c.p0 = c.o;
  c.o *= 3.5;
}

// node_modules/erie-web/src/audioFilters/audio-graph-filter-biquad.js
var BiquadFilter = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.filter = ctx.createBiquadFilter();
    this.destination = this.filter;
  }
  initialize(time2) {
    this.filter.gain.setValueAtTime(1, time2);
  }
  connect(node) {
    this.filter.connect(node);
  }
  disconnect(node) {
    this.filter.disconnect(node);
  }
};
var LowpassBiquadFilter = class extends BiquadFilter {
  constructor(ctx) {
    super(ctx);
    this.filter.type = "lowpass";
    this.destination = this.filter;
  }
  connect(node) {
    this.destination.connect(node);
  }
  disconnect(node) {
    this.destination.disconnect(node);
  }
};
var HighpassBiquadFilter = class extends BiquadFilter {
  constructor(ctx) {
    super(ctx);
    this.filter.type = "highpass";
    this.destination = this.filter;
  }
  connect(node) {
    this.destination.connect(node);
  }
  disconnect(node) {
    this.destination.disconnect(node);
  }
};
var BandpassBiquadFilter = class extends BiquadFilter {
  constructor(ctx) {
    super(ctx);
    this.filter.type = "bandpass";
    this.destination = this.filter;
  }
  connect(node) {
    this.destination.connect(node);
  }
  disconnect(node) {
    this.destination.disconnect(node);
  }
};
var LowshelfBiquadFilter = class extends BiquadFilter {
  constructor(ctx) {
    super(ctx);
    this.filter.type = "lowshelf";
    this.destination = this.filter;
    this.useGain = true;
  }
  connect(node) {
    this.destination.connect(node);
  }
  disconnect(node) {
    this.destination.disconnect(node);
  }
};
var HighshelfBiquadFilter = class extends BiquadFilter {
  constructor(ctx) {
    super(ctx);
    this.filter.type = "highshelf";
    this.destination = this.filter;
    this.useGain = true;
  }
  connect(node) {
    this.destination.connect(node);
  }
  disconnect(node) {
    this.destination.disconnect(node);
  }
};
var PeakingBiquadFilter = class extends BiquadFilter {
  constructor(ctx) {
    super(ctx);
    this.filter.type = "peaking";
    this.destination = this.filter;
    this.useGain = true;
  }
  connect(node) {
    this.destination.connect(node);
  }
  disconnect(node) {
    this.destination.disconnect(node);
  }
};
var NotchBiquadFilter = class extends BiquadFilter {
  constructor(ctx) {
    super(ctx);
    this.filter.type = "notch";
    this.destination = this.filter;
  }
  connect(node) {
    this.destination.connect(node);
  }
  disconnect(node) {
    this.destination.disconnect(node);
  }
};
var AllpassBiquadFilter = class extends BiquadFilter {
  constructor(ctx) {
    super(ctx);
    this.filter.type = "allpass";
    this.destination = this.filter;
  }
  connect(node) {
    this.destination.connect(node);
  }
  disconnect(node) {
    this.destination.disconnect(node);
  }
};
function BiquadEncoder(filter, sound, startTime) {
  var _a5, _b2, _c2, _d2, _e2;
  if (filter.useGain) {
    if (startTime > 0)
      filter.filter.gain.linearRampToValueAtTime(((_a5 = sound == null ? void 0 : sound.others) == null ? void 0 : _a5.biquadGain) || 1, startTime);
    else
      filter.filter.gain.setValueAtTime(((_b2 = sound == null ? void 0 : sound.others) == null ? void 0 : _b2.biquadGain) || 1, startTime);
  }
  if (((_c2 = sound == null ? void 0 : sound.others) == null ? void 0 : _c2.biquadPitch) !== void 0) {
    if (startTime > 0)
      filter.filter.frequency.linearRampToValueAtTime(sound.others.biquadPitch || 1, startTime);
    else
      filter.filter.frequency.setValueAtTime(sound.others.biquadPitch || 1, startTime);
  }
  if (((_d2 = sound == null ? void 0 : sound.others) == null ? void 0 : _d2.biquadQ) !== void 0) {
    if (startTime > 0)
      filter.filter.Q.linearRampToValueAtTime(sound.others.biquadQ || 1, startTime);
    else
      filter.filter.Q.setValueAtTime(sound.others.biquadQ || 1, startTime);
  }
  if (((_e2 = sound == null ? void 0 : sound.others) == null ? void 0 : _e2.biquadDetune) !== void 0) {
    if (startTime > 0)
      filter.filter.detune.linearRampToValueAtTime(sound.others.biquadDetune || 1, startTime);
    else
      filter.filter.detune.setValueAtTime(sound.others.biquadDetune || 1, startTime);
  }
}
function BiquadFinisher(filter, sound, startTime, duration) {
  var _a5, _b2, _c2;
  if (filter.useGain) {
    filter.filter.gain.setValueAtTime((sound == null ? void 0 : sound.others.biquadGain) || 1, startTime + duration);
  }
  if (((_a5 = sound == null ? void 0 : sound.others) == null ? void 0 : _a5.biquadPitch) !== void 0) {
    filter.filter.frequency.setValueAtTime(sound.others.biquadPitch || 1, startTime + duration);
  }
  if (((_b2 = sound == null ? void 0 : sound.others) == null ? void 0 : _b2.biquadQ) !== void 0) {
    filter.filter.Q.setValueAtTime(sound.others.biquadQ || 1, startTime + duration);
  }
  if (((_c2 = sound == null ? void 0 : sound.others) == null ? void 0 : _c2.biquadDetune) !== void 0) {
    filter.filter.detune.setValueAtTime(sound.others.biquadDetune || 1, startTime + duration);
  }
}

// node_modules/erie-web/src/audioFilters/audio-graph-filter-compressor.js
var DefaultDynamicCompressor = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.compressor = ctx.createDynamicsCompressor();
    this.destination = this.compressor;
  }
  initialize() {
    this.compressor.attack.value = 20;
    this.compressor.knee.value = 40;
    this.compressor.ratio.value = 18;
    this.compressor.release.value = 0.25;
    this.compressor.threshold.value = -50;
  }
  finisher() {
  }
  connect(node) {
    this.compressor.connect(node);
  }
  disconnect(node) {
    this.compressor.disconnect(node);
  }
};
function CompressorEncoder(filter, sound, startTime) {
  if (sound.others.dcAttack !== void 0)
    filter.compressor.attack.linearRampToValueAtTime(sound.others.dcAttack || 1, startTime);
  if (sound.others.dcKnee !== void 0)
    filter.compressor.knee.linearRampToValueAtTime(sound.others.dcKnee || 1, startTime);
  if (sound.others.dcRatio !== void 0)
    filter.compressor.ratio.linearRampToValueAtTime(sound.others.dcRatio || 1, startTime);
  if (sound.others.dcReduction !== void 0)
    filter.compressor.release.linearRampToValueAtTime(sound.others.dcReduction || 1, startTime);
  if (sound.others.dcThreshold !== void 0)
    filter.compressor.threshold.linearRampToValueAtTime(sound.others.dcThreshold || 1, startTime);
}
function CompressorFinisher(filter, sound, startTime, duration) {
}

// node_modules/erie-web/src/audioFilters/audio-graph-filter-distortion.js
var DistortionFilter = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.distortion = ctx.createWaveShaper();
    this.destination = this.distortion;
  }
  initialize(s, e) {
    this.distortion.curve = makeDistortionCurve(e);
  }
  finisher() {
  }
  connect(node) {
    this.distortion.connect(node);
  }
  disconnect(node) {
    this.distortion.disconnect(node);
  }
};
function makeDistortionCurve(amount) {
  const k = typeof amount === "number" ? amount : 50;
  const n_samples = 44100;
  const curve = new Float32Array(n_samples);
  const deg = Math.PI / 180;
  for (let i2 = 0; i2 < n_samples; i2++) {
    const x = i2 * 2 / n_samples - 1;
    curve[i2] = (3 + k) * x * 10 * deg / (Math.PI + k * Math.abs(x));
  }
  return curve;
}
function DistortionEncoder(filter, sound, startTime) {
  if (sound.others.distortion !== void 0) {
    filter.distortion.curve = makeDistortionCurve(sound.others.distortion);
  }
}
function DistortionFinisher(filter, sound, startTime, duration) {
  filter.distortion.curve = makeDistortionCurve(50);
}

// node_modules/erie-web/src/audioFilters/audio-graph-filter-gainer.js
var GainerFilter = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.attackTime = 0.1;
    this.releaseTime = 0.1;
    this.gainer = ctx.createGain();
    this.destination = this.gainer;
  }
  initialize(time2) {
    this.gainer.gain.cancelScheduledValues(time2);
    this.gainer.gain.setValueAtTime(0, time2);
  }
  finisher(time2, duration) {
    this.gainer.gain.linearRampToValueAtTime(0, (time2 || 0) + (duration || 1) - this.releaseTime);
  }
  connect(node) {
    this.gainer.connect(node);
  }
  disconnect(node) {
    this.gainer.disconnect(node);
  }
};
function GainerEncoder(filter, sound, startTime) {
  var _a5;
  filter.gainer.gain.linearRampToValueAtTime(((_a5 = sound.others) == null ? void 0 : _a5.gain2) || 1, startTime + filter.attackTime);
}
function GainerFinisher(filter, sound, startTime, duration) {
  filter.gainer.gain.linearRampToValueAtTime(0, (startTime || 0) + (duration || 1) - filter.releaseTime);
}

// node_modules/erie-web/src/scale/audio-graph-scale-constant.js
var NOM2 = "nominal";
var ORD2 = "ordinal";
var QUANT2 = "quantitative";
var TMP2 = "temporal";
var STATIC2 = "static";
var POS3 = "positive";
var NEG2 = "negative";
var TIME_chn2 = "time";
var TIME2_chn2 = "time2";
var DUR_chn2 = "duration";
var TAPCNT_chn2 = "tapCount";
var TAPSPD_chn2 = "tapSpeed";
var POST_REVERB_chn2 = "postReverb";
var PITCH_chn2 = "pitch";
var DETUNE_chn2 = "detune";
var LOUDNESS_chn2 = "loudness";
var PAN_chn2 = "pan";
var SPEECH_chn = "speech";
var SPEECH_BEFORE_chn2 = "speechBefore";
var SPEECH_AFTER_chn2 = "speechAfter";
var TIMBRE_chn2 = "timbre";
var REPEAT_chn2 = "repeat";
var MODULATION_chn2 = "modulation";
var HARMONICITY_chn2 = "harmonicity";
var MIN_TIME = 0;
var MIN_PITCH = 207.65;
var MAX_PITCH = 1600;
var MAX_LIMIT_PITCH2 = 3e3;
var MAX_DETUNE = -1200;
var MIN_DETUNE = 1200;
var MIN_LOUD = 0;
var MAX_LOUD = 10;
var MIN_PAN = -1;
var MAX_PAN = 1;
var MIN_DUR = 0;
var MAX_DUR = 20;
var DEF_DUR = 0.5;
var MAX_POST_REVERB = 4;
var MAX_TAP_COUNT = 25;
var MIN_TAP_SPEED = 0;
var MAX_TAP_SPEED = 5;
var MAX_LIMIT_TAP_SPEED2 = 7;
var DEF_SPEECH_RATE = 1.75;
var ChannelThresholds = {
  [TIME_chn2]: { min: 0 },
  [PITCH_chn2]: { max: MAX_PITCH, min: MIN_PITCH },
  [DETUNE_chn2]: { max: MAX_DETUNE, min: MIN_DETUNE },
  [LOUDNESS_chn2]: { max: MAX_LOUD, min: MIN_LOUD },
  [PAN_chn2]: { max: MAX_PAN, min: MIN_PAN },
  [DUR_chn2]: { max: MAX_DUR, min: MIN_DUR },
  [POST_REVERB_chn2]: { max: MAX_POST_REVERB, min: 0 },
  [TAPCNT_chn2]: { max: MAX_TAP_COUNT, min: 0 },
  [TAPSPD_chn2]: { max: MAX_TAP_SPEED, min: MIN_TAP_SPEED }
};
var ChannelCaps = {
  [TIME_chn2]: { max: Infinity, min: MIN_TIME },
  [PITCH_chn2]: { max: MAX_LIMIT_PITCH2, min: 0 },
  [DETUNE_chn2]: { max: MAX_DETUNE, min: MIN_DETUNE },
  [LOUDNESS_chn2]: { max: Infinity, min: -Infinity },
  [PAN_chn2]: { max: MAX_PAN, min: MIN_PAN },
  [DUR_chn2]: { max: Infinity, min: MIN_DUR },
  [POST_REVERB_chn2]: { max: Infinity, min: 0 },
  [TAPCNT_chn2]: { max: Infinity, min: 0 },
  [TAPSPD_chn2]: { max: MAX_LIMIT_TAP_SPEED2, min: MIN_TAP_SPEED }
};
var TimeChannels = [
  TIME_chn2,
  TIME2_chn2
];
var SpeechChannels = [
  SPEECH_chn,
  SPEECH_BEFORE_chn2,
  SPEECH_AFTER_chn2
];
var TapChannels = [
  TAPCNT_chn2,
  TAPSPD_chn2
];
var DefaultChannels = [
  TIME_chn2,
  TIME2_chn2,
  PITCH_chn2,
  DETUNE_chn2,
  LOUDNESS_chn2,
  PAN_chn2,
  DUR_chn2,
  SPEECH_chn,
  SPEECH_BEFORE_chn2,
  SPEECH_AFTER_chn2,
  POST_REVERB_chn2,
  TAPCNT_chn2,
  TAPSPD_chn2,
  MODULATION_chn2,
  HARMONICITY_chn2
];
var SQRT = "sqrt";
var POW = "pow";
var LOG = "log";
var SYMLOG = "symlog";
var REL_TIMING = "relative";
var SIM_TIMING = "simultaneous";
var DEF_TAP_PAUSE_RATE = 0.4;
var MAX_TAPPING_DUR = 0.3;
var DEF_TAPPING_DUR = 0.2;
var DEF_TAPPING_DUR_BEAT = 1;
var DEF_TAP_DUR = 2;
var DEF_TAP_DUR_BEAT = 4;
var SINGLE_TAP_MIDDLE = "middle";
var SINGLE_TAP_START = "start";
var ScaleDescriptionOrder = [
  REPEAT_chn2,
  TIME_chn2,
  TIMBRE_chn2,
  DUR_chn2,
  TAPCNT_chn2,
  TAPSPD_chn2,
  PITCH_chn2,
  DETUNE_chn2,
  LOUDNESS_chn2,
  PAN_chn2,
  MODULATION_chn2,
  HARMONICITY_chn2,
  POST_REVERB_chn2
];
var SKIP = "skip";
var NONSKIP = "nonskip";
var SEQUENCE = "sequence";
var OVERLAY = "overlay";
var RampMethods2 = [true, false, "abrupt", "linear", "exponential"];

// node_modules/erie-web/src/player/audio-graph-audio-filter.js
var PresetFilters = {
  "gainer": { filter: GainerFilter, encoder: GainerEncoder, finisher: GainerFinisher },
  "lowpass": { filter: LowpassBiquadFilter, encoder: BiquadEncoder, finisher: BiquadFinisher },
  "highpass": { filter: HighpassBiquadFilter, encoder: BiquadEncoder, finisher: BiquadFinisher },
  "bandpass": { filter: BandpassBiquadFilter, encoder: BiquadEncoder, finisher: BiquadFinisher },
  "lowshelf": { filter: LowshelfBiquadFilter, encoder: BiquadEncoder, finisher: BiquadFinisher },
  "highshelf": { filter: HighshelfBiquadFilter, encoder: BiquadEncoder, finisher: BiquadFinisher },
  "peaking": { filter: PeakingBiquadFilter, encoder: BiquadEncoder, finisher: BiquadFinisher },
  "notch": { filter: NotchBiquadFilter, encoder: BiquadEncoder, finisher: BiquadFinisher },
  "allpass": { filter: AllpassBiquadFilter, encoder: BiquadEncoder, finisher: BiquadFinisher },
  "defaultCompressor": { filter: DefaultDynamicCompressor, encoder: CompressorEncoder, finisher: CompressorFinisher },
  "distortion": { filter: DistortionFilter, encoder: DistortionEncoder, finisher: DistortionFinisher }
};
var FilterExtraChannelTypes = {
  gain2: { type: LOUDNESS_chn2 },
  biquadDetune: { type: DETUNE_chn2 },
  biquadPitch: { type: PITCH_chn2 }
};

// node_modules/erie-web/src/player/audio-graph-player-event.js
function sendToneStartEvent(detail) {
  let playEvent = new CustomEvent("erieOnPlayTone", { detail });
  document.body.dispatchEvent(playEvent);
  let chnageEvent = new CustomEvent("erieOnStatusChange", { detail: { status: "tone-started" } });
  document.body.dispatchEvent(chnageEvent);
}
function sendToneFinishEvent(detail) {
  let playEvent = new CustomEvent("erieOnFinishTone", { detail });
  document.body.dispatchEvent(playEvent);
  let chnageEvent = new CustomEvent("erieOnStatusChange", { detail: { status: "tone-finished" } });
  document.body.dispatchEvent(chnageEvent);
}
function sendSpeechStartEvent(detail) {
  let playEvent = new CustomEvent("erieOnPlaySpeech", { detail });
  document.body.dispatchEvent(playEvent);
  let chnageEvent = new CustomEvent("erieOnStatusChange", { detail: { status: "speech-started" } });
  document.body.dispatchEvent(chnageEvent);
}
function sendSpeechFinishEvent(detail) {
  let playEvent = new CustomEvent("erieOnFinishSpeech", { detail });
  document.body.dispatchEvent(playEvent);
  let chnageEvent = new CustomEvent("erieOnStatusChange", { detail: { status: "speech-finished" } });
  document.body.dispatchEvent(chnageEvent);
}
function sendQueueStartEvent(detail) {
  let playEvent = new CustomEvent("erieOnPlayQueue", { detail });
  document.body.dispatchEvent(playEvent);
  let chnageEvent = new CustomEvent("erieOnStatusChange", { detail: { status: "started" } });
  document.body.dispatchEvent(chnageEvent);
}
function sendQueueFinishEvent(detail) {
  let playEvent = new CustomEvent("erieOnFinishQueue", { detail });
  document.body.dispatchEvent(playEvent);
  let chnageEvent = new CustomEvent("erieOnStatusChange", { detail: { status: "finished" } });
  document.body.dispatchEvent(chnageEvent);
}

// node_modules/erie-web/src/player/audio-graph-note-event.js
function emitNotePlayEvent(type, note2) {
  if (typeof document === "object") {
    document.body.dispatchEvent(new CustomEvent("erieOnNotePlay", {
      detail: {
        type,
        note: note2
      }
    }));
  }
}
function emitNoteStopEvent(type, note2) {
  if (typeof document === "object") {
    document.body.dispatchEvent(new CustomEvent("erieOnNoteStop", {
      detail: {
        type,
        note: note2
      }
    }));
  }
}

// node_modules/erie-web/src/player/audio-graph-player-proto.js
var ErieGlobalSynth;
function makeContext() {
  return new AudioContext();
}
function setCurrentTime(ctx) {
  return ctx.currentTime;
}
function makeInstrument(ctx, detail, instSamples, synthDefs, waveDefs, sound, contEndTime) {
  var _a5, _b2, _c2;
  if (!detail || detail === "default") {
    return ctx.createOscillator();
  } else if (NoiseTypes.includes(detail)) {
    let dur = contEndTime || sound.duration;
    if (sound.detune > 0)
      dur += dur * (sound.detune / 600);
    return makeNoiseNode(ctx, detail, dur * 1.1);
  } else if (MultiNoteInstruments.includes(detail)) {
    let note2 = determineNoteRange(sound.pitch || DefaultFrequency, {});
    let sample = instSamples[detail]["C" + note2.octave];
    let source2 = ctx.createBufferSource();
    source2.buffer = sample;
    source2.detune.value = note2.detune;
    return source2;
  } else if (SingleNoteInstruments.includes(detail)) {
    let sample = instSamples[detail].mono;
    let source2 = ctx.createBufferSource();
    source2.buffer = sample;
    return source2;
  } else if ((_a5 = Object.keys(waveDefs || {})) == null ? void 0 : _a5.includes(detail)) {
    let real_parsed = new Float32Array(waveDefs[detail].real);
    let imag_parsed = new Float32Array(waveDefs[detail].imag);
    const wave = ctx.createPeriodicWave(
      real_parsed,
      imag_parsed,
      { disableNormalization: waveDefs[detail].disableNormalization || false }
    );
    let osc = ctx.createOscillator();
    osc.setPeriodicWave(wave);
    return osc;
  } else if ((_b2 = Object.keys(instSamples || {})) == null ? void 0 : _b2.includes(detail)) {
    let sample;
    if (instSamples[detail].multiNote) {
      let note2 = determineNoteRange(sound.pitch, {});
      sample = instSamples[detail]["C" + (note2 == null ? void 0 : note2.octave)];
    } else {
      sample = instSamples[detail].mono;
    }
    let source2 = ctx.createBufferSource();
    source2.buffer = sample;
    if (instSamples[detail].multiNote) {
      source2.detune.value = note.detune;
    }
    return source2;
  } else if ((_c2 = Object.keys(synthDefs || {})) == null ? void 0 : _c2.includes(detail)) {
    let synth = makeSynth(ctx, synthDefs[detail]);
    return synth;
  }
}
var DefaultFrequency = 523.25;
var Stopped = "stopped";
var Tone2 = "tone";
var Speech = "speech";
var ErieGlobalControl;
var ErieGlobalState;
var RamperNames = {
  abrupt: "setValueAtTime",
  linear: "linearRampToValueAtTime",
  linear: "exponentialRampToValueAtTime"
};
async function playAbsoluteDiscreteTonesAlt(ctx, queue, config, instSamples, synthDefs, waveDefs, filters) {
  ErieGlobalState = void 0;
  ErieGlobalControl = { type: Tone2, player: ctx };
  const gain = ctx.createGain();
  gain.connect(ctx.destination);
  gain.gain.value = 0;
  let q = queue.sort((a, b) => a.time + a.duration - (b.time + b.duration));
  q[0].isFirst = true;
  q[q.length - 1].isLast = true;
  config.subpart = true;
  let endTime = q[q.length - 1].time + q[q.length - 1].duration;
  let sid = genRid();
  sendToneStartEvent({ sid });
  if (config == null ? void 0 : config.isRecorded)
    await playPause(300);
  return new Promise((resolve2, reject) => {
    let ct = (config == null ? void 0 : config.context_time) !== void 0 ? config.context_time : setCurrentTime(ctx);
    const tick = makeTick(ctx, config.tick, endTime);
    for (let sound of q) {
      if (ErieGlobalState === Stopped) {
        resolve2();
        break;
      }
      const inst = makeInstrument(ctx);
      inst.connect(gain);
      inst.start(ct + sound.time);
      inst.stop(ct + sound.time + 0.01);
      inst.onended = async () => {
        var _a5;
        if ((config == null ? void 0 : config.falseTiming) && (ErieGlobalControl == null ? void 0 : ErieGlobalControl.type) === Speech) {
          (_a5 = ErieGlobalControl == null ? void 0 : ErieGlobalControl.player) == null ? void 0 : _a5.cancel();
        }
        await playSingleTone(ctx, sound, config, instSamples, synthDefs, waveDefs, filters);
        if (sound.isLast) {
          if (config == null ? void 0 : config.isRecorded)
            await playPause(300);
          sendToneFinishEvent({ sid });
          resolve2();
        }
      };
    }
    if (tick) {
      tick.start(ct + 0.01);
      tick.stop(ct + endTime + 0.01);
    }
  });
}
async function playAbsoluteContinuousTones(ctx, queue, config, synthDefs, waveDefs, filters) {
  ErieGlobalState = void 0;
  ErieGlobalControl = { type: Tone2, player: ctx };
  let rampers = {};
  if (config.ramp) {
    Object.keys(config.ramp || {}).forEach((chn) => {
      let name2 = RamperNames[config.ramp[chn]];
      if (chn === TAPCNT_chn2 || chn === TAPSPD_chn2) {
        rampers.tap = name2;
      } else {
        rampers[chn] = name2;
      }
    });
  }
  let q = queue.sort((a, b) => a.time + a.duration - (b.time + b.duration));
  q[0].isFirst = true;
  q[q.length - 1].isLast = true;
  let endTime = q[q.length - 1].time + q[q.length - 1].duration;
  let filterEncoders = {}, filterFinishers = {}, filterNodes = {};
  for (const filterName of filters) {
    if (PresetFilters[filterName]) {
      filterNodes[filterName] = new PresetFilters[filterName].filter(ctx);
      filterEncoders[filterName] = PresetFilters[filterName].encoder;
      filterFinishers[filterName] = PresetFilters[filterName].finisher;
    } else if (ErieFilters[filterName]) {
      filterNodes[filterName] = new ErieFilters[filterName].filter(ctx);
      filterEncoders[filterName] = ErieFilters[filterName].encoder;
      filterFinishers[filterName] = ErieFilters[filterName].finisher;
    }
  }
  let destination = ctx.destination;
  for (const filterName of filters) {
    let filter = filterNodes[filterName];
    if (filter) {
      filter.connect(destination);
      filter.initialize(ctx.currentTime, endTime);
      destination = filter.destination;
    }
  }
  const gain = ctx.createGain();
  gain.connect(destination);
  const panner = ctx.createStereoPanner();
  panner.connect(gain);
  let sid = genRid();
  sendToneStartEvent({ sid });
  if (config == null ? void 0 : config.isRecorded)
    await playPause(300);
  return new Promise((resolve2, reject) => {
    const inst = makeInstrument(ctx, config == null ? void 0 : config.instrument_type, null, synthDefs, waveDefs, null, endTime);
    inst.connect(panner);
    let startTime;
    let ct = (config == null ? void 0 : config.context_time) !== void 0 ? config.context_time : setCurrentTime(ctx);
    for (let sound of q) {
      if (sound.isFirst) {
        if ((inst == null ? void 0 : inst.constructor.name) === OscillatorNode.name) {
          inst.frequency.setValueAtTime(sound.pitch || DefaultFrequency, ct + sound.time);
        } else if ((inst == null ? void 0 : inst.constructor.name) === ErieSynth.name) {
          inst.frequency.setValueAtTime(sound.pitch || DefaultFrequency, ct + sound.time);
          if (inst.type === FM2 && sound.modulation !== void 0) {
            inst.modulator.frequency.setValueAtTime(inst.modulatorVolume / sound.modulation, ct + sound.time);
          } else if (inst.type === AM2 && sound.modulation !== void 0) {
            inst.modulatorGain.gain.setValueAtTime((sound.loudness || 1) * sound.modulation, ct + sound.time);
          }
          if (sound.harmonicity !== void 0 && sound.harmonicity > 0) {
            inst.modulator.frequency.setValueAtTime((sound.pitch || inst.carrierPitch || DefaultFrequency) * sound.harmonicity, ct + sound.time);
          }
          inst.envelope.gain.cancelScheduledValues(ct + sound.time);
          inst.envelope.gain.setValueAtTime(0, ct + sound.time);
          inst.envelope.gain.linearRampToValueAtTime(1, ct + sound.time + (inst.attackTime || 0));
          if (inst.decayTime) {
            inst.envelope.gain.linearRampToValueAtTime(inst.sustain || 1, ct + sound.time + (inst.attackTime || 0) + (inst.decayTime || 0));
          }
        }
        if (sound.detune && inst.detune) {
          inst.detune.setValueAtTime(sound.detune || 0, ct + sound.time);
        }
        if (sound.loudness !== void 0) {
          gain.gain.setValueAtTime(sound.loudness, ct + sound.time);
        }
        if (sound.pan !== void 0) {
          panner.pan.setTargetAtTime(sound.pan, ct + sound.time, 0.35);
        }
        startTime = ct + sound.time;
      } else {
        if ((inst == null ? void 0 : inst.constructor.name) === OscillatorNode.name) {
          if (rampers.pitch) {
            inst.frequency[rampers.pitch](sound.pitch || DefaultFrequency, ct + sound.time);
          } else {
            inst.frequency.linearRampToValueAtTime(sound.pitch || DefaultFrequency, ct + sound.time);
          }
        } else if ((inst == null ? void 0 : inst.constructor.name) === ErieSynth.name) {
          if (rampers.pitch) {
            inst.frequency[rampers.pitch](sound.pitch || DefaultFrequency, ct + sound.time);
          } else {
            inst.frequency.linearRampToValueAtTime(sound.pitch || DefaultFrequency, ct + sound.time);
          }
          if (inst.type === FM2 && sound.modulation !== void 0) {
            if (rampers.modulation) {
              inst.modulator.frequency[rampers.modulation](inst.modulatorVolume / sound.modulation, ct + sound.time);
            } else {
              inst.modulator.frequency.linearRampToValueAtTime(inst.modulatorVolume / sound.modulation, ct + sound.time);
            }
          } else if (inst.type === AM2 && sound.modulation !== void 0) {
            if (rampers.modulation) {
              inst.modulatorGain.gain[rampers.modulation]((sound.loudness || 1) * sound.modulation, ct + sound.time);
            } else {
              inst.modulatorGain.gain.linearRampToValueAtTime((sound.loudness || 1) * sound.modulation, ct + sound.time);
            }
          }
          if (sound.harmonicity !== void 0 && sound.harmonicity > 0) {
            if (rampers.harmonicity) {
              inst.modulator.frequency[rampers.harmonicity]((sound.pitch || inst.carrierPitch || DefaultFrequency) * sound.harmonicity, ct + sound.time);
            } else {
              inst.modulator.frequency.linearRampToValueAtTime((sound.pitch || inst.carrierPitch || DefaultFrequency) * sound.harmonicity, ct + sound.time);
            }
          }
        }
        if (sound.loudness !== void 0) {
          if (rampers.loudness) {
            gain.gain[rampers.loudness](
              sound.loudness <= 0 ? 1e-10 : sound.loudness,
              ct + sound.time
            );
          } else {
            gain.gain.linearRampToValueAtTime(
              sound.loudness,
              ct + sound.time
            );
          }
        }
        if (sound.pan !== void 0) {
          panner.pan.linearRampToValueAtTime(sound.pan, ct + sound.time);
        }
        if (sound.isLast) {
          gain.gain.linearRampToValueAtTime(0, ct + sound.time + 0.15);
          if ((inst == null ? void 0 : inst.constructor.name) === ErieSynth.name) {
            inst.envelope.gain.cancelScheduledValues(ct + sound.time);
            inst.envelope.gain.setValueAtTime(1, ct + sound.time + sound.duration);
            inst.envelope.gain.linearRampToValueAtTime(
              0,
              ct + sound.time + (sound.duration || 0) + (inst.attackTime || 0) + (inst.releaseTime || 0)
            );
          }
        }
        if (sound.detune && inst.detune) {
          if (rampers.detune) {
            inst.detune[rampers.detune](sound.detune || 0, ct + sound.time);
          } else {
            inst.detune.linearRampToValueAtTime(sound.detune || 0, ct + sound.time);
          }
        }
      }
      for (const filterName of filters) {
        let encoder3 = filterEncoders[filterName];
        let finisher = filterFinishers[filterName];
        if (encoder3) {
          encoder3(filterNodes[filterName], sound, ct + sound.time, rampers);
        }
        if (finisher) {
          finisher(filterNodes[filterName], sound, ct + sound.time, sound.duration + sound.postReverb + (inst.attackTime || 0) + (inst.releaseTime || 0), rampers);
        }
      }
    }
    const tick = makeTick(ctx, config.tick, endTime);
    if (tick) {
      tick.start(startTime);
      tick.stop(ct + endTime);
    }
    emitNotePlayEvent("tone", q[0]);
    inst.start(startTime);
    if (config == null ? void 0 : config.isRecorded) {
      gain.gain.setValueAtTime(0, ct + endTime + 0.3);
      inst.stop(ct + endTime + 0.3);
    } else {
      inst.stop(ct + endTime);
    }
    inst.onended = (e) => {
      ErieGlobalControl = void 0;
      ErieGlobalState = void 0;
      emitNoteStopEvent("tone", q[0]);
      sendToneFinishEvent({ sid });
      resolve2();
    };
  });
}
async function playSingleTone(ctx, sound, config, instSamples, synthDefs, waveDefs, filters) {
  var _a5, _b2;
  if ((config == null ? void 0 : config.subpart) && ErieGlobalState === Stopped)
    return;
  if (!(config == null ? void 0 : config.subpart))
    ErieGlobalState = void 0;
  ErieGlobalState = void 0;
  ErieGlobalControl = { type: Tone2, player: ctx };
  let sid;
  if (!config.subpart) {
    sid = genRid();
    sendToneStartEvent({ sid });
    if (config == null ? void 0 : config.isRecorded)
      await playPause(300);
  }
  if (sound.tap !== void 0 && ((_b2 = (_a5 = sound.tap) == null ? void 0 : _a5.pattern) == null ? void 0 : _b2.constructor.name) === "Array") {
    let ct = (config == null ? void 0 : config.context_time) !== void 0 ? config.context_time : setCurrentTime(ctx);
    let tapSound = deepcopy2(sound);
    let t2 = 1, acc = 0, i2 = 0;
    if (sound.tap.pattern.length == 0) {
      await playPause((sound.duration || 0.2) * 1e3);
      if (config == null ? void 0 : config.isRecorded)
        await playPause(300);
      sendToneFinishEvent({ sid });
    }
    emitNotePlayEvent("tone", sound);
    for (const s of sound.tap.pattern) {
      if (t2 === 1) {
        tapSound.duration = s;
        if (s > 0) {
          await __playSingleTone(ctx, ct + acc, tapSound, config, instSamples, synthDefs, waveDefs, filters);
        }
        t2 = 0;
      } else {
        await playPause(s * 1e3);
        t2 = 1;
      }
      acc += s;
      i2++;
      if (i2 == sound.tap.pattern.length) {
        if (!config.subpart) {
          if (config == null ? void 0 : config.isRecorded)
            await playPause(300);
          sendToneFinishEvent({ sid });
        }
        return;
      }
    }
    emitNoteStopEvent("tone", sound);
  } else {
    let ct = (config == null ? void 0 : config.context_time) !== void 0 ? config.context_time : setCurrentTime(ctx);
    emitNotePlayEvent("tone", sound);
    await __playSingleTone(ctx, ct, sound, config, instSamples, synthDefs, waveDefs, filters);
    emitNoteStopEvent("tone", sound);
    if (!config.subpart) {
      sendToneFinishEvent({ sid });
    }
    return;
  }
}
async function __playSingleTone(ctx, ct, sound, config, instSamples, synthDefs, waveDefs, filters) {
  let filterEncoders = {}, filterFinishers = {}, filterNodes = {};
  for (const filterName of filters) {
    if (PresetFilters[filterName]) {
      filterNodes[filterName] = new PresetFilters[filterName].filter(ctx);
      filterEncoders[filterName] = PresetFilters[filterName].encoder;
      filterFinishers[filterName] = PresetFilters[filterName].finisher;
    } else if (ErieFilters[filterName]) {
      filterNodes[filterName] = new ErieFilters[filterName].filter(ctx);
      filterEncoders[filterName] = ErieFilters[filterName].encoder;
      filterFinishers[filterName] = ErieFilters[filterName].finisher;
    }
  }
  let destination = ctx.destination;
  for (const filterName of filters) {
    let filter = filterNodes[filterName];
    if (filter) {
      filter.connect(destination);
      filter.initialize(ct, sound.duration);
      destination = filter.destination;
    }
  }
  const gain = ctx.createGain();
  gain.connect(destination);
  const panner = ctx.createStereoPanner();
  panner.connect(gain);
  return new Promise((resolve2, reject) => {
    let iType = sound.timbre || (config == null ? void 0 : config.instrument_type);
    const inst = makeInstrument(ctx, iType, instSamples, synthDefs, waveDefs, sound);
    inst.connect(panner);
    if ((inst == null ? void 0 : inst.constructor.name) === OscillatorNode.name) {
      inst.frequency.setValueAtTime(sound.pitch || inst.carrierPitch || DefaultFrequency, ct);
    } else if ((inst == null ? void 0 : inst.constructor.name) === ErieSynth.name) {
      inst.frequency.setValueAtTime(sound.pitch || inst.carrierPitch || DefaultFrequency, ct);
      if (inst.type === FM2 && sound.modulation !== void 0 && sound.modulation > 0) {
        inst.modulator.frequency.setValueAtTime(inst.modulatorVolume / sound.modulation, ct);
      } else if (inst.type === AM2 && sound.modulation !== void 0 && sound.modulation > 0) {
        inst.modulatorGain.gain.setValueAtTime((sound.loudness || 1) * sound.modulation, ct);
      }
      if (sound.harmonicity !== void 0 && sound.harmonicity > 0) {
        inst.modulator.frequency.cancelScheduledValues(ct);
        inst.modulator.frequency.setValueAtTime((sound.pitch || inst.carrierPitch || DefaultFrequency) * sound.harmonicity, ct);
      }
      inst.envelope.gain.cancelScheduledValues(ct);
      inst.envelope.gain.setValueAtTime(0, ct);
      inst.envelope.gain.linearRampToValueAtTime(1, ct + (inst.attackTime || 0));
      if (inst.decayTime) {
        inst.envelope.gain.linearRampToValueAtTime(inst.sustain || 1, ct + sound.time + (inst.attackTime || 0) + (inst.decayTime || 0));
      }
      inst.envelope.gain.setValueAtTime(inst.sustain || 1, ct + sound.duration);
      inst.envelope.gain.linearRampToValueAtTime(
        0,
        ct + sound.duration + (inst.attackTime || 0) + (inst.releaseTime || 0)
      );
    }
    if (sound.detune && inst.detune) {
      inst.detune.setValueAtTime(sound.detune || 0, ct);
    }
    if (sound.loudness !== void 0) {
      gain.gain.setValueAtTime(sound.loudness, ct);
    }
    if (sound.postReverb) {
      gain.gain.setTargetAtTime(0, ct + sound.duration * 0.95, 0.015);
      gain.gain.setTargetAtTime(0.45, ct + sound.duration, 0.015);
      gain.gain.exponentialRampToValueAtTime(0.02, ct + (sound.duration + sound.postReverb) * 0.95);
    } else {
      sound.postReverb = 0;
    }
    for (const filterName of filters) {
      let encoder3 = filterEncoders[filterName];
      let finisher = filterFinishers[filterName];
      if (encoder3) {
        encoder3(filterNodes[filterName], sound, ct);
      }
      if (finisher) {
        finisher(filterNodes[filterName], sound, ct + sound.time, ct + (sound.duration + sound.postReverb + (inst.attackTime || 0) + (inst.releaseTime || 0)));
      }
    }
    gain.gain.setTargetAtTime(0, ct + (sound.duration + sound.postReverb + (inst.attackTime || 0) + (inst.releaseTime || 0)) * 0.95, 0.015);
    if (sound.pan !== void 0) {
      panner.pan.setValueAtTime(sound.pan, ct);
    }
    inst.onended = (e) => {
      resolve2();
    };
    inst.start(ct);
    inst.stop(ct + sound.duration + sound.postReverb);
  });
}
async function playSingleSpeech(sound, config) {
  if ((config == null ? void 0 : config.subpart) && ErieGlobalState === Stopped)
    return;
  if (!(config == null ? void 0 : config.subpart))
    ErieGlobalState = void 0;
  let sid = genRid();
  if (!config.subpart) {
    sendSpeechStartEvent({ sound, sid });
  }
  return new Promise((resolve2, reject) => {
    var _a5;
    if (!ErieGlobalSynth)
      ErieGlobalSynth = window.speechSynthesis;
    var utterance = new SpeechSynthesisUtterance(sound.speech);
    if ((config == null ? void 0 : config.speechRate) !== void 0)
      utterance.rate = config == null ? void 0 : config.speechRate;
    else if ((sound == null ? void 0 : sound.speechRate) !== void 0)
      utterance.rate = sound == null ? void 0 : sound.speechRate;
    if ((sound == null ? void 0 : sound.pitch) !== void 0)
      utterance.pitch = sound.pitch;
    if ((sound == null ? void 0 : sound.loudness) !== void 0)
      utterance.volume = sound.loudness;
    if (sound == null ? void 0 : sound.language)
      utterance.lang = bcp47language.includes(sound.language) ? sound.language : (_a5 = document == null ? void 0 : document.documentElement) == null ? void 0 : _a5.lang;
    else
      utterance.lang = document.documentElement.lang;
    emitNotePlayEvent("speech", sound);
    ErieGlobalSynth.speak(utterance);
    ErieGlobalControl = { type: Speech, player: ErieGlobalSynth };
    utterance.onend = () => {
      window.removeEventListener("keypress", stop);
      ErieGlobalControl = void 0;
      ErieGlobalState = void 0;
      emitNoteStopEvent("speech", sound);
      if (!config.subpart) {
        sendSpeechFinishEvent({ sid });
      }
      resolve2();
    };
  });
}
async function playRelativeDiscreteTonesAndSpeeches(ctx, queue, _config, instSamples, synthDefs, waveDefs, filters) {
  ErieGlobalState = void 0;
  let config = deepcopy2(_config);
  config.subpart = true;
  for (const sound of queue) {
    if (ErieGlobalState === Stopped)
      break;
    let sid = genRid();
    if (sound.speech) {
      sendSpeechStartEvent({ sound, sid });
      await playSingleSpeech(sound, config);
      sendSpeechFinishEvent({ sid });
    } else {
      sendToneStartEvent({ sid });
      if (config == null ? void 0 : config.isRecorded)
        await playPause(300);
      await playSingleTone(ctx, sound, config, instSamples, synthDefs, waveDefs, filters);
      if (config == null ? void 0 : config.isRecorded)
        await playPause(300);
      sendToneFinishEvent({ sid });
    }
  }
  ErieGlobalState = void 0;
  return;
}
var ErieGlobalPlayerEvents = /* @__PURE__ */ new Map();
function setPlayerEvents(queue, config) {
  if (typeof window !== "undefined") {
    let stop2 = function(event) {
      if (event.key == "x") {
        ErieGlobalState = Stopped;
        queue.state = Stopped;
        if ((ErieGlobalControl == null ? void 0 : ErieGlobalControl.type) === Tone2) {
          ErieGlobalControl.player.close();
        } else if ((ErieGlobalControl == null ? void 0 : ErieGlobalControl.type) === Speech) {
          ErieGlobalControl.player.cancel();
        }
        notifyStop(config);
      }
    };
    window.addEventListener("keypress", stop2);
    ErieGlobalPlayerEvents.set("stop-event", stop2);
  }
}
function clearPlayerEvents() {
  if (typeof window !== "undefined") {
    let stop2 = ErieGlobalPlayerEvents.get("stop-event");
    window.removeEventListener("keypress", stop2);
    ErieGlobalPlayerEvents.delete("stop-event");
  }
}
function playPause(ms, config) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, ms);
  });
}
var bcp47language = [
  "ar-SA",
  "bn-BD",
  "bn-IN",
  "cs-CZ",
  "da-DK",
  "de-AT",
  "de-CH",
  "de-DE",
  "el-GR",
  "en-AU",
  "en-CA",
  "en-GB",
  "en-IE",
  "en-IN",
  "en-NZ",
  "en-US",
  "en-ZA",
  "es-AR",
  "es-CL",
  "es-CO",
  "es-ES",
  "es-MX",
  "es-US",
  "fi-FI",
  "fr-BE",
  "fr-CA",
  "fr-CH",
  "fr-FR",
  "he-IL",
  "hi-IN",
  "hu-HU",
  "id-ID",
  "it-CH",
  "it-IT",
  "ja-JP",
  "ko-KR",
  "nl-BE",
  "nl-NL",
  "no-NO",
  "pl-PL",
  "pt-BR",
  "pt-PT",
  "ro-RO",
  "ru-RU",
  "sk-SK",
  "sv-SE",
  "ta-IN",
  "ta-LK",
  "th-TH",
  "tr-TR",
  "zh-CN",
  "zh-HK",
  "zh-TW"
];

// node_modules/erie-web/src/util/audio-graph-typing-util.js
function isJSON(d) {
  try {
    JSON.parse(d);
    return true;
  } catch {
    return false;
  }
}
var TSV_format = /^\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^\t'"\s\\]*(?:\s+[^\t'"\s\\]+)*)\s*(?:\t\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^\t\'"\s\\]*(?:\s+[^\t'"\s\\]+)*)\s*)*$/gi;
function isTSV(d) {
  return d.match(TSV_format);
}
var CSV_format = /^\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^,'"\s\\]*(?:\s+[^,'"\s\\]+)*)\s*(?:,\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^,'"\s\\]*(?:\s+[^,'"\s\\]+)*)\s*)*$/gi;
function isCSV(d) {
  return d.match(CSV_format);
}
function jType(v) {
  return v == null ? void 0 : v.constructor.name;
}
function detectType(values2) {
  if (values2.every((d) => (d == null ? void 0 : d.constructor.name) === "Number"))
    return QUANT2;
  else
    return ORD2;
}

// node_modules/erie-web/src/util/audio-graph-scale-util.js
function makeParamFilter(expr) {
  if (jType(expr) !== "String")
    return null;
  let base = expr.includes("datum.") ? "datum" : "d";
  if (base === "datum") {
    return Function("datum", "return (" + expr + ");");
  } else {
    return Function("d", "return (" + expr + ");");
  }
}
var tapEndBumper = 0.1;
function makeTapPattern(tapValue, tapType, duration, pause, tappingDur, singleTappingPosition, beat) {
  if (tapValue !== void 0 && tapType === TAPCNT_chn2) {
    if (!duration && !beat)
      duration = DEF_TAPPING_DUR;
    else if (!duration && beat && beat.converter) {
      duration = DEF_TAPPING_DUR_BEAT;
    }
    let pauseLength;
    duration = round(duration, -2);
    if ((pause == null ? void 0 : pause.length) !== void 0)
      pauseLength = pause == null ? void 0 : pause.length;
    else if ((pause == null ? void 0 : pause.rate) !== void 0)
      pauseLength = duration * (pause == null ? void 0 : pause.rate);
    else
      pauseLength = duration * DEF_TAP_PAUSE_RATE;
    pauseLength = round(pauseLength, -2);
    let pattern = [], totalLength = 0, patternString = `[${duration}, ${pauseLength}] x ${tapValue} `;
    for (let i2 = 0; i2 < tapValue; i2++) {
      pattern.push(duration);
      totalLength += duration;
      if (i2 < tapValue - 1) {
        totalLength += pauseLength;
        pattern.push(pauseLength);
      } else {
        totalLength += tapEndBumper;
        pattern.push(tapEndBumper);
      }
    }
    if (beat == null ? void 0 : beat.converter)
      pattern = pattern.map(beat == null ? void 0 : beat.converter);
    return { pattern, totalLength, patternString };
  } else if (tapValue !== void 0 && tapType === TAPSPD_chn2) {
    if (!duration && !beat)
      duration = DEF_TAP_DUR;
    else if (!duration && beat && beat.converter) {
      duration = DEF_TAP_DUR_BEAT;
    }
    let count2 = round(tapValue * duration, 0);
    let tapOnlyDur = count2 * tappingDur;
    let pauseLength;
    let pattern = [], totalLength = 0;
    if (count2 == 0) {
      pauseLength = duration;
      pattern = [0, pauseLength];
      totalLength += pauseLength;
    } else if (count2 == 1) {
      if (!singleTappingPosition || singleTappingPosition === SINGLE_TAP_MIDDLE) {
        pauseLength = (duration - tappingDur) / 2;
        pauseLength = round(pauseLength, -2);
        pattern = [0, pauseLength, tappingDur, pauseLength];
        totalLength += pauseLength + tappingDur + pauseLength;
      } else {
        pauseLength = duration - tappingDur;
        pauseLength = round(pauseLength, -2);
        if (singleTappingPosition === SINGLE_TAP_START) {
          pattern = [tappingDur, pauseLength];
          totalLength += pauseLength + tappingDur;
        } else if (singleTappingPosition === SINGLE_TAP_START) {
          pattern = [0, pauseLength, tappingDur, tapEndBumper];
          totalLength += pauseLength + tappingDur + tapEndBumper;
        }
      }
    } else {
      pauseLength = (duration - tapOnlyDur) / (count2 - 1);
      pauseLength = round(pauseLength, -2);
      for (let i2 = 0; i2 < count2; i2++) {
        pattern.push(tappingDur);
        totalLength += tappingDur;
        if (i2 < count2 - 1) {
          totalLength += pauseLength;
          pattern.push(pauseLength);
        } else {
          totalLength += tapEndBumper;
          pattern.push(tapEndBumper);
        }
      }
    }
    let patternString = `[${tappingDur}, ${pauseLength}] x ${count2}`;
    if (beat == null ? void 0 : beat.converter)
      pattern = pattern.map(beat == null ? void 0 : beat.converter);
    return { pattern, totalLength, patternString };
  } else if (tapValue !== void 0 && tapType === "both") {
    let count2 = round(tapValue.count, 0), speed = tapValue.speed;
    if (!duration && !beat)
      duration = DEF_TAPPING_DUR;
    else if (!duration && beat && beat.converter) {
      duration = DEF_TAPPING_DUR_BEAT;
    }
    let tapSection = round(1 / speed, -2);
    if (!beat) {
      if (tapSection < 0.12)
        tapSection = 0.12;
      if (duration > tapSection)
        duration = round(tapSection * 0.85, -2);
    }
    let pauseLength = round(tapSection - duration, -2);
    let pattern = [], totalLength = 0, patternString = `[${duration}, ${pauseLength}] x ${count2} `;
    for (let i2 = 0; i2 < count2; i2++) {
      pattern.push(duration);
      totalLength += duration;
      if (i2 < count2 - 1) {
        totalLength += pauseLength;
        pattern.push(pauseLength);
      } else {
        totalLength += tapEndBumper;
        pattern.push(tapEndBumper);
      }
    }
    if (beat == null ? void 0 : beat.converter)
      pattern = pattern.map(beat == null ? void 0 : beat.converter);
    return { pattern, totalLength, patternString };
  } else {
    return { pattern: [], totalLength: 0, patternString: `[0, 0] x 0` };
  }
}
function mergeTapPattern(tapCount, tapSpeed) {
  if (tapCount && tapSpeed) {
    return makeTapPattern({ count: tapCount == null ? void 0 : tapCount.value, speed: tapSpeed == null ? void 0 : tapSpeed.value }, "both", tapCount.tapLength, void 0, tapSpeed.tappingUnit, tapSpeed.singleTappingPosition, tapCount.beat);
  } else if (tapCount) {
    return makeTapPattern(tapCount == null ? void 0 : tapCount.value, TAPCNT_chn2, tapCount.tapLength, tapCount.pause, void 0, void 0, tapCount.beat);
  } else if (tapSpeed) {
    return makeTapPattern(tapSpeed == null ? void 0 : tapSpeed.value, TAPSPD_chn2, tapSpeed.tapDuration, void 0, tapSpeed.tappingUnit, tapSpeed.singleTappingPosition, tapSpeed.beat);
  } else {
    return void 0;
  }
  ;
}
var noteScale = [
  {
    c: 16.35,
    cs: 17.32,
    d: 18.35,
    ds: 19.45,
    e: 20.6,
    f: 21.83,
    fs: 23.12,
    g: 24.5,
    gs: 25.96,
    a: 27.5,
    as: 29.14,
    b: 30.87
  },
  {
    c: 32.7,
    cs: 34.65,
    d: 36.71,
    ds: 38.89,
    e: 41.2,
    f: 43.65,
    fs: 46.25,
    g: 49,
    gs: 51.91,
    a: 55,
    as: 58.27,
    b: 61.74
  },
  {
    c: 65.41,
    cs: 69.3,
    d: 73.42,
    ds: 77.78,
    e: 82.41,
    f: 87.31,
    fs: 92.5,
    g: 98,
    gs: 103.83,
    a: 110,
    as: 116.54,
    b: 123.47
  },
  {
    c: 130.81,
    cs: 138.59,
    d: 146.83,
    ds: 155.56,
    e: 164.81,
    f: 174.61,
    fs: 185,
    g: 196,
    gs: 207.65,
    a: 220,
    as: 233.08,
    b: 246.94
  },
  {
    c: 261.63,
    cs: 277.18,
    d: 293.66,
    ds: 311.13,
    e: 329.63,
    f: 349.23,
    fs: 369.99,
    g: 392,
    gs: 415.3,
    a: 440,
    as: 466.16,
    b: 493.88
  },
  {
    c: 523.25,
    cs: 554.37,
    d: 587.33,
    ds: 622.25,
    e: 659.25,
    f: 698.46,
    fs: 739.99,
    g: 783.99,
    gs: 830.61,
    a: 880,
    as: 932.33,
    b: 987.77
  },
  {
    c: 1046.5,
    cs: 1108.73,
    d: 1174.66,
    ds: 1244.51,
    e: 1318.51,
    f: 1396.91,
    fs: 1479.98,
    g: 1567.98,
    gs: 1661.22,
    a: 1760,
    as: 1864.66,
    b: 1975.53
  },
  {
    c: 2093,
    cs: 2217.46,
    d: 2349.32,
    ds: 2489.02,
    e: 2637.02,
    f: 2793.83,
    fs: 2959.96,
    g: 3135.96,
    gs: 3322.44,
    a: 3520,
    as: 3729.31,
    b: 3951.07
  },
  {
    c: 4186.01,
    cs: 4434.92,
    d: 4698.63,
    ds: 4978.03,
    e: 5274.04,
    f: 5587.65,
    fs: 5919.91,
    g: 6271.93,
    gs: 6644.88,
    a: 7040,
    as: 7458.62,
    b: 7902.13
  }
];
var sharpToFlat = {
  bb: "as",
  ab: "gs",
  gb: "fs",
  fb: "e",
  eb: "ds",
  db: "cs",
  cb: "b"
};
function noteToFreq2(note2) {
  var _a5, _b2;
  if (jType(note2) === "Number")
    return note2;
  if (jType(note2) !== "String")
    return null;
  let n2 = (_a5 = note2[0]) == null ? void 0 : _a5.toLowerCase(), o = note2[1], a = (_b2 = note2[2]) == null ? void 0 : _b2.toLowerCase();
  if (a === "#")
    a = "s";
  else if (a === "")
    a = "b";
  if (o > 8)
    return null;
  if (a === "b") {
    let na = sharpToFlat[n2 + a];
    n2 = na[0];
    a = na[1];
    if (na == "b")
      o = o - 1;
  }
  if (n2 + a === "bs") {
    n2 = "c";
    a = void 0;
  } else if (n2 + a === "es") {
    n2 = "f";
    a = void 0;
  }
  if (o < 0)
    return null;
  return noteScale[o][n2 + (a || "")];
}

// node_modules/erie-web/src/player/audio-graph-player.js
var TextType = "text";
var ToneType = "tone";
var ToneSeries = "tone-series";
var LegendType = "legend";
var ToneSpeechSeries = "tone-speech-series";
var Pause = "pause";
var ToneOverlaySeries = "tone-overlay-series";
var Stopped2 = "stopped";
var Paused = "paused";
var Playing = "playing";
var Finished = "finished";
var Types = [TextType, ToneType, ToneSeries, ToneOverlaySeries, Pause, ToneSpeechSeries, LegendType];
var AudioGraphQueue = class {
  constructor() {
    this.queue = [];
    this.state = Finished;
    this.playAt;
    this.config = {};
    this.stopEvents = {};
    this.sampledInstruments = [];
    this.sampledInstrumentSources = {};
    this.chunks;
    this.export = [];
    this.samplings = {};
    this.synths = {};
    this.waves = {};
    this.playId;
  }
  setConfig(key2, value) {
    this.config[key2] = value;
  }
  setSampling(samplings) {
    this.samplings = deepcopy2(samplings);
  }
  setSynths(synths) {
    this.synths = deepcopy2(synths);
  }
  setWaves(waves) {
    this.waves = deepcopy2(waves);
  }
  isSupportedInst(k) {
    return SupportedInstruments.includes(k);
  }
  isSampling(k) {
    var _a5;
    return ((_a5 = this.samplings) == null ? void 0 : _a5[k]) !== void 0;
  }
  isSynth(k) {
    var _a5;
    return ((_a5 = this.synths) == null ? void 0 : _a5[k]) !== void 0;
  }
  isWave(k) {
    var _a5;
    return ((_a5 = this.waves) == null ? void 0 : _a5[k]) !== void 0;
  }
  add(type, info, lineConfig, at2) {
    var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j2, _k2, _l2, _m2, _n;
    let checkInstrumentSampling = /* @__PURE__ */ new Set(), userSampledInstruments = /* @__PURE__ */ new Set();
    if (Types.includes(type)) {
      let item = {
        type,
        config: lineConfig
      };
      if (type === TextType) {
        item.text = (info == null ? void 0 : info.text) || info || "";
        if (info == null ? void 0 : info.speechRate)
          item.speechRate = info == null ? void 0 : info.speechRate;
      } else if (type === ToneType) {
        item.instrument_type = info.instrument_type;
        if (this.isSupportedInst(item.instrument_type))
          checkInstrumentSampling.add(item.instrument_type);
        else if (this.isSampling(item.instrument_type))
          userSampledInstruments.add(item.instrument_type);
        item.time = ((_a5 = info.sound) == null ? void 0 : _a5.start) || info.start || 0;
        item.end = ((_b2 = info.sound) == null ? void 0 : _b2.end) || item.time + (((_c2 = item.sound) == null ? void 0 : _c2.duration) || 0.2);
        item.duration = ((_d2 = info.sound) == null ? void 0 : _d2.duration) || item.end - item.time || 0.2;
        item.pitch = ((_e2 = info.sound) == null ? void 0 : _e2.pitch) || info.pitch || DefaultFrequency;
        item.detune = ((_f2 = info.sound) == null ? void 0 : _f2.detune) || info.detune;
        item.loudness = getFirstDefined((_g2 = info.sound) == null ? void 0 : _g2.loudness, info.loudness, 1);
        item.pan = ((_h2 = info.sound) == null ? void 0 : _h2.pan) || info.pan;
        item.postReverb = ((_i = info.sound) == null ? void 0 : _i.postReverb) || info.postReverb || 0;
        item.timbre = ((_j2 = info.sound) == null ? void 0 : _j2.timbre) || info.timbre || info.instrument_type;
        let tapCount = ((_k2 = info.sound) == null ? void 0 : _k2.tapCount) || info.tapCount, tapSpeed = ((_l2 = info.sound) == null ? void 0 : _l2.tapSpeed) || info.tapSpeed;
        if (tapCount || tapSpeed) {
          item.tap = mergeTapPattern(tapCount, tapSpeed);
          item.duration = item.tap.totalLength;
        }
        item.modulation = ((_m2 = info.sound) == null ? void 0 : _m2.modulation) || info.modulation || 0;
        item.harmonicity = ((_n = info.sound) == null ? void 0 : _n.harmonicity) || info.harmonicity || 0;
        item.others = {};
        Object.keys(info.sound || info || {}).forEach((chn) => {
          var _a6;
          if (!DefaultChannels.includes(chn)) {
            item.others[chn] = ((_a6 = info.sound) == null ? void 0 : _a6[chn]) || info[chn];
          }
        });
        item.filters = info.filters || [];
        if (this.isSupportedInst(item.timbre))
          checkInstrumentSampling.add(item.timbre);
        else if (this.isSampling(item.timbre))
          userSampledInstruments.add(item.timbre);
      } else if (type === ToneSeries) {
        item.instrument_type = info.instrument_type;
        if (this.isSupportedInst(item.instrument_type))
          checkInstrumentSampling.add(item.instrument_type);
        else if (this.isSampling(item.instrument_type))
          userSampledInstruments.add(item.instrument_type);
        item.sounds = makeSingleStreamQueueValues(info.sounds);
        if (item.sounds.hasSpeech)
          item.type = ToneSpeechSeries;
        item.sounds[item.sounds.length - 1].isLast = true;
        item.continued = info.continued;
        item.relative = info.relative;
        item.filters = info.filters || [];
        if (this.isSupportedInst(item.instrument_type))
          checkInstrumentSampling.add(item.instrument_type);
        else if (this.isSampling(item.instrument_type))
          userSampledInstruments.add(item.instrument_type);
        item.sounds.forEach((sound) => {
          if (this.isSupportedInst(sound.timbre))
            checkInstrumentSampling.add(sound.timbre);
          else if (this.isSampling(sound.timbre))
            userSampledInstruments.add(sound.timbre);
        });
      } else if (type === ToneOverlaySeries) {
        if (info.overlays.length > 0) {
          item.overlays = info.overlays.map((d) => {
            let o = {
              instrument_type: d.instrument_type,
              sounds: makeSingleStreamQueueValues(d.sounds),
              continued: d.continued,
              relative: d.relative,
              filters: d.filters || []
            };
            o.sounds[o.sounds.length - 1].isLast = true;
            if (this.isSupportedInst(o.instrument_type))
              checkInstrumentSampling.add(o.instrument_type);
            else if (this.isSampling(o.instrument_type))
              userSampledInstruments.add(o.instrument_type);
            o.sounds.forEach((sound) => {
              if (this.isSupportedInst(sound.timbre))
                checkInstrumentSampling.add(sound.timbre);
              else if (this.isSampling(sound.timbre))
                userSampledInstruments.add(sound.timbre);
            });
            return o;
          });
        } else {
          item.overlays = info.overlays;
        }
      } else if (type === Pause) {
        item.duration = info.duration;
      } else if (type === LegendType) {
        Object.assign(item, info);
      }
      if (info.ramp) {
        item.ramp = deepcopy2(info.ramp);
      }
      Array.from(checkInstrumentSampling).forEach((inst) => {
        if (!this.sampledInstruments.includes(inst)) {
          this.sampledInstruments.push(inst);
        }
      });
      Array.from(userSampledInstruments).forEach((inst) => {
        if (!this.sampledInstruments.includes(inst)) {
          this.sampledInstruments.push(inst);
        }
      });
      if (at2 !== void 0) {
        this.queue.splice(at2, 0, item);
      } else {
        this.queue.push(item);
      }
    }
  }
  addMulti(multiples, lineConfig, pos) {
    let at2 = pos;
    for (const mul of multiples) {
      if (mul == null ? void 0 : mul.type) {
        this.add(mul.type, mul, lineConfig, at2);
        if (at2 !== void 0) {
          at2 += 1;
        }
      }
    }
  }
  addQueue(queue, pos) {
    if (pos !== void 0) {
      this.queue.splice(pos, 0, ...queue.queue);
    } else {
      this.queue.push(...queue.queue);
    }
  }
  async play(i2, j) {
    if (this.state !== Playing) {
      setPlayerEvents(this, this.config);
      let queue = this.queue;
      this.playAt = i2 || 0;
      if (i2 !== void 0 && j !== void 0) {
        queue = this.queue.slice(i2, j);
      } else if (i2 !== void 0) {
        queue = this.queue.slice(i2, this.queue.length);
      } else if (j !== void 0) {
        queue = this.queue.slice(0, j);
      }
      this.state = Playing;
      this.fireStartEvent();
      for (const item of queue) {
        console.log(item, this.state);
        if (this.state === Stopped2 || this.state === Paused)
          break;
        await this.playLine(item);
        this.playAt += 1;
      }
      this.fireStopEvent();
      clearPlayerEvents();
      this.state = Stopped2;
      this.playAt = void 0;
    }
  }
  async playLine(item) {
    var _a5, _b2, _c2, _d2;
    let config = deepcopy2(this.config);
    Object.assign(config, item.config);
    config.ramp = item.ramp;
    if ((item == null ? void 0 : item.type) === TextType) {
      await playSingleSpeech(item.text, config);
    } else if ((item == null ? void 0 : item.type) === ToneType) {
      let ctx = makeContext();
      for (const inst of this.sampledInstruments) {
        if (inst && !this.sampledInstrumentSources[inst]) {
          this.sampledInstrumentSources[inst] = await loadSamples(ctx, inst, this.samplings, (_a5 = this.config.options) == null ? void 0 : _a5.baseUrl);
        }
      }
      await playSingleTone(ctx, item, config, this.sampledInstrumentSources, this.synths, this.waves, item.filters);
      ctx.close();
    } else if ((item == null ? void 0 : item.type) === Pause) {
      await playPause(item.duration * 1e3, config);
    } else if ((item == null ? void 0 : item.type) === ToneSeries) {
      let ctx = makeContext();
      for (const inst of this.sampledInstruments) {
        if (inst && !this.sampledInstrumentSources[inst]) {
          this.sampledInstrumentSources[inst] = await loadSamples(ctx, inst, this.samplings, (_b2 = this.config.options) == null ? void 0 : _b2.baseUrl);
        }
      }
      if (item.continued) {
        await playAbsoluteContinuousTones(ctx, item.sounds, config, this.synths, this.waves, item.filters);
      } else if (!item.relative) {
        await playAbsoluteDiscreteTonesAlt(ctx, item.sounds, config, this.sampledInstrumentSources, this.synths, this.waves, item.filters);
      } else {
        await playRelativeDiscreteTonesAndSpeeches(ctx, item.sounds, config, this.sampledInstrumentSources, this.synths, this.waves, item.filters);
      }
      ctx.close();
    } else if ((item == null ? void 0 : item.type) === ToneSpeechSeries) {
      let ctx = makeContext();
      for (const inst of this.sampledInstruments) {
        if (inst && !this.sampledInstrumentSources[inst]) {
          this.sampledInstrumentSources[inst] = await loadSamples(ctx, inst, this.samplings, (_c2 = this.config.options) == null ? void 0 : _c2.baseUrl);
        }
      }
      await playRelativeDiscreteTonesAndSpeeches(ctx, item.sounds, config, this.sampledInstrumentSources, this.synths, this.waves, item.filters);
      ctx.close();
    } else if ((item == null ? void 0 : item.type) === ToneOverlaySeries) {
      let promises = [];
      let ctx = makeContext();
      for (const inst of this.sampledInstruments) {
        if (inst && !this.sampledInstrumentSources[inst]) {
          this.sampledInstrumentSources[inst] = await loadSamples(ctx, inst, this.samplings, (_d2 = this.config.options) == null ? void 0 : _d2.baseUrl);
        }
      }
      for (let stream of item.overlays) {
        if (stream.continued) {
          promises.push(playAbsoluteContinuousTones(ctx, stream.sounds, config, this.synths, this.waves, stream.filters));
        } else if (!stream.relative) {
          promises.push(playAbsoluteDiscreteTonesAlt(ctx, stream.sounds, config, this.sampledInstrumentSources, this.synths, this.waves, stream.filters));
        } else {
          promises.push(playRelativeDiscreteTonesAndSpeeches(ctx, stream.sounds, config, this.sampledInstrumentSources, this.synths, this.waves, stream.filters));
        }
      }
      await Promise.all(promises);
      ctx.close();
    }
    return;
  }
  stop() {
    var _a5, _b2, _c2, _d2, _e2, _f2;
    if (this.state === Playing) {
      if (((_a5 = ErieGlobalControl) == null ? void 0 : _a5.type) === Tone2 || ((_c2 = (_b2 = ErieGlobalControl) == null ? void 0 : _b2.player) == null ? void 0 : _c2.close)) {
        ErieGlobalControl.player.close();
      } else if (((_d2 = ErieGlobalControl) == null ? void 0 : _d2.type) === Speech || ((_f2 = (_e2 = ErieGlobalControl) == null ? void 0 : _e2.player) == null ? void 0 : _f2.cancel)) {
        ErieGlobalControl.player.cancel();
      }
      if (this.state !== Stopped2) {
        this.state = Stopped2;
        notifyStop(this.config);
        this.fireStopEvent();
        clearPlayerEvents();
        this.playAt = void 0;
      }
    }
  }
  pause() {
    self.state = Paused;
    notifyPause(this.config);
  }
  // todo
  async resume() {
    await notifyResume(this.config);
    return this.play(this.playAt);
  }
  fireStartEvent() {
    this.playId = genRid();
    sendQueueStartEvent({ pid: this.playId });
  }
  fireStopEvent() {
    sendQueueFinishEvent({ pid: this.playId });
  }
  destroy() {
    this.state = Finished;
    this.queue = [];
    clearPlayerEvents();
  }
};
function makeSingleStreamQueueValues(sounds) {
  let queue_values = [];
  for (const sound of sounds) {
    let time2 = sound.start !== void 0 ? sound.start : sound.time;
    let dur = sound.duration !== void 0 ? sound.duration : sound.end - time2;
    let tap = mergeTapPattern(sound.tapCount, sound.tapSpeed);
    if (sound.tapCount || sound.tapSpeed) {
      dur = tap.totalLength;
    }
    let ith_q = {
      pitch: sound.pitch,
      detune: sound.detune,
      loudness: sound.loudness,
      time: time2,
      duration: dur,
      pan: sound.pan,
      speech: sound.speech,
      language: sound.language,
      postReverb: Math.round(sound.postReverb * 100) / 100 || 0,
      timbre: sound.timbre,
      tap,
      modulation: sound.modulation || 0,
      harmonicity: sound.harmonicity || 0,
      __datum: sound.__datum,
      others: {}
    };
    if (sound.speech) {
      ith_q.duration = void 0;
      queue_values.hasSpeech = true;
    }
    Object.keys(sound || {}).forEach((chn) => {
      if (!DefaultChannels.includes(chn) && chn !== "__datum") {
        ith_q.others[chn] = sound[chn];
      }
    });
    queue_values.push(ith_q);
  }
  queue_values = queue_values.sort((a, b) => a.time + a.duration - (b.time + b.duration));
  return queue_values;
}

// node_modules/erie-web/src/util/audio-graph-format-util.js
function listString(arr, delim, isAnd, _and) {
  if (arr.length == 0)
    return "";
  else if (arr.length == 1)
    return arr[0];
  else if (arr.length == 2 && isAnd)
    return `${arr[0]} ${_and || "and"} ${arr[1]}`;
  else if (arr.length == 2 && !isAnd)
    return `${arr[0]}${delim || " "}${arr[1]} `;
  else if (!isAnd) {
    return arr.join(delim);
  } else {
    let last = arr[arr.length - 1];
    let rest = arr.slice(0, arr.length - 1);
    return rest.join(delim) + delim + `${_and || "and"}` + last;
  }
}
function toOrdinalNumbers(n2) {
  return [
    "zeroth",
    "first",
    "second",
    "third",
    "fourth",
    "fifth",
    "sixth",
    "seventh",
    "eighth",
    "nineth",
    "tenth",
    "eleventh",
    "twelveth",
    "thirteenth",
    "fourteenth",
    "fifteenth",
    "sixteenth",
    "seventeenth",
    "eighteenth",
    "nineteenth",
    "twentieth",
    "twenty-first",
    "twenty-second",
    "twenty-third"
  ][n2] || n2 + "th";
}
function toHashedObject(a, k, dp) {
  let o = {};
  a.forEach((d) => {
    let t2 = {};
    if (dp) {
      t2 = deepcopy2(d);
    } else {
      Object.assign(t2, d);
    }
    o[d[k]] = t2;
  });
  return o;
}

// node_modules/erie-web/src/scale/audio-graph-scale-desc-parser.js
var descriptionKeywords = [
  "sound",
  "list",
  "domain",
  "domain.min",
  "domain.max",
  "domain.length",
  "channel",
  "field",
  "aggregate",
  "title",
  "range.length",
  "range",
  "timeUnit"
];
function compileDescriptionMarkup(expression, channel, scale2, speechRate, timeUnit) {
  if (expression.length == 0 || !expression)
    return [];
  let exprParsed = parseDescriptionMarkup(expression);
  let scaleProps = scale2.properties;
  let preQueue = [];
  for (const seg of exprParsed) {
    if (seg.type === "text") {
      seg.speechRate = speechRate;
      preQueue.push(seg);
    } else {
      if (seg.key === "sound") {
        let item = { type: "sound" };
        if (jType(seg.value) === "Array") {
          item.continuous = true;
          item.value = seg.value.map((v) => getLKvalues(v, channel, scaleProps, timeUnit));
        } else {
          item.continuous = false;
          item.value = getLKvalues(seg.value, channel, scaleProps, timeUnit);
        }
        if (seg.duration) {
          item.duration = seg.duration;
        } else {
          if (item.continuous)
            item.duration = (timeUnit === "beat" ? 1 : 0.5) * item.value.length;
          else
            item.duration = timeUnit === "beat" ? 1 : 0.5;
        }
        preQueue.push(item);
      } else if (seg.key === "list") {
        let elements = seg.item;
        if (!elements)
          elements = getKeywordValues("domain", channel, scaleProps, timeUnit);
        let formatter = (d) => d;
        if (scaleProps.format) {
          if (scaleProps.formatType === "number")
            formatter = format(scaleProps.format);
          else if (scaleProps.formatType === "datetime")
            formatter = timeFormat(scaleProps.format);
        }
        if (elements)
          elements = elements.map((d) => jType(d) === "Number" ? formatter(d) : d);
        let first = seg.first;
        let last = seg.last;
        let item = { type: "text" };
        let textItems = [];
        if (first)
          textItems.push(...elements.slice(0, first));
        if (last)
          textItems.push(...elements.slice(elements.length - last, elements.length));
        let join = seg.join || ", ", and = seg.and;
        item.text = listString(textItems, join, and ? true : false, and);
        item.speechRate = speechRate;
        preQueue.push(item);
      } else {
        let text = getKeywordValues(seg.key, channel, scaleProps, timeUnit);
        let formatter = (d) => (d == null ? void 0 : d.toString()) || "";
        if (scaleProps.format) {
          if (scaleProps.formatType === "number")
            formatter = format(scaleProps.format);
          else if (scaleProps.formatType === "datetime")
            formatter = timeFormat(scaleProps.format);
        }
        if (jType(text) === "Array")
          text = text.map((d) => jType(d) === "Number" ? formatter(d) : d);
        else if (jType(text) !== "String")
          text = formatter(text);
        preQueue.push({
          type: "text",
          text,
          speechRate
        });
      }
    }
  }
  let queue = [];
  for (const item of preQueue) {
    if (queue.length > 0 && queue[queue.length - 1].type === "text" && item.type === "text") {
      queue[queue.length - 1].text += (item.text.startsWith(".") ? "" : " ") + item.text.trim();
    } else {
      queue.push(item);
    }
  }
  return queue;
}
function getLKvalues(item, channel, scaleProps, timeUnit) {
  if (item == null ? void 0 : item.literal)
    return item.literal;
  else if (item == null ? void 0 : item.keyword)
    return getKeywordValues(item.keyword, channel, scaleProps, timeUnit);
  else
    return void 0;
}
function getKeywordValues(keyword, channel, scaleProps, timeUnit) {
  if (keyword === "domain") {
    return scaleProps.domain.join(", ");
  } else if (keyword === "domain.min") {
    return Math.min(...scaleProps.domain);
  } else if (keyword === "domain.max") {
    return Math.max(...scaleProps.domain);
  } else if (keyword.match(/domain\[[0-9]+\]/g)) {
    let i2 = parseInt(keyword.match(/[0-9]+/g)[0]);
    return scaleProps.domain[i2];
  } else if (keyword === "domain.length") {
    return scaleProps.domain.length;
  }
  if (keyword === "range") {
    return scaleProps.range.join(", ");
  } else if (keyword === "range.length") {
    if (channel === TIME_chn2)
      return scaleProps.length;
    else
      return Math.max(...scaleProps.range) - Math.min(...scaleProps.range);
  } else if (keyword === "channel") {
    return channel;
  } else if (keyword === "field") {
    return scaleProps.field.join(", ");
  } else if (keyword === "title") {
    return scaleProps.title;
  } else if (keyword === "aggregate") {
    return scaleProps.aggregate;
  } else if (keyword === "timeUnit") {
    return timeUnit;
  }
}
var exprRegex = /(\<[^\<\>]+\>|[^\<\>]+)/g;
function parseDescriptionMarkup(expression) {
  if (jType(expression) !== "String") {
    console.error("Wrong description expression type.");
  }
  let expr = expression.trim(), hasPeriodAtTheEnd = false;
  if (expr.endsWith(".")) {
    expr = expr.substring(0, expr.length - 1);
    hasPeriodAtTheEnd = true;
  }
  let exprGroups = expr.match(exprRegex);
  if (!exprGroups) {
    console.error(`Wrong description expression (not parsable): ${expression}.`);
  }
  let parsed = [];
  for (const exprSeg of exprGroups) {
    if (exprSeg.startsWith("<")) {
      let segParsed = parseDescriptionKeywords(exprSeg);
      parsed.push(segParsed);
    } else {
      parsed.push({
        type: "text",
        text: exprSeg
      });
    }
  }
  if (parsed[parsed.length - 1].type === "text" && hasPeriodAtTheEnd) {
    parsed[parsed.length - 1].text += ".";
  }
  return parsed;
}
var descSegmentReges = /(([a-zA-Z0-9\.]+=\"[^\"]+\")|[a-zA-Z\.0-9\[\]]+)/g;
function parseDescriptionKeywords(exprSeg) {
  let output4 = {};
  let parsed = exprSeg.match(descSegmentReges);
  if (!parsed) {
    console.error(`Wrong description keyword expression: ${exprSeg}.`);
  }
  parsed.forEach((p, i2) => {
    var _a5;
    output4.type = "keyword";
    if (i2 == 0) {
      if (descriptionKeywords.includes(p))
        output4.key = p;
      else if (p.match(/domain\[[0-9]+\]/g))
        output4.key = p;
      else
        console.error(`Unidentifiable keyword: ${p}.`);
    } else {
      let ps = p.split("=");
      let value = ps[1].replace(/\"/gi, "");
      if (ps[0] === "duration") {
        output4.duration = parseFloat(value);
      } else if (ps[0] === "first") {
        output4.first = parseInt(value);
      } else if (ps[0] === "last") {
        output4.last = parseInt(value);
      } else if (ps[0] === "item") {
        if (descriptionKeywords.includes(value)) {
          output4.item = { keyword: value };
        } else if (value.match(/domain\[[0-9]+\]/g)) {
          output4.item = { keyword: value };
        } else {
          output4.item = { literal: value.split(",").map((d) => d.trim()) };
        }
      } else if (ps[0] === "value") {
        if (descriptionKeywords.includes(value)) {
          output4.value = { keyword: value };
        } else if (value.match(/domain\[[0-9]+\]/g)) {
          output4.value = { keyword: value };
        } else {
          output4.value = { literal: value };
        }
      } else if (((_a5 = ps[0].match(/v[0-9]+/g)) == null ? void 0 : _a5.length) == 1) {
        if (!output4.value)
          output4.value = [];
        let vi = parseInt(ps[0].substring(1));
        if (descriptionKeywords.includes(value)) {
          output4.value[vi] = { keyword: value };
        } else if (value.match(/domain\[[0-9]+\]/g)) {
          output4.value[vi] = { keyword: value };
        } else {
          output4.value[vi] = { literal: value };
        }
      } else {
        if (descriptionKeywords.includes(value)) {
          output4[ps[0]] = { keyword: value };
        } else if (value.match(/domain\[[0-9]+\]/g)) {
          output4[ps[0]] = { keyword: value };
        } else {
          output4[ps[0]] = { literal: value };
        }
      }
    }
  });
  return output4;
}

// node_modules/erie-web/src/scale/audio-graph-scale-desc.js
function makeScaleDescription(scale2, encoding, dataInfo, tickDef, tone_spec, config, beat) {
  var _a5, _b2, _c2, _d2, _e2, _f2, _g2;
  let properties = scale2.properties;
  let channel = properties.channel, field = properties.field, encodingType = properties.encodingType;
  let timeUnit = ((_a5 = config == null ? void 0 : config.timeUnit) == null ? void 0 : _a5.unit) || "seconds";
  if ((properties == null ? void 0 : properties.descriptionDetail) === SKIP || (properties == null ? void 0 : properties.descriptionDetail) === null) {
    return null;
  }
  let expression = "", customExpression = false;
  if (jType(properties == null ? void 0 : properties.descriptionDetail) === "String" && (properties == null ? void 0 : properties.descriptionDetail) !== NONSKIP) {
    expression = properties == null ? void 0 : properties.descriptionDetail;
    customExpression = true;
    return [{
      type: TextType,
      speech: properties == null ? void 0 : properties.descriptionDetail,
      speechRate
    }];
  }
  let speechRate = config.speechRate || DEF_SPEECH_RATE;
  let title = (encoding == null ? void 0 : encoding.scale.title) || listString(unique(properties.field), ", ", false);
  if (channel === TIME_chn2) {
    if (!customExpression)
      expression = `The <title> is mapped to <channel>. `;
    let length = properties.range ? Math.max(...properties.range) : null;
    if (length) {
      if (!customExpression)
        expression += `The duration of the stream is <range.length> <timeUnit>. `;
    }
    if (properties.binned) {
      let binInfo = encoding.binned;
      if (binInfo.equiBin) {
        if (!customExpression)
          expression += `Each sound represents a equally sized bin bucket. `;
      } else {
        if (!customExpression)
          expression += `The length of each sound represents the corresponding bin bucket size. `;
      }
    }
    if ((tickDef == null ? void 0 : tickDef.interval) && (tickDef == null ? void 0 : tickDef.description) !== SKIP) {
      if (!customExpression)
        expression += `A tick sound is played every ${tickDef.interval} ${timeUnit}. `;
    }
  } else {
    if (encodingType === QUANT2) {
      if (title && properties.aggregate && properties.aggregate !== "count") {
        if (!customExpression)
          expression += `The <title> is mapped to <channel> and aggregated by <aggregate>. `;
      } else if (properties.aggregate === "count") {
        if (!customExpression)
          expression = `The count of data points is mapped to <channel>. `;
      } else {
        if (!customExpression)
          expression = `The <title> is mapped to <channel>. `;
      }
      if (tone_spec.continued) {
        if (((_b2 = properties == null ? void 0 : properties.domain) == null ? void 0 : _b2.length) == 2) {
          if (!customExpression)
            expression += `The domains values from <domain.min> to <domain.max> are mapped to <sound v0="domain.min" v1="domain.max" duration="0.6">`;
        } else if (((_c2 = properties == null ? void 0 : properties.domain) == null ? void 0 : _c2.length) > 2) {
          if (!customExpression)
            expression += `The domains values from <domain.min> to <domain.max> are mapped to <sound ${properties.domain.map((_, i2) => "domain[" + i2 + "]")} duration="${properties.domain * 0.3}">`;
        }
      } else {
        if (((_d2 = properties == null ? void 0 : properties.domain) == null ? void 0 : _d2.length) == 2) {
          if (!customExpression)
            expression += `The minimum value <domain.min> is mapped to <sound value="domain.min" duration="0.3">, and `;
          if (!customExpression)
            expression += `the maximum value <domain.max> is mapped to <sound value="domain.max" duration="0.3">.`;
        } else if (((_e2 = properties == null ? void 0 : properties.domain) == null ? void 0 : _e2.length) > 2) {
          if (!customExpression) {
            expression += `<title> values are mapped as`;
            for (let i2 = 0; i2 < properties.domain.length; i2++) {
              expression += `<domain[${i2}]> <sound value="domain[${i2}]" duration="0.3">`;
            }
          }
        }
      }
    } else if (encodingType === TMP2) {
      if (title && properties.aggregate && properties.aggregate !== "count") {
        if (!customExpression)
          expression += `The <title> is mapped to <channel> and aggregated by <aggregate>. `;
      } else if (properties.aggregate === "count") {
        if (!customExpression)
          expression += `The count of data points is mapped to <channel>. `;
      } else {
        if (!customExpression)
          expression += `The <title> is mapped to <channel>. `;
      }
      if (tone_spec.continued) {
        if (!customExpression)
          expression += `The domains values from <domain.min> to <domain.max> are mapped to <sound v0="domain.min" v1="domain.max" duration="0.6">. `;
      } else {
        if (!customExpression)
          expression += `The minimum value <domain.min> is mapped to <sound value="domain.min" duration="0.5">, and `;
        if (!customExpression)
          expression += `the maximum value <domain.max> is mapped to <sound value="domain.max" duration="0.5">. `;
      }
    } else if (encodingType === ORD2 || encodingType === NOM2) {
      if (!customExpression)
        expression += `The <title> is mapped to <channel>. `;
      let domainCount = properties.domain.length;
      if (domainCount <= 6 || properties.playAllDescription) {
        for (let i2 = 0; i2 < domainCount; i2++) {
          if (!customExpression)
            expression += `The value <domain[${i2}]> is <sound value="domain[${i2}]" duration="0.3">. `;
        }
      } else {
        if (!customExpression)
          expression += `The first value <domain[${0}]> is <sound value="domain[${0}]" duration="0.3">. `;
        if (!customExpression)
          expression += `The second value <domain[${1}]> is <sound value="domain[${1}]" duration="0.3">. `;
        if (!customExpression)
          expression += `The second last value <domain[${domainCount - 2}]> is <sound value="domain[${domainCount - 2}]" duration="0.3">. `;
        if (!customExpression)
          expression += `The last value <domain[${domainCount - 1}]> is <sound value="domain[${domainCount - 1}]" duration="0.3">. `;
      }
    } else if (encodingType === STATIC2) {
      if (properties.conditions) {
        for (const cond of properties.conditions) {
          if (jType(cond.test) === "Array") {
            if (!customExpression)
              expression += `The values of <list item="${cond.test.join(",")}" join=", "> are mapped to <sound value="${cond.test[0]}" duration="0.3>. `;
          } else if (((_f2 = cond.test) == null ? void 0 : _f2.not) && jType(cond.test.not) === "Array") {
            if (!customExpression)
              expression += `The values that are not <list item="${cond.test.not.join(",")}" join=", "> are mapped to <sound value="${cond.test.not[0]}" duration="0.3>. `;
          } else if (cond.test && cond.name) {
            let d = cond.test[0] || ((_g2 = cond.test.not) == null ? void 0 : _g2[0]);
            if (!customExpression && d !== void 0)
              expression += `${cond.name} values are mapped to <sound value="${d}" duration="0.3>. `;
          }
        }
      }
    }
  }
  let parsedExprDesc = compileDescriptionMarkup(expression, channel, scale2, speechRate, timeUnit);
  let descList = [];
  for (const pDesc of parsedExprDesc) {
    if (pDesc.type === TextType) {
      descList.push({
        type: TextType,
        speech: pDesc.text,
        speechRate: pDesc.speechRate || speechRate
      });
    } else if (pDesc.type === "sound") {
      if (pDesc.continuous) {
        let sounds = makeConinuousAudioLegend(channel, pDesc.value, scale2, pDesc.duration);
        descList.push({
          type: ToneSeries,
          channel,
          sounds,
          instrument_type: (tone_spec == null ? void 0 : tone_spec.type) || "default",
          continued: true
        });
      } else {
        let sound = makeSingleDiscAudioLegend(channel, pDesc.value, scale2, pDesc.duration);
        descList.push({
          type: ToneType,
          sound,
          instrument_type: (tone_spec == null ? void 0 : tone_spec.type) || "default"
        });
      }
    }
  }
  return descList;
}
function makeConinuousAudioLegend(channel, domain, scale2, duration) {
  let min = Math.min(...domain), max = Math.max(...domain);
  let normalizer = (d) => (d - min) / (max - min) * duration;
  let timing = linear().domain(domain).range(domain.map(normalizer));
  let sounds = [];
  let i2 = 0;
  for (const d of domain) {
    sounds.push({
      start: timing(d),
      [channel]: scale2(d),
      duration: i2 == domain.length - 1 ? 0.15 : 0
    });
    i2++;
  }
  return sounds;
}
function makeSingleDiscAudioLegend(channel, value, scale2, duration) {
  let sound = {
    start: 0,
    [channel]: scale2(value)
  };
  if (sound.duration == void 0) {
    sound.duration = duration || 0.2;
  }
  return sound;
}
var ForceRepeatScale = "forceRepeatScale";
var PlayAt = "playScaleAt";
var BeforeAll = "beforeAll";
var BeforeThis = "beforeThis";
var AfterAll = "afterAll";
var AfterThis = "afterThis";

// node_modules/erie-web/src/compile/audio-graph-datatype.js
var SequenceStream = class {
  constructor() {
    this.streams = [];
    this.playing = false;
    this.status = void 0;
    this.prerendered = false;
    this.config = {};
    this.synths = [];
    this.samplings = [];
  }
  setTitle(t2) {
    this.title = t2;
  }
  setDescription(d) {
    this.description = d;
  }
  addStream(stream) {
    this.streams.push(stream);
  }
  addStreams(streams) {
    this.streams.push(...streams);
  }
  setSampling(samplings) {
    this.samplings = samplings;
  }
  setSynths(synths) {
    this.synths = synths;
  }
  setWaves(waves) {
    this.waves = waves;
  }
  setConfig(key2, value) {
    this.config[key2] = value;
  }
  setIntroStream(stream) {
    this.introStream = stream;
  }
  async prerender() {
    var _a5, _b2, _c2, _d2, _e2, _f2;
    this.queue = new AudioGraphQueue();
    if (this.config) {
      Object.keys(this.config).forEach((key2) => {
        this.queue.setConfig(key2, this.config[key2]);
      });
    }
    this.queue.setSampling(this.samplings);
    this.queue.setSynths(this.synths);
    this.queue.setWaves(this.waves);
    if (!this.config.skipStartSpeech) {
      this.queue.add(TextType, { speech: `To stop playing the sonification, press the X key. `, speechRate: (_a5 = this.config) == null ? void 0 : _a5.speechRate }, this.config);
    }
    if (this.introStream) {
      this.introStream.stream.forEach((d) => {
        var _a6;
        this.queue.add(TextType, { speech: d.speech, speechRate: (_a6 = this.config) == null ? void 0 : _a6.speechRate }, this.config);
      });
    } else {
      if (this.title && !this.config.skipTitle) {
        this.queue.add(TextType, { speech: `${this.title}. `, speechRate: (_b2 = this.config) == null ? void 0 : _b2.speechRate }, this.config);
      } else if (this.name && !this.config.skipTitle) {
        this.queue.add(TextType, { speech: `This sonification is about ${this.name}. `, speechRate: (_c2 = this.config) == null ? void 0 : _c2.speechRate }, this.config);
      }
      if (this.description && !this.config.skipDescription) {
        this.queue.add(TextType, { speech: this.description, speechRate: (_d2 = this.config) == null ? void 0 : _d2.speechRate }, this.config);
      }
    }
    let titles_queues = [], scales_queues = [], audio_queues = [], scale_count = 0, announced_scales = [];
    let multiSeq = this.streams.length > 1;
    if (multiSeq && !this.config.skipSquenceIntro) {
      this.queue.add(TextType, { speech: `This sonification sequence consists of ${this.streams.length} parts. `, speechRate: (_e2 = this.config) == null ? void 0 : _e2.speechRate }, this.config);
    }
    let oi = 0;
    for (const stream of this.streams) {
      let _c3 = deepcopy2(this.config || {});
      Object.assign(_c3, stream.config || {});
      let speechRate = _c3.speechRate;
      if (multiSeq) {
        let title_queue = new AudioGraphQueue();
        if ((stream.title || stream.name) && !stream.config.skipSequenceTitle) {
          title_queue.add(TextType, { speech: `Stream ${oi + 1}. ${stream.title || stream.name}. `, speechRate }, _c3);
        } else if (!stream.config.skipSequenceTitle) {
          title_queue.add(TextType, { speech: `Stream ${oi + 1}. `, speechRate }, _c3);
        }
        if (stream.description && !stream.config.skipSequenceDescription) {
          title_queue.add(TextType, { speech: stream.description, speechRate }, _c3);
        }
        titles_queues.push(title_queue);
      } else {
        titles_queues.push(new AudioGraphQueue());
      }
      let determiner = "This";
      if (multiSeq)
        determiner = "The " + toOrdinalNumbers(oi + 1);
      if (jType(stream) !== OverlayStream.name && !_c3.skipScaleSpeech) {
        let scale_text = stream.make_scale_text().filter((d) => d);
        let scales_to_announce = [];
        let forceRepeat = _c3[ForceRepeatScale];
        if (!forceRepeat)
          forceRepeat = false;
        for (const item of scale_text) {
          if (item.description) {
            if (!announced_scales.includes(item.id)) {
              scales_to_announce.push(...item.description);
              announced_scales.push(item.id);
            } else if (forceRepeat === true || (forceRepeat == null ? void 0 : forceRepeat[item.channel]) === true) {
              scales_to_announce.push(...item.description);
            }
          }
        }
        if (scales_to_announce.length > 0) {
          let scales_queue = new AudioGraphQueue();
          scales_queue.add(TextType, { speech: `${determiner} stream has the following sound mappings. `, speechRate }, _c3);
          scales_queue.addMulti(scales_to_announce, { ..._c3, tick: null });
          scale_count++;
          scales_queues.push(scales_queue);
        } else {
          scales_queues.push(null);
        }
      } else if (jType(stream) === OverlayStream.name) {
        if (!_c3.skipTitle)
          titles_queues[oi].add(TextType, { speech: `${determiner} stream has ${stream.overlays.length} overlaid sounds. `, speechRate }, _c3);
        let forceRepeat = _c3[ForceRepeatScale];
        if (!forceRepeat)
          forceRepeat = false;
        let scale_init_text_added = false;
        let scales_queue = new AudioGraphQueue();
        stream.overlays.forEach((overlay, li) => {
          let __c = deepcopy2(_c3 || {});
          Object.assign(__c, overlay.config || {});
          let speechRate2 = __c.speechRate;
          if (__c.playRepeatSequenceName !== false && overlay.title && !__c.skipOverlayTitle) {
            titles_queues[oi].add(TextType, { speech: `Overlay ${li + 1}. ${overlay.title}. `, speechRate: speechRate2 }, __c);
          } else if (__c.playRepeatSequenceName !== false && overlay.name && !__c.skipOverlayTitle) {
            titles_queues[oi].add(TextType, { speech: `Overlay ${li + 1}. ${overlay.name}. `, speechRate: speechRate2 }, __c);
          }
          if (overlay.description && !__c.skipOverlayDescription) {
            titles_queues[oi].add(TextType, { speech: overlay.description, speechRate: speechRate2 }, __c);
          }
          let scale_text = stream.make_scale_text(li).filter((d) => d);
          let scales_to_announce = [];
          for (const item of scale_text) {
            if (item.description) {
              if (!announced_scales.includes(item.id)) {
                scales_to_announce.push(...item.description);
                announced_scales.push(item.id);
              } else if (forceRepeat === true || (forceRepeat == null ? void 0 : forceRepeat[item.channel]) === true) {
                scales_to_announce.push(...item.description);
              }
            }
          }
          if (scales_to_announce.length > 0) {
            if (!forceRepeat && !scale_init_text_added) {
              scales_queue.add(TextType, { speech: `${determiner} stream has the following sound mappings. `, speechRate: speechRate2 }, __c);
              scale_init_text_added = true;
            } else {
              let determiner2 = "This";
              if (multiSeq && li > 1)
                determiner2 = "The " + toOrdinalNumbers(li);
              scales_queue.add(TextType, { speech: `${determiner2} overlay has the following sound mappings. `, speechRate: speechRate2 }, __c);
            }
            scales_queue.addMulti(scales_to_announce, { ...__c, tick: null });
            scale_count++;
          }
        });
        if (scales_queue.queue.length > 0) {
          scales_queues.push(scales_queue);
        } else {
          scales_queues.push(null);
        }
        scale_count++;
      }
      oi++;
    }
    for (const stream of this.streams) {
      let prerender_series = await stream.prerender(true);
      audio_queues.push(prerender_series);
    }
    let streamIndex = 0;
    let preaddPos = this.queue.queue.length || 0;
    let preadd = [], postadd = [];
    for (const stream of this.streams) {
      let _c3 = deepcopy2(this.config || {});
      Object.assign(_c3, stream.config || {});
      let speechRate = _c3.speechRate;
      if (titles_queues[streamIndex])
        this.queue.addQueue(titles_queues[streamIndex]);
      let scalePlayAt = _c3[PlayAt];
      if (scalePlayAt === BeforeAll) {
        if (scales_queues[streamIndex])
          preadd.push(scales_queues[streamIndex]);
      } else if (scalePlayAt === BeforeThis || !scalePlayAt) {
        if (scales_queues[streamIndex])
          this.queue.addQueue(scales_queues[streamIndex]);
      }
      let prerender_series = audio_queues[streamIndex];
      if (!_c3.skipStartPlaySpeech) {
        this.queue.add(TextType, { speech: `Start playing. `, speechRate }, _c3);
      }
      if (jType(prerender_series) === AudioGraphQueue.name) {
        this.queue.addMulti(prerender_series.queue, _c3);
      } else {
        this.queue.add(ToneSeries, prerender_series, _c3);
      }
      if (scalePlayAt === AfterAll) {
        if (scales_queues[streamIndex])
          postadd.push(scales_queues[streamIndex]);
      } else if (scalePlayAt === AfterThis) {
        if (scales_queues[streamIndex])
          this.queue.addQueue(scales_queues[streamIndex]);
      }
      streamIndex++;
    }
    if (preadd.length > 0) {
      for (const pq of preadd) {
        this.queue.addQueue(pq, preaddPos);
        preaddPos += 1;
      }
    }
    if (postadd.length > 0) {
      for (const pq of preadd) {
        this.queue.addQueue(pq);
      }
    }
    if (!this.config.skipFinishSpeech) {
      this.queue.add(TextType, { speech: "Finished.", speechRate: (_f2 = this.config) == null ? void 0 : _f2.speechRate }, this.config);
    }
    this.prerendered = true;
    this.queue.setConfig("options", this.config.options);
    return this.queue;
  }
  make_scale_text(i2, channel) {
    var _a5;
    if (i2 === void 0) {
      return this.streams.map((stream) => {
        return stream.make_scale_text(channel);
      }).flat();
    } else {
      return (_a5 = this.streams[i2]) == null ? void 0 : _a5.make_scale_text(channel);
    }
  }
  // needs test
  async prerenderScale(i2, channel) {
    let scaleQueue = (this.make_scale_text(i2, channel) || []).map((d) => d.description).flat();
    this.scaleQueue = new AudioGraphQueue();
    this.scaleQueue.addMulti(scaleQueue, { ...this.config, tick: null });
    return this.scaleQueue;
  }
  async playScaleDescription(i2, channel) {
    var _a5;
    await this.prerenderScale(i2, channel);
    await ((_a5 = this.scaleQueue) == null ? void 0 : _a5.play());
  }
  async stopScaleDescription() {
    var _a5;
    (_a5 = this.scaleQueue) == null ? void 0 : _a5.stop();
  }
  async playQueue() {
    var _a5;
    if (!this.prerendered)
      await this.prerender();
    await ((_a5 = this.queue) == null ? void 0 : _a5.play());
  }
  async stopQueue() {
    var _a5;
    (_a5 = this.queue) == null ? void 0 : _a5.stop();
  }
  destroy() {
    this.queue = this.queue.destroy();
  }
};
var OverlayStream = class {
  // todoL change to queue format
  constructor() {
    this.overlays = [];
    this.playing = false;
    this.status = void 0;
    this.prerendered = false;
    this.individual_playing = [];
    this.config = {};
    this.name;
  }
  setName(name2) {
    this.name = name2;
  }
  setTitle(title) {
    this.title = title;
  }
  setDescription(desc2) {
    this.description = desc2;
  }
  addStream(stream) {
    this.overlays.push(stream);
  }
  addStreams(streams) {
    this.overlays.push(...streams);
  }
  setConfig(key2, value) {
    this.config[key2] = value;
  }
  async prerender(subpart) {
    var _a5, _b2, _c2, _d2, _e2, _f2, _g2;
    this.queue = new AudioGraphQueue();
    if (!subpart) {
      if (this.title && !this.config.skipTitle) {
        this.queue.add(TextType, { speech: this.title, speechRate: (_a5 = this.config) == null ? void 0 : _a5.speechRate }, this.config);
      } else if (this.name && !this.config.skipTitle) {
        this.queue.add(TextType, { speech: this.name, speechRate: (_b2 = this.config) == null ? void 0 : _b2.speechRate }, this.config);
      }
      if (this.description && !this.config.skipDescription) {
        this.queue.add(TextType, { speech: this.description, speechRate: (_c2 = this.config) == null ? void 0 : _c2.speechRate }, this.config);
      }
    }
    if (this.overlays.length > 1) {
      if (!subpart && !this.config.skipStartSpeech) {
        this.queue.add(TextType, { speech: `This sonification has ${this.overlays.length} overlaid streams.`, speechRate: (_d2 = this.config) == null ? void 0 : _d2.speechRate });
        let oi = 1;
        let titles_queues = [], scales_queues = [], scale_count = 0;
        for (const stream of this.overlays) {
          let title_queue = new AudioGraphQueue();
          if ((stream.title || stream.name) && !stream.config.skipTitle) {
            title_queue.add(TextType, { speech: `The ${toOrdinalNumbers(oi)} overlay stream is about ${stream.title || stream.name}. `, speechRate: (_e2 = this.config) == null ? void 0 : _e2.speechRate }, stream.config);
          }
          if (stream.description && !stream.config.skipDescription) {
            title_queue.add(TextType, { speech: stream.description, speechRate: (_f2 = this.config) == null ? void 0 : _f2.speechRate }, stream.config);
          }
          titles_queues.push(title_queue);
          let scale_text = stream.make_scale_text().filter((d) => d);
          if (!stream.config.skipScaleSpeech && scale_text.length > 0) {
            let scales_queue = new AudioGraphQueue();
            scales_queue.add(TextType, { speech: `This stream has the following sound mappings. `, speechRate: (_g2 = this.config) == null ? void 0 : _g2.speechRate }, stream.config);
            scales_queue.addMulti(scale_text, { ...stream.config, tick: null });
            scale_count++;
            scales_queues.push(scales_queue);
          }
          oi++;
        }
        if (scale_count > 1) {
          for (let i2 = 0; i2 < oi - 1; i2++) {
            if (titles_queues[i2])
              this.queue.addQueue(titles_queues[i2]);
            if (scales_queues[i2])
              this.queue.addQueue(scales_queues[i2]);
          }
        } else {
          for (let i2 = 0; i2 < oi - 1; i2++) {
            if (titles_queues[i2])
              this.queue.addQueue(titles_queues[i2]);
          }
          for (let i2 = 0; i2 < oi - 1; i2++) {
            if (scales_queues[i2])
              this.queue.addQueue(scales_queues[i2]);
          }
        }
      }
    }
    let overlays = [];
    this.overlays.forEach(async (stream, i2) => {
      overlays.push(await stream.prerender());
    });
    this.queue.add(
      ToneOverlaySeries,
      { overlays }
    );
    this.prerendered = true;
    return this.queue;
  }
  make_scale_text(i2, channel) {
    if (i2 !== void 0) {
      let stream = this.overlays[i2];
      if (stream && !stream.config.skipScaleSpeech)
        return stream.make_scale_text(channel);
      else
        return [];
    } else {
      return this.overlays.map((stream) => {
        if (!stream.config.skipScaleSpeech)
          return stream.make_scale_text(channel);
        else
          return [];
      }).flat();
    }
  }
  async playQueue() {
    var _a5;
    if (!this.prerendered)
      await this.prerender();
    (_a5 = this.queue) == null ? void 0 : _a5.play();
  }
  async stopQueue() {
    var _a5;
    (_a5 = this.queue) == null ? void 0 : _a5.stop();
  }
};
var UnitStream = class {
  constructor(instrument_type, stream, scales, opt2) {
    this.instrument_type = instrument_type;
    this.stream = stream;
    this.option = opt2 || {};
    this.instrument;
    this.scales = scales;
    this.config = {};
    this.name;
    this.ramp = {};
  }
  setTitle(t2) {
    this.title = t2;
  }
  setDescription(d) {
    this.description = d;
  }
  setName(name2) {
    this.name = name2;
  }
  setConfig(key2, value) {
    this.config[key2] = value;
  }
  setFilters(audioFilters) {
    this.audioFilters = audioFilters;
  }
  setRamp(ramp) {
    this.ramp = deepcopy2(ramp);
  }
  make_tone_text(i2) {
    var _a5, _b2;
    let text = [];
    let identifier = i2 !== void 0 ? `The ${toOrdinalNumbers(i2 + 1)}` : `This`;
    if (this.name)
      text.push({ type: TextType, speech: `${identifier} stream is for ${this.name} layer and has a tone of`, speechRate: (_a5 = this.config) == null ? void 0 : _a5.speechRate });
    else
      text.push({ type: TextType, speech: `${identifier} stream has a tone of`, speechRate: (_b2 = this.config) == null ? void 0 : _b2.speechRate });
    text.push({ type: ToneType, sound: { pitch: DefaultFrequency, duration: 0.2, start: 0 }, instrument_type: this.instrument_type });
    return text;
  }
  make_scale_text(channel) {
    let scales = this.scales;
    let text = Object.keys(scales).filter((chn) => !channel && !OmitDesc.includes(chn) || chn === channel).map((channel2) => {
      var _a5, _b2;
      return {
        id: (_a5 = scales[channel2]) == null ? void 0 : _a5.scaleId,
        channel: channel2,
        description: (_b2 = scales[channel2]) == null ? void 0 : _b2.description
      };
    });
    return text.flat();
  }
  async prerender() {
    var _a5, _b2;
    return {
      instrument_type: this.instrument_type,
      sounds: this.stream,
      continued: (_a5 = this.option) == null ? void 0 : _a5.is_continued,
      relative: (_b2 = this.option) == null ? void 0 : _b2.relative,
      filters: this.audioFilters,
      ramp: this.ramp
    };
  }
};
var SpeechStream = class {
  constructor(stream) {
    this.stream = stream;
    this.config = {};
  }
  setConfig(key2, value) {
    this.config[key2] = value;
  }
  make_scale_text() {
    return [];
  }
  async prerender() {
    var _a5;
    let text = [];
    for (const stream of this.stream) {
      if (stream.speech) {
        text.push({ type: TextType, speech: stream.speech, speechRate: (_a5 = this.config) == null ? void 0 : _a5.speechRate });
      }
    }
    return text;
  }
};
var OmitDesc = ["time2"];

// node_modules/erie-web/src/compile/audio-graph-repeat-stream.js
function makeRepeatStreamTree(level, values2, directions) {
  let tree = {};
  if (level === void 0)
    level = 0;
  if (directions.length <= level)
    return { direction: "leaf", node: [] };
  let memberships = values2.map((v) => v.membership[level]);
  let curr_value_list = [];
  let dir = directions[level];
  tree.direction = dir;
  tree.nodes = [];
  tree.field = memberships[0].key;
  let membership_checked = [];
  for (const member of memberships) {
    if (!membership_checked.includes(member.value)) {
      membership_checked.push(member.value);
      if (!curr_value_list.includes(member.value)) {
        let subValues = values2.filter((d) => d[level] === member.value);
        if (subValues.length > 0) {
          let subtree = makeRepeatStreamTree(level + 1, subValues, directions);
          subtree.parent_value = member.value;
          tree.nodes.push(subtree);
          curr_value_list.push(member.value);
        }
      }
    }
  }
  return tree;
}
function postprocessRepeatStreams(tree) {
  let flat_streams = postprocessRstreamTree(tree);
  flat_streams = flat_streams.nodes.map((s) => {
    if (jType(s) === UnitStream.name)
      return s;
    else if (s.length == 1)
      return s[0];
    else if (s.length > 1) {
      let overlay = new OverlayStream();
      overlay.addStreams(s);
      return overlay;
    }
  });
  return flat_streams;
}
function postprocessRstreamTree(tree) {
  if (tree.direction === "leaf")
    return { nodes: tree.node, dir: "leaf" };
  else {
    if (tree.direction === OVERLAY) {
      let flat_overlay = [];
      tree.nodes.forEach((node) => {
        let { nodes, dir } = postprocessRstreamTree(node);
        flat_overlay.push(...nodes);
      });
      return { nodes: flat_overlay.filter((d) => d !== void 0), dir: OVERLAY };
    } else if (tree.direction === SEQUENCE) {
      let flat_seq = [];
      tree.nodes.forEach((node) => {
        let { nodes, dir } = postprocessRstreamTree(node);
        if (dir === OVERLAY) {
          flat_seq.push(nodes);
        } else {
          flat_seq.push(...nodes);
        }
      });
      return { nodes: flat_seq.filter((d) => d !== void 0), dir: SEQUENCE };
    }
  }
}

// node_modules/erie-web/src/compile/audio-graph-normalize.js
async function normalizeSpecification(_spec) {
  var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j2;
  let spec = deepcopy2(_spec);
  let streams = [], datasets = deepcopy2(spec.datasets || []), synths = deepcopy2(spec.synth || []), samplings = deepcopy2(spec.sampling || []), tickDefs = deepcopy2(spec.tick || []), waves = deepcopy2(spec.wave || []), scales = [], config;
  let used_encodings = [];
  if (isSingleStream(spec)) {
    if (spec.data) {
      let new_data_name = "data__" + (datasets.length + 1);
      datasets.push({
        name: new_data_name,
        ...deepcopy2(spec.data)
      });
      spec.data = { name: new_data_name };
    }
    let { normalized, scaleDefinitions } = normalizeSingleSpec(spec, null);
    streams.push({ stream: normalized });
    scales.push(...scaleDefinitions);
    used_encodings.push(...Object.keys(normalized.encoding));
  } else {
    let new_data_name;
    if (spec.data && !spec.data.name) {
      new_data_name = "data__" + (datasets.length + 1);
      datasets.push({
        name: new_data_name,
        ...deepcopy2(spec.data)
      });
    }
    if (isOverlayStream(spec)) {
      let overlay = [];
      let h_data, h_data_name;
      if (spec.data && !spec.data.name) {
        h_data = deepcopy2(spec.data);
        h_data_name = `data__${datasets.length + 1}`;
        datasets.push({ name: h_data_name, ...h_data });
      } else if ((_a5 = spec.data) == null ? void 0 : _a5.name) {
        h_data = deepcopy2(spec.data);
      }
      for (const _o2 of spec.overlay) {
        let o = deepcopy2(_o2);
        if (h_data && !o.data) {
          if (h_data_name) {
            o.data = { name: h_data_name };
          } else if (!o.data) {
            o.data = h_data;
          }
        } else if (o.data) {
          if (!o.data.name) {
            let dname = `data__${datasets.length + 1}`;
            datasets.push({ name: dname, ...o.data });
            o.data = { name: dname };
          }
        }
        if ((_b2 = o.encoding) == null ? void 0 : _b2.time.tick) {
          if (!((_c2 = o.encoding) == null ? void 0 : _c2.time.tick.name) || !tickDefs.filter((d) => {
            var _a6;
            return d.name === ((_a6 = o.encoding) == null ? void 0 : _a6.time.tick.name);
          })) {
            let new_tick_name = ((_d2 = o.encoding) == null ? void 0 : _d2.time.tick.name) || "tick_" + (tickDefs.length + 1);
            tickDefs.push({
              ...(_e2 = o.encoding) == null ? void 0 : _e2.time.tick,
              name: new_tick_name
            });
            o.encoding.time.tick = { name: new_tick_name };
          }
        }
        if (!o.data)
          o.data = { name: new_data_name };
        o.common_transform = deepcopy2(spec.transform || []);
        o.transform = deepcopy2(_o2.transform || []);
        if (!isSingleStream(_o2))
          console.error("An overlay of multi-stream sequences is not supported!");
        let n2 = normalizeSingleSpec(o, OVERLAY);
        used_encodings.push(...Object.keys(n2.normalized.encoding));
        overlay.push(n2.normalized);
        scales.push(...n2.scaleDefinitions);
      }
      let config2 = {};
      Object.assign(config2, spec.config);
      normalizeScaleConsistency(config2, unique(used_encodings));
      delete config2.sequenceScaleConsistency;
      delete config2.forceSequenceScaleConsistency;
      streams.push({ overlay, name: spec.name, title: spec.title, description: spec.description, config: config2 });
    } else if (isSequenceStream(spec)) {
      let output4 = [];
      let introSeq = {};
      config = {};
      Object.assign(config, spec.config);
      if (spec.title) {
        introSeq.title = spec.title;
      }
      if (spec.description) {
        introSeq.description = spec.description;
      }
      if (Object.keys(introSeq).length > 0) {
        output4.push({ intro: introSeq });
      }
      for (const _o2 of spec.sequence) {
        let o = deepcopy2(_o2);
        if (isSequenceStream(_o2))
          console.error("A sequence of sequence is not supported!");
        if (isSingleStream(o)) {
          if ((_f2 = o.encoding) == null ? void 0 : _f2.time.tick) {
            if (!((_g2 = o.encoding) == null ? void 0 : _g2.time.tick.name) || !tickDefs.filter((d) => {
              var _a6;
              return d.name === ((_a6 = o.encoding) == null ? void 0 : _a6.time.tick.name);
            })) {
              let new_tick_name = ((_h2 = o.encoding) == null ? void 0 : _h2.time.tick.name) || "tick_" + (tickDefs.length + 1);
              tickDefs.push({
                ...(_i = o.encoding) == null ? void 0 : _i.time.tick,
                name: new_tick_name
              });
              o.encoding.time.tick = { name: new_tick_name };
            }
          }
          if (!o.data)
            o.data = { name: new_data_name };
          else if ((_j2 = o.data) == null ? void 0 : _j2.values) {
            let new_data_name_2 = "data__" + (datasets.length + 1);
            datasets.push({
              name: new_data_name_2,
              values: deepcopy2(o.data.values)
            });
            o.data = { name: new_data_name_2 };
          }
          o.common_transform = deepcopy2(spec.transform || []);
          o.transform = deepcopy2(_o2.transform || []);
          let n2 = normalizeSingleSpec(o, SEQUENCE);
          scales.push(...n2.scaleDefinitions);
          output4.push(n2.normalized);
          used_encodings.push(...Object.keys(n2.normalized.encoding));
        } else if (isOverlayStream(o)) {
          o.id = "overlay-" + genRid();
          let n2 = await normalizeSpecification(o);
          let over = n2.normalized[0];
          over.id = o.id;
          output4.push(over);
          n2.scaleDefinitions.forEach((d) => {
            d.parentId = over.id;
          });
          n2.normalized[0].overlay.forEach((ov) => {
            used_encodings.push(...Object.keys(ov.encoding));
          });
          scales.push(...n2.scaleDefinitions);
          Object.assign(datasets, n2.datasets);
          Object.assign(tickDefs, n2.tick);
        }
      }
      normalizeScaleConsistency(config, unique(used_encodings));
      delete config.overlayScaleConsistency;
      delete config.forceOverlayScaleConsistency;
      streams.push(...output4.map((d) => {
        if (d.intro) {
          return { intro: d.intro };
        } else if (d.overlay) {
          return {
            overlay: d.overlay || d,
            id: d.overlay.id || d.id,
            name: d.overlay.name || d.name,
            title: d.overlay.title || d.title,
            description: d.overlay.description || d.description,
            config: d.config
          };
        } else {
          return { stream: d };
        }
      }));
    }
  }
  let dataset_hash = toHashedObject(datasets, "name", true);
  let tick_hash = toHashedObject(tickDefs, "name", true);
  if (!config) {
    config = {};
    Object.assign(config, spec.config);
    normalizeScaleConsistency(config, unique(used_encodings));
    delete config.overlayScaleConsistency;
    delete config.forceOverlayScaleConsistency;
  }
  return {
    normalized: streams,
    datasets: dataset_hash,
    tick: tick_hash,
    scaleDefinitions: scales,
    sequenceConfig: config,
    synths,
    samplings,
    waves
  };
}
function isRepeatedStream(spec) {
  var _a5;
  if (spec && spec.encoding && ((_a5 = spec.encoding) == null ? void 0 : _a5.repeat)) {
    return true;
  }
  return false;
}
function isSingleStream(spec) {
  if (spec && spec.encoding && spec.tone && !spec.overlay && !spec.sequence) {
    return true;
  }
  return false;
}
function isOverlayStream(spec) {
  if (spec && !spec.encoding && !spec.tone && spec.overlay && !spec.sequence) {
    return true;
  }
  return false;
}
function isSequenceStream(spec) {
  if (spec && !spec.encoding && !spec.tone && !spec.overlay && spec.sequence) {
    return true;
  }
  return false;
}
var bin_ending = "__bin";
var bin_end_ending = "__bin_end";
var count_ending = "__count";
var Def_tone = "default";
var Auto = "auto";
function normalizeSingleSpec(spec, parent) {
  var _a5, _b2, _c2, _d2, _e2;
  let scaleDefinitions = [];
  if (!spec)
    return null;
  let is_part_of_overlay = parent === OVERLAY;
  let normalized = {};
  if (spec.title) {
    normalized.title = spec.title;
  }
  if (spec.name) {
    normalized.name = spec.name;
  }
  normalized.id = "stream-" + genRid();
  if (spec.description) {
    normalized.description = spec.description;
  }
  if (spec.data) {
    normalized.data = deepcopy2(spec.data);
  }
  if (spec.tone) {
    normalized.tone = {};
    if (jType(spec.tone) === "String") {
      normalized.tone.type = spec.tone;
    } else if (jType(spec.tone) === "Object") {
      normalized.tone = deepcopy2(spec.tone);
      if (normalized.tone.type === void 0) {
        normalized.tone.type = Def_tone;
      }
    }
    if (jType((_a5 = spec.tone) == null ? void 0 : _a5.filter) === "Array") {
      normalized.filter = [...spec.tone.filter];
    }
  }
  let further_transforms = [];
  let encoding_aggregates = [];
  if (spec.encoding) {
    normalized.encoding = {};
    if (((_c2 = (_b2 = spec.encoding[TIME_chn2]) == null ? void 0 : _b2.scale) == null ? void 0 : _c2.timing) === SIM_TIMING) {
      if (spec.encoding[SPEECH_BEFORE_chn2] && spec.encoding[SPEECH_AFTER_chn2]) {
        console.warn(`Speech channels cannot be used for simultaneous timing. ${SPEECH_BEFORE_chn2} and ${SPEECH_AFTER_chn2} are dropped.`);
        delete spec.encoding[SPEECH_BEFORE_chn2];
        delete spec.encoding[SPEECH_AFTER_chn2];
      } else if (spec.encoding[SPEECH_BEFORE_chn2]) {
        console.warn(`Speech channels cannot be used for simultaneous timing. ${SPEECH_BEFORE_chn2} is dropped.`);
        delete spec.encoding[SPEECH_BEFORE_chn2];
      } else if (spec.encoding[SPEECH_AFTER_chn2]) {
        console.warn(`Speech channels cannot be used for simultaneous timing. ${SPEECH_AFTER_chn2} is dropped.`);
        delete spec.encoding[SPEECH_AFTER_chn2];
      }
    }
    let has_repeated_overlay = false;
    for (const channel of Object.keys(spec.encoding)) {
      let o_enc = spec.encoding[channel], enc = {};
      if (o_enc.field)
        enc.field = o_enc.field;
      if (o_enc.type)
        enc.type = o_enc.type;
      if (o_enc.by) {
        if (jType(o_enc.by) === "Array" && !o_enc.by.join("X").match(/(^(sequence|sequenceX)*(overlay|overlayX)*$)/gi)) {
          console.error("Wrong repeat-by form. Overlay cannot preceed sequence!");
        }
        enc.by = o_enc.by;
        has_repeated_overlay = enc.by.includes(OVERLAY);
        if (has_repeated_overlay && is_part_of_overlay) {
          console.error("Overlay composition + overlay repet is not supported.");
        }
      }
      ;
      if (o_enc.ramp && RampMethods2.includes(o_enc.ramp)) {
        if (o_enc.ramp.constructor.name === "String")
          enc.ramp = o_enc.ramp;
        else
          enc.ramp = o_enc.ramp ? "linear" : "exponential";
      } else {
        enc.ramp = "linear";
      }
      if (o_enc.speech)
        enc.speech = o_enc.speech;
      if (o_enc.value !== void 0)
        enc.value = o_enc.value;
      if (channel === TIME_chn2 && o_enc.tick)
        enc.tick = deepcopy2(o_enc.tick);
      if (o_enc.scale) {
        enc.scale = deepcopy2(o_enc.scale);
      } else {
        enc.scale = {};
      }
      if (o_enc.format)
        enc.format = o_enc.format;
      if (o_enc.formatType)
        enc.formatType = o_enc.formatType;
      if (o_enc.bin) {
        if (jType(o_enc.bin) === "Object") {
          further_transforms.push({
            bin: o_enc.field,
            step: o_enc.bin.step,
            maxbins: o_enc.bin.maxbins,
            nice: o_enc.bin.nice,
            as: o_enc.field + bin_ending,
            exact: o_enc.bin.exact,
            end: o_enc.field + bin_end_ending
          });
        } else if (jType(o_enc.bin) === "Boolean") {
          further_transforms.push({
            bin: o_enc.field,
            auto: true,
            as: o_enc.field + bin_ending,
            end: o_enc.field + bin_end_ending
          });
        }
        enc.field = o_enc.field + bin_ending;
        enc.original_field = o_enc.field;
        enc.type = QUANT2;
        if (channel === TIME_chn2) {
          normalized.encoding[channel + "2"] = {
            field: o_enc.field + bin_end_ending
          };
        }
        if (!enc.scale)
          enc.scale = {};
        enc.scale.title = o_enc.field + " (binned)";
        enc.binned = true;
      }
      if (o_enc.aggregate) {
        if (!o_enc.field && o_enc.aggregate === "count") {
          encoding_aggregates.push({
            op: "count",
            as: count_ending
          });
          enc.field = count_ending;
          if (!enc.scale)
            enc.scale = {};
          enc.scale.title = "Count";
          enc.type = QUANT2;
        } else {
          encoding_aggregates.push({
            op: o_enc.aggregate,
            field: o_enc.field,
            as: o_enc.field + "__" + o_enc.aggregate,
            p: o_enc.p
          });
          enc.field = o_enc.field + "__" + o_enc.aggregate;
          enc.original_field = o_enc.field;
          if (!enc.scale)
            enc.scale = {};
          enc.scale.title = o_enc.aggregate + " " + o_enc.field;
          enc.type = o_enc.type || QUANT2;
        }
        enc.aggregate = o_enc.aggregate;
      }
      if (o_enc.condition) {
        enc.condtion = deepcopy2(o_enc.condition);
      }
      if (channel === TAPCNT_chn2 && spec.encoding[TAPSPD_chn2]) {
        enc.hasTapSpeed = true;
      } else if (channel === TAPSPD_chn2 && spec.encoding[TAPCNT_chn2]) {
        enc.hasTapCount = true;
      }
      let scaleId = "scale-" + genRid();
      let scaleDef = {
        id: scaleId,
        channel,
        type: enc.type,
        dataName: normalized.data.name,
        field: [enc.field],
        scale: deepcopy2(enc.scale),
        streamID: [normalized.id],
        parentType: parent
      };
      enc.scale.id = scaleId;
      scaleDefinitions.push(scaleDef);
      normalized.encoding[channel] = enc;
    }
    if (normalized.encoding[TIME2_chn2]) {
      normalized.encoding[TIME2_chn2].scale = { id: (_e2 = (_d2 = normalized.encoding[TIME_chn2]) == null ? void 0 : _d2.scale) == null ? void 0 : _e2.id };
      scaleDefinitions.forEach((d) => {
        var _a6, _b3;
        if (d.channel === TIME_chn2 && d.id === ((_b3 = (_a6 = normalized.encoding[TIME_chn2]) == null ? void 0 : _a6.scale) == null ? void 0 : _b3.id)) {
          if (!d.hasTime2)
            d.hasTime2 = [];
          d.hasTime2.push(normalized.id);
        }
      });
    }
    if (normalized.encoding[REPEAT_chn2]) {
      scaleDefinitions.forEach((d) => {
        if (!d.isRepeated)
          d.isRepeated = [];
        d.isRepeated.push(normalized.id);
      });
    }
    let used_channels = Object.keys(normalized.encoding);
    if (has_repeated_overlay || is_part_of_overlay) {
      if (used_channels.includes(SPEECH_AFTER_chn2) || used_channels.includes(SPEECH_BEFORE_chn2)) {
        console.warn("Using speechAfter/Before channels for an overlaid stream is not recommended.");
      }
    }
  }
  if (spec.common_transform) {
    normalized.common_transform = deepcopy2(spec.common_transform);
  }
  if (spec.transform) {
    normalized.transform = deepcopy2(spec.transform);
  }
  if (further_transforms.length > 0) {
    if (!normalized.transform)
      normalized.transform = [];
    normalized.transform.push(...further_transforms);
  }
  if (encoding_aggregates.length > 0) {
    normalized.encoding_aggregates = encoding_aggregates;
    if (!normalized.transform)
      normalized.transform = [];
    normalized.transform.push({ aggregate: encoding_aggregates, groupby: Auto });
  }
  if (spec.config) {
    let config = {};
    Object.assign(config, spec.config);
    normalized.config = config;
  }
  return { normalized, scaleDefinitions };
}
function normalizeScaleConsistency(config, used_channels) {
  var _a5, _b2, _c2, _d2;
  let overlayScaleConsistency = {}, forceOverlayScaleConsistency = {}, sequenceScaleConsistency = {}, forceSequenceScaleConsistency = {};
  for (const chn of used_channels) {
    if (((_a5 = config.overlayScaleConsistency) == null ? void 0 : _a5[chn]) !== void 0) {
      overlayScaleConsistency[chn] = config.overlayScaleConsistency[chn];
    } else if (jType(config.overlayScaleConsistency) === "Boolean") {
      overlayScaleConsistency[chn] = config.overlayScaleConsistency;
    } else {
      overlayScaleConsistency[chn] = true;
    }
    if (((_b2 = config.forceOverlayScaleConsistency) == null ? void 0 : _b2[chn]) !== void 0) {
      forceOverlayScaleConsistency[chn] = config.forceOverlayScaleConsistency[chn];
    } else if (jType(config.overlayScaleConsistency) === "Boolean") {
      forceOverlayScaleConsistency[chn] = config.forceOverlayScaleConsistency;
    } else {
      forceOverlayScaleConsistency[chn] = false;
    }
    if (((_c2 = config.sequenceScaleConsistency) == null ? void 0 : _c2[chn]) !== void 0) {
      sequenceScaleConsistency[chn] = config.sequenceScaleConsistency[chn];
    } else if (jType(config.sequenceScaleConsistency) === "Boolean") {
      sequenceScaleConsistency[chn] = config.sequenceScaleConsistency;
    } else {
      sequenceScaleConsistency[chn] = true;
    }
    if (((_d2 = config.forceSequenceScaleConsistency) == null ? void 0 : _d2[chn]) !== void 0) {
      forceSequenceScaleConsistency[chn] = config.forceSequenceScaleConsistency[chn];
    } else if (jType(config.overlayScaleConsistency) === "Boolean") {
      forceSequenceScaleConsistency[chn] = config.forceSequenceScaleConsistency;
    } else {
      forceSequenceScaleConsistency[chn] = false;
    }
  }
  config.overlayScaleConsistency = overlayScaleConsistency;
  config.forceOverlayScaleConsistency = forceOverlayScaleConsistency;
  config.sequenceScaleConsistency = sequenceScaleConsistency;
  config.forceSequenceScaleConsistency = forceSequenceScaleConsistency;
}

// node_modules/arquero/src/util/is-array.js
var is_array_default = Array.isArray;

// node_modules/arquero/src/util/to-array.js
function to_array_default(value) {
  return value != null ? is_array_default(value) ? value : [value] : [];
}

// node_modules/arquero/src/helpers/slice.js
function slice_default(start = 0, end = Infinity) {
  return `${prep(start)} < row_number() && row_number() <= ${prep(end)}`;
}
function prep(index) {
  return index < 0 ? `count() + ${index}` : index;
}

// node_modules/arquero/src/table/transformable.js
var Transformable = class {
  /**
   * Instantiate a new Transformable instance.
   * @param {Params} [params] The parameter values.
   */
  constructor(params) {
    if (params)
      this._params = params;
  }
  /**
   * Get or set table expression parameter values.
   * If called with no arguments, returns the current parameter values
   * as an object. Otherwise, adds the provided parameters to this
   * table's parameter set and returns the table. Any prior parameters
   * with names matching the input parameters are overridden.
   * @param {Params} [values] The parameter values.
   * @return {this|Params} The current parameters values (if called with
   *  no arguments) or this table.
   */
  params(values2) {
    if (arguments.length) {
      if (values2) {
        this._params = { ...this._params, ...values2 };
      }
      return this;
    } else {
      return this._params;
    }
  }
  /**
   * Create a new fully-materialized instance of this table.
   * All filter and orderby settings are removed from the new table.
   * Instead, the backing data itself is filtered and ordered as needed.
   * @param {number[]} [indices] Ordered row indices to materialize.
   *  If unspecified, all rows passing the table filter are used.
   * @return {this} A reified table.
   */
  reify(indices) {
    return this.__reify(this, indices);
  }
  // -- Transformation Verbs ------------------------------------------------
  /**
   * Count the number of values in a group. This method is a shorthand
   * for {@link Transformable#rollup} with a count aggregate function.
   * @param {CountOptions} [options] Options for the count.
   * @return {this} A new table with groupby and count columns.
   * @example table.groupby('colA').count()
   * @example table.groupby('colA').count({ as: 'num' })
   */
  count(options) {
    return this.__count(this, options);
  }
  /**
   * Derive new column values based on the provided expressions. By default,
   * new columns are added after (higher indices than) existing columns. Use
   * the before or after options to place new columns elsewhere.
   * @param {ExprObject} values Object of name-value pairs defining the
   *  columns to derive. The input object should have output column
   *  names for keys and table expressions for values.
   * @param {DeriveOptions} [options] Options for dropping or relocating
   *  derived columns. Use either a before or after property to indicate
   *  where to place derived columns. Specifying both before and after is an
   *  error. Unlike the relocate verb, this option affects only new columns;
   *  updated columns with existing names are excluded from relocation.
   * @return {this} A new table with derived columns added.
   * @example table.derive({ sumXY: d => d.x + d.y })
   * @example table.derive({ z: d => d.x * d.y }, { before: 'x' })
   */
  derive(values2, options) {
    return this.__derive(this, values2, options);
  }
  /**
   * Filter a table to a subset of rows based on the input criteria.
   * The resulting table provides a filtered view over the original data; no
   * data copy is made. To create a table that copies only filtered data to
   * new data structures, call {@link Transformable#reify} on the output table.
   * @param {TableExpr} criteria Filter criteria as a table expression.
   *  Both aggregate and window functions are permitted, taking into account
   *  {@link Transformable#groupby} or {@link Transformable#orderby} settings.
   * @return {this} A new table with filtered rows.
   * @example table.filter(d => abs(d.value) < 5)
   */
  filter(criteria) {
    return this.__filter(this, criteria);
  }
  /**
   * Extract rows with indices from start to end (end not included), where
   * start and end represent per-group ordered row numbers in the table.
   * @param {number} [start] Zero-based index at which to start extraction.
   *  A negative index indicates an offset from the end of the group.
   *  If start is undefined, slice starts from the index 0.
   * @param {number} [end] Zero-based index before which to end extraction.
   *  A negative index indicates an offset from the end of the group.
   *  If end is omitted, slice extracts through the end of the group.
   * @return {this} A new table with sliced rows.
   * @example table.slice(1, -1)
   */
  slice(start, end) {
    return this.filter(slice_default(start, end)).reify();
  }
  /**
   * Group table rows based on a set of column values.
   * Subsequent operations that are sensitive to grouping (such as
   * aggregate functions) will operate over the grouped rows.
   * To undo grouping, use {@link Transformable#ungroup}.
   * @param  {...ExprList} keys Key column values to group by.
   *  The keys may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @return {this} A new table with grouped rows.
   * @example table.groupby('colA', 'colB')
   * @example table.groupby({ key: d => d.colA + d.colB })
   */
  groupby(...keys) {
    return this.__groupby(this, keys.flat());
  }
  /**
   * Order table rows based on a set of column values.
   * Subsequent operations sensitive to ordering (such as window functions)
   * will operate over sorted values.
   * The resulting table provides an view over the original data, without
   * any copying. To create a table with sorted data copied to new data
   * strucures, call {@link Transformable#reify} on the result of this method.
   * To undo ordering, use {@link Transformable#unorder}.
   * @param  {...OrderKeys} keys Key values to sort by, in precedence order.
   *  By default, sorting is done in ascending order.
   *  To sort in descending order, wrap values using {@link desc}.
   *  If a string, order by the column with that name.
   *  If a number, order by the column with that index.
   *  If a function, must be a valid table expression; aggregate functions
   *  are permitted, but window functions are not.
   *  If an object, object values must be valid values parameters
   *  with output column names for keys and table expressions
   *  for values (the output names will be ignored).
   *  If an array, array values must be valid key parameters.
   * @return {this} A new ordered table.
   * @example table.orderby('a', desc('b'))
   * @example table.orderby({ a: 'a', b: desc('b') )})
   * @example table.orderby(desc(d => d.a))
   */
  orderby(...keys) {
    return this.__orderby(this, keys.flat());
  }
  /**
   * Relocate a subset of columns to change their positions, also
   * potentially renaming them.
   * @param {Selection} columns An ordered selection of columns to relocate.
   *  The input may consist of column name strings, column integer indices,
   *  rename objects with current column names as keys and new column names
   *  as values, or functions that take a table as input and returns a valid
   *  selection parameter (typically the output of selection helper functions
   *  such as {@link all}, {@link not}, or {@link range}).
   * @param {RelocateOptions} options Options for relocating. Must include
   *  either the before or after property to indicate where to place the
   *  relocated columns. Specifying both before and after is an error.
   * @return {this} A new table with relocated columns.
   * @example table.relocate(['colY', 'colZ'], { after: 'colX' })
   * @example table.relocate(not('colB', 'colC'), { before: 'colA' })
   * @example table.relocate({ colA: 'newA', colB: 'newB' }, { after: 'colC' })
   */
  relocate(columns2, options) {
    return this.__relocate(this, to_array_default(columns2), options);
  }
  /**
   * Rename one or more columns, preserving column order.
   * @param {...Select} columns One or more rename objects with current
   *  column names as keys and new column names as values.
   * @return {this} A new table with renamed columns.
   * @example table.rename({ oldName: 'newName' })
   * @example table.rename({ a: 'a2', b: 'b2' })
   */
  rename(...columns2) {
    return this.__rename(this, columns2.flat());
  }
  /**
   * Rollup a table to produce an aggregate summary.
   * Often used in conjunction with {@link Transformable#groupby}.
   * To produce counts only, {@link Transformable#count} is a shortcut.
   * @param {ExprObject} [values] Object of name-value pairs defining aggregate
   *  output columns. The input object should have output column names for
   *  keys and table expressions for values. The expressions must be valid
   *  aggregate expressions: window functions are not allowed and column
   *  references must be arguments to aggregate functions.
   * @return {this} A new table of aggregate summary values.
   * @example table.groupby('colA').rollup({ mean: d => mean(d.colB) })
   * @example table.groupby('colA').rollup({ mean: op.median('colB') })
   */
  rollup(values2) {
    return this.__rollup(this, values2);
  }
  /**
   * Generate a table from a random sample of rows.
   * If the table is grouped, performs a stratified sample by
   * sampling from each group separately.
   * @param {number|TableExpr} size The number of samples to draw per group.
   *  If number-valued, the same sample size is used for each group.
   *  If function-valued, the input should be an aggregate table
   *  expression compatible with {@link Transformable#rollup}.
   * @param {SampleOptions} [options] Options for sampling.
   * @return {this} A new table with sampled rows.
   * @example table.sample(50)
   * @example table.sample(100, { replace: true })
   * @example table.groupby('colA').sample(() => op.floor(0.5 * op.count()))
   */
  sample(size, options) {
    return this.__sample(this, size, options);
  }
  /**
   * Select a subset of columns into a new table, potentially renaming them.
   * @param {...Select} columns An ordered selection of columns.
   *  The input may consist of column name strings, column integer indices,
   *  rename objects with current column names as keys and new column names
   *  as values, or functions that take a table as input and returns a valid
   *  selection parameter (typically the output of selection helper functions
   *  such as {@link all}, {@link not}, or {@link range}).
   * @return {this} A new table of selected columns.
   * @example table.select('colA', 'colB')
   * @example table.select(not('colB', 'colC'))
   * @example table.select({ colA: 'newA', colB: 'newB' })
   */
  select(...columns2) {
    return this.__select(this, columns2.flat());
  }
  /**
   * Ungroup a table, removing any grouping criteria.
   * Undoes the effects of {@link Transformable#groupby}.
   * @return {this} A new ungrouped table, or this table if not grouped.
   * @example table.ungroup()
   */
  ungroup() {
    return this.__ungroup(this);
  }
  /**
   * Unorder a table, removing any sorting criteria.
   * Undoes the effects of {@link Transformable#orderby}.
   * @return {this} A new unordered table, or this table if not ordered.
   * @example table.unorder()
   */
  unorder() {
    return this.__unorder(this);
  }
  // -- Cleaning Verbs ------------------------------------------------------
  /**
   * De-duplicate table rows by removing repeated row values.
   * @param {...ExprList} keys Key columns to check for duplicates.
   *  Two rows are considered duplicates if they have matching values for
   *  all keys. If keys are unspecified, all columns are used.
   *  The keys may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @return {this} A new de-duplicated table.
   * @example table.dedupe()
   * @example table.dedupe('a', 'b')
   * @example table.dedupe({ abs: d => op.abs(d.a) })
   */
  dedupe(...keys) {
    return this.__dedupe(this, keys.flat());
  }
  /**
   * Impute missing values or rows. Accepts a set of column-expression pairs
   * and evaluates the expressions to replace any missing (null, undefined,
   * or NaN) values in the original column.
   * If the expand option is specified, imputes new rows for missing
   * combinations of values. All combinations of key values (a full cross
   * product) are considered for each level of grouping (specified by
   * {@link Transformable#groupby}). New rows will be added for any combination
   * of key and groupby values not already contained in the table. For all
   * non-key and non-group columns the new rows are populated with imputation
   * values (first argument) if specified, otherwise undefined.
   * If the expand option is specified, any filter or orderby settings are
   * removed from the output table, but groupby settings persist.
   * @param {ExprObject} values Object of name-value pairs for the column values
   *  to impute. The input object should have existing column names for keys
   *  and table expressions for values. The expressions will be evaluated to
   *  determine replacements for any missing values.
   * @param {ImputeOptions} [options] Imputation options. The expand
   *  property specifies a set of column values to consider for imputing
   *  missing rows. All combinations of expanded values are considered, and
   *  new rows are added for each combination that does not appear in the
   *  input table.
   * @return {this} A new table with imputed values and/or rows.
   * @example table.impute({ v: () => 0 })
   * @example table.impute({ v: d => op.mean(d.v) })
   * @example table.impute({ v: () => 0 }, { expand: ['x', 'y'] })
   */
  impute(values2, options) {
    return this.__impute(this, values2, options);
  }
  // -- Reshaping Verbs -----------------------------------------------------
  /**
   * Fold one or more columns into two key-value pair columns.
   * The fold transform is an inverse of the {@link Transformable#pivot} transform.
   * The resulting table has two new columns, one containing the column
   * names (named "key") and the other the column values (named "value").
   * The number of output rows equals the original row count multiplied
   * by the number of folded columns.
   * @param {ExprList} values The columns to fold.
   *  The columns may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @param {FoldOptions} [options] Options for folding.
   * @return {this} A new folded table.
   * @example table.fold('colA')
   * @example table.fold(['colA', 'colB'])
   * @example table.fold(range(5, 8))
   */
  fold(values2, options) {
    return this.__fold(this, values2, options);
  }
  /**
   * Pivot columns into a cross-tabulation.
   * The pivot transform is an inverse of the {@link Transformable#fold} transform.
   * The resulting table has new columns for each unique combination
   * of the provided *keys*, populated with the provided *values*.
   * The provided *values* must be aggregates, as a single set of keys may
   * include more than one row. If string-valued, the *any* aggregate is used.
   * If only one *values* column is defined, the new pivoted columns will
   * be named using key values directly. Otherwise, input value column names
   * will be included as a component of the output column names.
   * @param {ExprList} keys Key values to map to new column names.
   *  The keys may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @param {ExprList} values Output values for pivoted columns.
   *  Column references will be wrapped in an *any* aggregate.
   *  If object-valued, the input object should have output value
   *  names for keys and aggregate table expressions for values.
   * @param {PivotOptions} [options] Options for pivoting.
   * @return {this} A new pivoted table.
   * @example table.pivot('key', 'value')
   * @example table.pivot(['keyA', 'keyB'], ['valueA', 'valueB'])
   * @example table.pivot({ key: d => d.key }, { value: d => sum(d.value) })
   */
  pivot(keys, values2, options) {
    return this.__pivot(this, keys, values2, options);
  }
  /**
   * Spread array elements into a set of new columns.
   * Output columns are named based on the value key and array index.
   * @param {ExprList} values The column values to spread.
   *  The values may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @param {SpreadOptions} [options] Options for spreading.
   * @return {this} A new table with the spread columns added.
   * @example table.spread({ a: split(d.text, '') })
   * @example table.spread('arrayCol', { limit: 100 })
   */
  spread(values2, options) {
    return this.__spread(this, values2, options);
  }
  /**
   * Unroll one or more array-valued columns into new rows.
   * If more than one array value is used, the number of new rows
   * is the smaller of the limit and the largest length.
   * Values for all other columns are copied over.
   * @param {ExprList} values The column values to unroll.
   *  The values may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @param {UnrollOptions} [options] Options for unrolling.
   * @return {this} A new unrolled table.
   * @example table.unroll('colA', { limit: 1000 })
   */
  unroll(values2, options) {
    return this.__unroll(this, values2, options);
  }
  // -- Joins ---------------------------------------------------------------
  /**
   * Lookup values from a secondary table and add them as new columns.
   * A lookup occurs upon matching key values for rows in both tables.
   * If the secondary table has multiple rows with the same key, only
   * the last observed instance will be considered in the lookup.
   * Lookup is similar to {@link Transformable#join_left}, but with a simpler
   * syntax and the added constraint of allowing at most one match only.
   * @param {TableRef} other The secondary table to look up values from.
   * @param {JoinKeys} [on] Lookup keys (column name strings or table
   *  expressions) for this table and the secondary table, respectively.
   * @param {...ExprList} values The column values to add from the
   *  secondary table. Can be column name strings or objects with column
   *  names as keys and table expressions as values.
   * @return {this} A new table with lookup values added.
   * @example table.lookup(other, ['key1', 'key2'], 'value1', 'value2')
   */
  lookup(other, on, ...values2) {
    return this.__lookup(this, other, on, values2.flat());
  }
  /**
   * Join two tables, extending the columns of one table with
   * values from the other table. The current table is considered
   * the "left" table in the join, and the new table input is
   * considered the "right" table in the join. By default an inner
   * join is performed, removing all rows that do not match the
   * join criteria. To perform left, right, or full outer joins, use
   * the {@link Transformable#join_left}, {@link Transformable#join_right}, or
   * {@link Transformable#join_full} methods, or provide an options argument.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @param {JoinValues} [values] The columns to include in the join output.
   *  If unspecified, all columns from both tables are included; paired
   *  join keys sharing the same column name are included only once.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join.
   * @return {this} A new joined table.
   * @example table.join(other, ['keyL', 'keyR'])
   * @example table.join(other, (a, b) => equal(a.keyL, b.keyR))
   */
  join(other, on, values2, options) {
    return this.__join(this, other, on, values2, options);
  }
  /**
   * Perform a left outer join on two tables. Rows in the left table
   * that do not match a row in the right table will be preserved.
   * This is a convenience method with fixed options for {@link Transformable#join}.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @param {JoinValues} [values] The columns to include in the join output.
   *  If unspecified, all columns from both tables are included; paired
   *  join keys sharing the same column name are included only once.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join. With this method,
   *  any options will be overridden with {left: true, right: false}.
   * @return {this} A new joined table.
   * @example table.join_left(other, ['keyL', 'keyR'])
   * @example table.join_left(other, (a, b) => equal(a.keyL, b.keyR))
   */
  join_left(other, on, values2, options) {
    const opt2 = { ...options, left: true, right: false };
    return this.__join(this, other, on, values2, opt2);
  }
  /**
   * Perform a right outer join on two tables. Rows in the right table
   * that do not match a row in the left table will be preserved.
   * This is a convenience method with fixed options for {@link Transformable#join}.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @param {JoinValues} [values] The columns to include in the join output.
   *  If unspecified, all columns from both tables are included; paired
   *  join keys sharing the same column name are included only once.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join. With this method,
   *  any options will be overridden with {left: false, right: true}.
   * @return {this} A new joined table.
   * @example table.join_right(other, ['keyL', 'keyR'])
   * @example table.join_right(other, (a, b) => equal(a.keyL, b.keyR))
   */
  join_right(other, on, values2, options) {
    const opt2 = { ...options, left: false, right: true };
    return this.__join(this, other, on, values2, opt2);
  }
  /**
   * Perform a full outer join on two tables. Rows in either the left or
   * right table that do not match a row in the other will be preserved.
   * This is a convenience method with fixed options for {@link Transformable#join}.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @param {JoinValues} [values] The columns to include in the join output.
   *  If unspecified, all columns from both tables are included; paired
   *  join keys sharing the same column name are included only once.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join. With this method,
   *  any options will be overridden with {left: true, right: true}.
   * @return {this} A new joined table.
   * @example table.join_full(other, ['keyL', 'keyR'])
   * @example table.join_full(other, (a, b) => equal(a.keyL, b.keyR))
   */
  join_full(other, on, values2, options) {
    const opt2 = { ...options, left: true, right: true };
    return this.__join(this, other, on, values2, opt2);
  }
  /**
   * Produce the Cartesian cross product of two tables. The output table
   * has one row for every pair of input table rows. Beware that outputs
   * may be quite large, as the number of output rows is the product of
   * the input row counts.
   * This is a convenience method for {@link Transformable#join} in which the
   * join criteria is always true.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinValues} [values] The columns to include in the output.
   *  If unspecified, all columns from both tables are included.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join.
   * @return {this} A new joined table.
   * @example table.cross(other)
   * @example table.cross(other, [['leftKey', 'leftVal'], ['rightVal']])
   */
  cross(other, values2, options) {
    return this.__cross(this, other, values2, options);
  }
  /**
   * Perform a semi-join, filtering the left table to only rows that
   * match a row in the right table.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @return {this} A new filtered table.
   * @example table.semijoin(other)
   * @example table.semijoin(other, ['keyL', 'keyR'])
   * @example table.semijoin(other, (a, b) => equal(a.keyL, b.keyR))
   */
  semijoin(other, on) {
    return this.__semijoin(this, other, on);
  }
  /**
   * Perform an anti-join, filtering the left table to only rows that
   * do *not* match a row in the right table.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @return {this} A new filtered table.
   * @example table.antijoin(other)
   * @example table.antijoin(other, ['keyL', 'keyR'])
   * @example table.antijoin(other, (a, b) => equal(a.keyL, b.keyR))
   */
  antijoin(other, on) {
    return this.__antijoin(this, other, on);
  }
  // -- Set Operations ------------------------------------------------------
  /**
   * Concatenate multiple tables into a single table, preserving all rows.
   * This transformation mirrors the UNION_ALL operation in SQL.
   * Only named columns in this table are included in the output.
   * @see Transformable#union
   * @param  {...TableRef} tables A list of tables to concatenate.
   * @return {this} A new concatenated table.
   * @example table.concat(other)
   * @example table.concat(other1, other2)
   * @example table.concat([other1, other2])
   */
  concat(...tables) {
    return this.__concat(this, tables.flat());
  }
  /**
   * Union multiple tables into a single table, deduplicating all rows.
   * This transformation mirrors the UNION operation in SQL. It is
   * similar to {@link Transformable#concat} but suppresses duplicate rows with
   * values identical to another row.
   * Only named columns in this table are included in the output.
   * @see Transformable#concat
   * @param  {...TableRef} tables A list of tables to union.
   * @return {this} A new unioned table.
   * @example table.union(other)
   * @example table.union(other1, other2)
   * @example table.union([other1, other2])
   */
  union(...tables) {
    return this.__union(this, tables.flat());
  }
  /**
   * Intersect multiple tables, keeping only rows whose with identical
   * values for all columns in all tables, and deduplicates the rows.
   * This transformation is similar to a series of {@link Transformable#semijoin}
   * calls, but additionally suppresses duplicate rows.
   * @see Transformable#semijoin
   * @param  {...TableRef} tables A list of tables to intersect.
   * @return {this} A new filtered table.
   * @example table.intersect(other)
   * @example table.intersect(other1, other2)
   * @example table.intersect([other1, other2])
   */
  intersect(...tables) {
    return this.__intersect(this, tables.flat());
  }
  /**
   * Compute the set difference with multiple tables, keeping only rows in
   * this table that whose values do not occur in the other tables.
   * This transformation is similar to a series of {@link Transformable#antijoin}
   * calls, but additionally suppresses duplicate rows.
   * @see Transformable#antijoin
   * @param  {...TableRef} tables A list of tables to difference.
   * @return {this} A new filtered table.
   * @example table.except(other)
   * @example table.except(other1, other2)
   * @example table.except([other1, other2])
   */
  except(...tables) {
    return this.__except(this, tables.flat());
  }
};

// node_modules/arquero/src/util/error.js
function error_default(message) {
  throw Error(message);
}

// node_modules/arquero/src/util/is-number.js
function is_number_default(value) {
  return typeof value === "number";
}

// node_modules/arquero/src/util/is-function.js
function is_function_default(value) {
  return typeof value === "function";
}

// node_modules/arquero/src/util/repeat.js
function repeat_default(reps, value) {
  const result = Array(reps);
  if (is_function_default(value)) {
    for (let i2 = 0; i2 < reps; ++i2) {
      result[i2] = value(i2);
    }
  } else {
    result.fill(value);
  }
  return result;
}

// node_modules/arquero/src/table/table.js
var Table = class extends Transformable {
  /**
   * Instantiate a new Table instance.
   * @param {string[]} names An ordered list of column names.
   * @param {number} nrows The number of rows.
   * @param {TableData} data The backing data, which can vary by implementation.
   * @param {BitSet} [filter] A bit mask for which rows to include.
   * @param {GroupBySpec} [groups] A groupby specification for grouping ows.
   * @param {RowComparator} [order] A comparator function for sorting rows.
   * @param {Params} [params] Parameter values for table expressions.
   */
  constructor(names2, nrows, data2, filter, groups, order, params) {
    super(params);
    this._names = Object.freeze(names2);
    this._data = data2;
    this._total = nrows;
    this._nrows = filter ? filter.count() : nrows;
    this._mask = nrows !== this._nrows && filter || null;
    this._group = groups || null;
    this._order = order || null;
  }
  /**
   * Create a new table with the same type as this table.
   * The new table may have different data, filter, grouping, or ordering
   * based on the values of the optional configuration argument. If a
   * setting is not specified, it is inherited from the current table.
   * @param {CreateOptions} [options] Creation options for the new table.
   * @return {this} A newly created table.
   */
  create(options) {
    error_default("Not implemented");
  }
  /**
   * Provide an informative object string tag.
   */
  get [Symbol.toStringTag]() {
    if (!this._names)
      return "Object";
    const nr = this.numRows() + " row" + (this.numRows() !== 1 ? "s" : "");
    const nc = this.numCols() + " col" + (this.numCols() !== 1 ? "s" : "");
    return `Table: ${nc} x ${nr}` + (this.isFiltered() ? ` (${this.totalRows()} backing)` : "") + (this.isGrouped() ? `, ${this._group.size} groups` : "") + (this.isOrdered() ? ", ordered" : "");
  }
  /**
   * Indicates if the table has a filter applied.
   * @return {boolean} True if filtered, false otherwise.
   */
  isFiltered() {
    return !!this._mask;
  }
  /**
   * Indicates if the table has a groupby specification.
   * @return {boolean} True if grouped, false otherwise.
   */
  isGrouped() {
    return !!this._group;
  }
  /**
   * Indicates if the table has a row order comparator.
   * @return {boolean} True if ordered, false otherwise.
   */
  isOrdered() {
    return !!this._order;
  }
  /**
   * Returns the internal table storage data structure.
   * @return {TableData} The backing table storage data structure.
   */
  data() {
    return this._data;
  }
  /**
   * Returns the filter bitset mask, if defined.
   * @return {BitSet} The filter bitset mask.
   */
  mask() {
    return this._mask;
  }
  /**
   * Returns the groupby specification, if defined.
   * @return {GroupBySpec} The groupby specification.
   */
  groups() {
    return this._group;
  }
  /**
   * Returns the row order comparator function, if specified.
   * @return {RowComparator} The row order comparator function.
   */
  comparator() {
    return this._order;
  }
  /**
   * The total number of rows in this table, counting both
   * filtered and unfiltered rows.
   * @return {number} The number of total rows.
   */
  totalRows() {
    return this._total;
  }
  /**
   * The number of active rows in this table. This number may be
   * less than the total rows if the table has been filtered.
   * @see Table.totalRows
   * @return {number} The number of rows.
   */
  numRows() {
    return this._nrows;
  }
  /**
   * The number of active rows in this table. This number may be
   * less than the total rows if the table has been filtered.
   * @see Table.totalRows
   * @return {number} The number of rows.
   */
  get size() {
    return this._nrows;
  }
  /**
   * The number of columns in this table.
   * @return {number} The number of columns.
   */
  numCols() {
    return this._names.length;
  }
  /**
   * Filter function invoked for each column name.
   * @callback NameFilter
   * @param {string} name The column name.
   * @param {number} index The column index.
   * @param {string[]} array The array of names.
   * @return {boolean} Returns true to retain the column name.
   */
  /**
   * The table column names, optionally filtered.
   * @param {NameFilter} [filter] An optional filter function.
   *  If unspecified, all column names are returned.
   * @return {string[]} An array of matching column names.
   */
  columnNames(filter) {
    return filter ? this._names.filter(filter) : this._names.slice();
  }
  /**
   * The column name at the given index.
   * @param {number} index The column index.
   * @return {string} The column name,
   *  or undefined if the index is out of range.
   */
  columnName(index) {
    return this._names[index];
  }
  /**
   * The column index for the given name.
   * @param {string} name The column name.
   * @return {number} The column index, or -1 if the name is not found.
   */
  columnIndex(name2) {
    return this._names.indexOf(name2);
  }
  /**
   * Deprecated alias for the table array() method: use table.array()
   * instead. Get an array of values contained in a column. The resulting
   * array respects any table filter or orderby criteria.
   * @param {string} name The column name.
   * @param {ArrayConstructor|TypedArrayConstructor} [constructor=Array]
   *  The array constructor for instantiating the output array.
   * @return {DataValue[]|TypedArray} The array of column values.
   */
  columnArray(name2, constructor) {
    return this.array(name2, constructor);
  }
  /**
   * Get an array of values contained in a column. The resulting array
   * respects any table filter or orderby criteria.
   * @param {string} name The column name.
   * @param {ArrayConstructor|TypedArrayConstructor} [constructor=Array]
   *  The array constructor for instantiating the output array.
   * @return {DataValue[]|TypedArray} The array of column values.
   */
  array(name2, constructor) {
    error_default("Not implemented");
  }
  /**
   * Returns an iterator over column values.
   * @return {Iterator<object>} An iterator over row objects.
   */
  *values(name2) {
    const get2 = this.getter(name2);
    const n2 = this.numRows();
    for (let i2 = 0; i2 < n2; ++i2) {
      yield get2(i2);
    }
  }
  /**
   * Get the value for the given column and row.
   * @param {string} name The column name.
   * @param {number} [row=0] The row index, defaults to zero if not specified.
   * @return {DataValue} The data value at (column, row).
   */
  get(name2, row = 0) {
    error_default("Not implemented");
  }
  /**
   * Returns an accessor ("getter") function for a column. The returned
   * function takes a row index as its single argument and returns the
   * corresponding column value.
   * @param {string} name The column name.
   * @return {ColumnGetter} The column getter function.
   */
  getter(name2) {
    error_default("Not implemented");
  }
  /**
   * Returns an array of objects representing table rows.
   * @param {ObjectsOptions} [options] The options for row object generation.
   * @return {RowObject[]} An array of row objects.
   */
  objects(options) {
    error_default("Not implemented");
  }
  /**
   * Returns an object representing a table row.
   * @param {number} [row=0] The row index, defaults to zero if not specified.
   * @return {object} A row object with named properties for each column.
   */
  object(row) {
    error_default("Not implemented");
  }
  /**
   * Returns an iterator over objects representing table rows.
   * @return {Iterator<object>} An iterator over row objects.
   */
  [Symbol.iterator]() {
    error_default("Not implemented");
  }
  /**
   * Print the contents of this table using the console.table() method.
   * @param {PrintOptions|number} options The options for row object
   *  generation, determining which rows and columns are printed. If
   *  number-valued, specifies the row limit.
   * @return {this} The table instance.
   */
  print(options = {}) {
    if (is_number_default(options)) {
      options = { limit: options };
    } else if (options.limit == null) {
      options.limit = 10;
    }
    const obj = this.objects({ ...options, grouped: false });
    const msg = `${this[Symbol.toStringTag]}. Showing ${obj.length} rows.`;
    console.log(msg);
    console.table(obj);
    return this;
  }
  /**
   * Returns an array of indices for all rows passing the table filter.
   * @param {boolean} [order=true] A flag indicating if the returned
   *  indices should be sorted if this table is ordered. If false, the
   *  returned indices may or may not be sorted.
   * @return {Uint32Array} An array of row indices.
   */
  indices(order = true) {
    if (this._index)
      return this._index;
    const n2 = this.numRows();
    const index = new Uint32Array(n2);
    const ordered = this.isOrdered();
    const bits = this.mask();
    let row = -1;
    if (bits) {
      for (let i2 = bits.next(0); i2 >= 0; i2 = bits.next(i2 + 1)) {
        index[++row] = i2;
      }
    } else {
      for (let i2 = 0; i2 < n2; ++i2) {
        index[++row] = i2;
      }
    }
    if (order && ordered) {
      const compare = this._order;
      const data2 = this._data;
      index.sort((a, b) => compare(a, b, data2));
    }
    if (order || !ordered) {
      this._index = index;
    }
    return index;
  }
  /**
   * Returns an array of indices for each group in the table.
   * If the table is not grouped, the result is the same as
   * {@link indices}, but wrapped within an array.
   * @param {boolean} [order=true] A flag indicating if the returned
   *  indices should be sorted if this table is ordered. If false, the
   *  returned indices may or may not be sorted.
   * @return {number[][]} An array of row index arrays, one per group.
   *  The indices will be filtered if the table is filtered.
   */
  partitions(order = true) {
    if (this._partitions) {
      return this._partitions;
    }
    if (!this.isGrouped()) {
      return [this.indices(order)];
    }
    const { keys, size } = this._group;
    const part = repeat_default(size, () => []);
    const sort = this._index;
    const bits = this.mask();
    const n2 = this.numRows();
    if (sort && this.isOrdered()) {
      for (let i2 = 0, r; i2 < n2; ++i2) {
        r = sort[i2];
        part[keys[r]].push(r);
      }
    } else if (bits) {
      for (let i2 = bits.next(0); i2 >= 0; i2 = bits.next(i2 + 1)) {
        part[keys[i2]].push(i2);
      }
    } else {
      for (let i2 = 0; i2 < n2; ++i2) {
        part[keys[i2]].push(i2);
      }
    }
    if (order && !sort && this.isOrdered()) {
      const compare = this._order;
      const data2 = this._data;
      for (let i2 = 0; i2 < size; ++i2) {
        part[i2].sort((a, b) => compare(a, b, data2));
      }
    }
    if (order || !this.isOrdered()) {
      this._partitions = part;
    }
    return part;
  }
  /**
   * Callback function to cancel a table scan.
   * @callback ScanStop
   * @return {void}
   */
  /**
   * Callback function invoked for each row of a table scan.
   * @callback ScanVisitor
   * @param {number} [row] The table row index.
   * @param {TableData} [data] The backing table data store.
   * @param {ScanStop} [stop] Function to stop the scan early.
   *  Callees can invoke this function to prevent future calls.
   * @return {void}
   */
  /**
   * Perform a table scan, visiting each row of the table.
   * If this table is filtered, only rows passing the filter are visited.
   * @param {ScanVisitor} fn Callback invoked for each row of the table.
   * @param {boolean} [order=false] Indicates if the table should be
   *  scanned in the order determined by {@link Table#orderby}. This
   *  argument has no effect if the table is unordered.
   * @property {number} [limit=Infinity] The maximum number of objects to create.
   * @property {number} [offset=0] The row offset indicating how many initial rows to skip.
   */
  scan(fn, order, limit = Infinity, offset2 = 0) {
    const filter = this._mask;
    const nrows = this._nrows;
    const data2 = this._data;
    let i2 = offset2 || 0;
    if (i2 > nrows)
      return;
    const n2 = Math.min(nrows, i2 + limit);
    const stop2 = () => i2 = this._total;
    if (order && this.isOrdered() || filter && this._index) {
      const index = this.indices();
      const data3 = this._data;
      for (; i2 < n2; ++i2) {
        fn(index[i2], data3, stop2);
      }
    } else if (filter) {
      let c = n2 - i2 + 1;
      for (i2 = filter.nth(i2); --c && i2 > -1; i2 = filter.next(i2 + 1)) {
        fn(i2, data2, stop2);
      }
    } else {
      for (; i2 < n2; ++i2) {
        fn(i2, data2, stop2);
      }
    }
  }
  /**
   * Extract rows with indices from start to end (end not included), where
   * start and end represent per-group ordered row numbers in the table.
   * @param {number} [start] Zero-based index at which to start extraction.
   *  A negative index indicates an offset from the end of the group.
   *  If start is undefined, slice starts from the index 0.
   * @param {number} [end] Zero-based index before which to end extraction.
   *  A negative index indicates an offset from the end of the group.
   *  If end is omitted, slice extracts through the end of the group.
   * @return {this} A new table with sliced rows.
   * @example table.slice(1, -1)
   */
  slice(start = 0, end = Infinity) {
    if (this.isGrouped())
      return super.slice(start, end);
    const indices = [];
    const nrows = this.numRows();
    start = Math.max(0, start + (start < 0 ? nrows : 0));
    end = Math.min(nrows, Math.max(0, end + (end < 0 ? nrows : 0)));
    this.scan((row) => indices.push(row), true, end - start, start);
    return this.reify(indices);
  }
  /**
   * Reduce a table, processing all rows to produce a new table.
   * To produce standard aggregate summaries, use {@link rollup}.
   * This method allows the use of custom reducer implementations,
   * for example to produce multiple rows for an aggregate.
   * @param {Reducer} reducer The reducer to apply.
   * @return {Table} A new table of reducer outputs.
   */
  reduce(reducer) {
    return this.__reduce(this, reducer);
  }
};

// node_modules/arquero/src/table/column.js
var Column = class {
  /**
   * Create a new column instance.
   * @param {Array} data The backing array (or array-like object)
   *  containing the column data.
   */
  constructor(data2) {
    this.data = data2;
  }
  /**
   * Get the length (number of rows) of the column.
   * @return {number} The length of the column array.
   */
  get length() {
    return this.data.length;
  }
  /**
   * Get the column value at the given row index.
   * @param {number} row The row index of the value to retrieve.
   * @return {import('./table').DataValue} The column value.
   */
  get(row) {
    return this.data[row];
  }
  /**
   * Returns an iterator over the column values.
   * @return {Iterator<object>} An iterator over column values.
   */
  [Symbol.iterator]() {
    return this.data[Symbol.iterator]();
  }
};
var defaultColumnFactory = function(data2) {
  return data2 && is_function_default(data2.get) ? data2 : new Column(data2);
};

// node_modules/arquero/src/util/is-date.js
function is_date_default(value) {
  return value instanceof Date;
}

// node_modules/arquero/src/util/is-object.js
function is_object_default(value) {
  return value === Object(value);
}

// node_modules/arquero/src/util/is-regexp.js
function is_regexp_default(value) {
  return value instanceof RegExp;
}

// node_modules/arquero/src/util/is-string.js
function is_string_default(value) {
  return typeof value === "string";
}

// node_modules/arquero/src/table/columns-from.js
function columns_from_default(values2, names2) {
  const raise2 = (type) => error_default(`Illegal argument type: ${type || typeof values2}`);
  return values2 instanceof Map ? fromKeyValuePairs(values2.entries(), names2) : is_date_default(values2) ? raise2("Date") : is_regexp_default(values2) ? raise2("RegExp") : is_string_default(values2) ? raise2() : is_array_default(values2) ? fromArray(values2, names2) : is_function_default(values2[Symbol.iterator]) ? fromIterable(values2, names2) : is_object_default(values2) ? fromKeyValuePairs(Object.entries(values2), names2) : raise2();
}
function fromKeyValuePairs(entries, names2 = ["key", "value"]) {
  const keys = [];
  const vals = [];
  for (const [key2, val] of entries) {
    keys.push(key2);
    vals.push(val);
  }
  const columns2 = {};
  if (names2[0])
    columns2[names2[0]] = keys;
  if (names2[1])
    columns2[names2[1]] = vals;
  return columns2;
}
function fromArray(values2, names2) {
  const len = values2.length;
  const columns2 = {};
  const add = (name2) => columns2[name2] = Array(len);
  if (len) {
    names2 = names2 || Object.keys(values2[0]);
    const cols = names2.map(add);
    const n2 = cols.length;
    for (let idx = 0; idx < len; ++idx) {
      const row = values2[idx];
      for (let i2 = 0; i2 < n2; ++i2) {
        cols[i2][idx] = row[names2[i2]];
      }
    }
  } else if (names2) {
    names2.forEach(add);
  }
  return columns2;
}
function fromIterable(values2, names2) {
  const columns2 = {};
  const add = (name2) => columns2[name2] = [];
  let cols;
  let n2;
  for (const row of values2) {
    if (!cols) {
      names2 = names2 || Object.keys(row);
      cols = names2.map(add);
      n2 = cols.length;
    }
    for (let i2 = 0; i2 < n2; ++i2) {
      cols[i2].push(row[names2[i2]]);
    }
  }
  if (!cols && names2) {
    names2.forEach(add);
  }
  return columns2;
}

// node_modules/arquero/src/util/has.js
var { hasOwnProperty } = Object.prototype;
function has_default(object, property) {
  return hasOwnProperty.call(object, property);
}

// node_modules/arquero/src/table/column-set.js
function column_set_default(table3) {
  return table3 ? new ColumnSet({ ...table3.data() }, table3.columnNames()) : new ColumnSet();
}
var ColumnSet = class {
  constructor(data2, names2) {
    this.data = data2 || {};
    this.names = names2 || [];
  }
  add(name2, values2) {
    if (!this.has(name2))
      this.names.push(name2 + "");
    return this.data[name2] = values2;
  }
  has(name2) {
    return has_default(this.data, name2);
  }
  new() {
    this.filter = null;
    this.groups = this.groups || null;
    this.order = null;
    return this;
  }
  groupby(groups) {
    this.groups = groups;
    return this;
  }
};

// node_modules/arquero/src/util/null.js
var null_default = void 0;

// node_modules/arquero/src/util/is-typed-array.js
var TypedArray = Object.getPrototypeOf(Int8Array);
function is_typed_array_default(value) {
  return value instanceof TypedArray;
}

// node_modules/arquero/src/util/is-array-type.js
function isArrayType(value) {
  return is_array_default(value) || is_typed_array_default(value);
}

// node_modules/arquero/src/util/is-valid.js
function is_valid_default(value) {
  return value != null && value === value;
}

// node_modules/arquero/src/op/functions/array.js
var isSeq = (seq) => isArrayType(seq) || is_string_default(seq);
var array_default = {
  compact: (arr) => isArrayType(arr) ? arr.filter((v) => is_valid_default(v)) : arr,
  concat: (...values2) => [].concat(...values2),
  includes: (seq, value, index) => isSeq(seq) ? seq.includes(value, index) : false,
  indexof: (seq, value) => isSeq(seq) ? seq.indexOf(value) : -1,
  join: (arr, delim) => isArrayType(arr) ? arr.join(delim) : null_default,
  lastindexof: (seq, value) => isSeq(seq) ? seq.lastIndexOf(value) : -1,
  length: (seq) => isSeq(seq) ? seq.length : 0,
  pluck: (arr, prop) => isArrayType(arr) ? arr.map((v) => is_valid_default(v) ? v[prop] : null_default) : null_default,
  reverse: (seq) => isArrayType(seq) ? seq.slice().reverse() : is_string_default(seq) ? seq.split("").reverse().join("") : null_default,
  slice: (seq, start, end) => isSeq(seq) ? seq.slice(start, end) : null_default
};

// node_modules/arquero/src/op/functions/bin.js
function bin_default(value, min, max, step, offset2) {
  return value == null ? null : value < min ? -Infinity : value > max ? Infinity : (value = Math.max(min, Math.min(value, max)), min + step * Math.floor(1e-14 + (value - min) / step + (offset2 || 0)));
}

// node_modules/arquero/src/util/pad.js
function pad_default(value, width, char = "0") {
  const s = value + "";
  const len = s.length;
  return len < width ? Array(width - len + 1).join(char) + s : s;
}

// node_modules/arquero/src/util/format-date.js
var pad2 = (v) => (v < 10 ? "0" : "") + v;
var formatYear = (year) => year < 0 ? "-" + pad_default(-year, 6) : year > 9999 ? "+" + pad_default(year, 6) : pad_default(year, 4);
function formatISO(year, month, date, hours, min, sec, ms, utc, short) {
  const suffix = utc ? "Z" : "";
  return formatYear(year) + "-" + pad2(month + 1) + "-" + pad2(date) + (!short || ms ? "T" + pad2(hours) + ":" + pad2(min) + ":" + pad2(sec) + "." + pad_default(ms, 3) + suffix : sec ? "T" + pad2(hours) + ":" + pad2(min) + ":" + pad2(sec) + suffix : min || hours || !utc ? "T" + pad2(hours) + ":" + pad2(min) + suffix : "");
}
function formatDate(d, short) {
  return isNaN(d) ? "Invalid Date" : formatISO(
    d.getFullYear(),
    d.getMonth(),
    d.getDate(),
    d.getHours(),
    d.getMinutes(),
    d.getSeconds(),
    d.getMilliseconds(),
    false,
    short
  );
}
function formatUTCDate(d, short) {
  return isNaN(d) ? "Invalid Date" : formatISO(
    d.getUTCFullYear(),
    d.getUTCMonth(),
    d.getUTCDate(),
    d.getUTCHours(),
    d.getUTCMinutes(),
    d.getUTCSeconds(),
    d.getUTCMilliseconds(),
    true,
    short
  );
}

// node_modules/arquero/src/util/is-iso-date-string.js
var iso_re = /^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/;
function is_iso_date_string_default(value) {
  return value.match(iso_re) && !isNaN(Date.parse(value));
}

// node_modules/arquero/src/util/parse-iso-date.js
function parse_iso_date_default(value, parse4 = Date.parse) {
  return is_iso_date_string_default(value) ? parse4(value) : value;
}

// node_modules/arquero/src/op/functions/date.js
var msMinute = 6e4;
var msDay = 864e5;
var msWeek = 6048e5;
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
var t = (d) => (t0.setTime(typeof d === "string" ? parse_iso_date_default(d) : d), t0);
function datetime(year, month, date, hours, minutes, seconds, milliseconds) {
  return !arguments.length ? new Date(Date.now()) : new Date(
    year,
    month || 0,
    date == null ? 1 : date,
    hours || 0,
    minutes || 0,
    seconds || 0,
    milliseconds || 0
  );
}
function utcdatetime(year, month, date, hours, minutes, seconds, milliseconds) {
  return !arguments.length ? new Date(Date.now()) : new Date(Date.UTC(
    year,
    month || 0,
    date == null ? 1 : date,
    hours || 0,
    minutes || 0,
    seconds || 0,
    milliseconds || 0
  ));
}
function dayofyear(date) {
  t1.setTime(+date);
  t1.setHours(0, 0, 0, 0);
  t0.setTime(+t1);
  t0.setMonth(0);
  t0.setDate(1);
  const tz = (t1.getTimezoneOffset() - t0.getTimezoneOffset()) * msMinute;
  return Math.floor(1 + (t1 - t0 - tz) / msDay);
}
function utcdayofyear(date) {
  t1.setTime(+date);
  t1.setUTCHours(0, 0, 0, 0);
  const t02 = Date.UTC(t1.getUTCFullYear(), 0, 1);
  return Math.floor(1 + (t1 - t02) / msDay);
}
function week(date, firstday) {
  const i2 = firstday || 0;
  t1.setTime(+date);
  t1.setDate(t1.getDate() - (t1.getDay() + 7 - i2) % 7);
  t1.setHours(0, 0, 0, 0);
  t0.setTime(+date);
  t0.setMonth(0);
  t0.setDate(1);
  t0.setDate(1 - (t0.getDay() + 7 - i2) % 7);
  t0.setHours(0, 0, 0, 0);
  const tz = (t1.getTimezoneOffset() - t0.getTimezoneOffset()) * msMinute;
  return Math.floor((1 + (t1 - t0) - tz) / msWeek);
}
function utcweek(date, firstday) {
  const i2 = firstday || 0;
  t1.setTime(+date);
  t1.setUTCDate(t1.getUTCDate() - (t1.getUTCDay() + 7 - i2) % 7);
  t1.setUTCHours(0, 0, 0, 0);
  t0.setTime(+date);
  t0.setUTCMonth(0);
  t0.setUTCDate(1);
  t0.setUTCDate(1 - (t0.getUTCDay() + 7 - i2) % 7);
  t0.setUTCHours(0, 0, 0, 0);
  return Math.floor((1 + (t1 - t0)) / msWeek);
}
var date_default = {
  format_date: (date, shorten) => formatDate(t(date), !shorten),
  format_utcdate: (date, shorten) => formatUTCDate(t(date), !shorten),
  timestamp: (date) => +t(date),
  year: (date) => t(date).getFullYear(),
  quarter: (date) => Math.floor(t(date).getMonth() / 3),
  month: (date) => t(date).getMonth(),
  date: (date) => t(date).getDate(),
  dayofweek: (date) => t(date).getDay(),
  hours: (date) => t(date).getHours(),
  minutes: (date) => t(date).getMinutes(),
  seconds: (date) => t(date).getSeconds(),
  milliseconds: (date) => t(date).getMilliseconds(),
  utcyear: (date) => t(date).getUTCFullYear(),
  utcquarter: (date) => Math.floor(t(date).getUTCMonth() / 3),
  utcmonth: (date) => t(date).getUTCMonth(),
  utcdate: (date) => t(date).getUTCDate(),
  utcdayofweek: (date) => t(date).getUTCDay(),
  utchours: (date) => t(date).getUTCHours(),
  utcminutes: (date) => t(date).getUTCMinutes(),
  utcseconds: (date) => t(date).getUTCSeconds(),
  utcmilliseconds: (date) => t(date).getUTCMilliseconds(),
  datetime,
  dayofyear,
  week,
  utcdatetime,
  utcdayofyear,
  utcweek,
  now: Date.now
};

// node_modules/arquero/src/op/functions/equal.js
function equal(a, b) {
  return a == null || b == null || a !== a || b !== b ? false : a === b ? true : is_date_default(a) || is_date_default(b) ? +a === +b : is_regexp_default(a) && is_regexp_default(b) ? a + "" === b + "" : is_object_default(a) && is_object_default(b) ? deepEqual(a, b) : false;
}
function deepEqual(a, b) {
  if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {
    return false;
  }
  if (a.length || b.length) {
    return arrayEqual(a, b);
  }
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) {
    return false;
  }
  keysA.sort();
  keysB.sort();
  if (!arrayEqual(keysA, keysB, (a2, b2) => a2 === b2)) {
    return false;
  }
  const n2 = keysA.length;
  for (let i2 = 0; i2 < n2; ++i2) {
    const k = keysA[i2];
    if (!equal(a[k], b[k])) {
      return false;
    }
  }
  return true;
}
function arrayEqual(a, b, test2 = equal) {
  const n2 = a.length;
  if (n2 !== b.length)
    return false;
  for (let i2 = 0; i2 < n2; ++i2) {
    if (!test2(a[i2], b[i2])) {
      return false;
    }
  }
  return true;
}

// node_modules/arquero/src/op/functions/json.js
var json_default = {
  parse_json: (str) => JSON.parse(str),
  to_json: (val) => JSON.stringify(val)
};

// node_modules/arquero/src/util/random.js
var source = Math.random;
function random() {
  return source();
}

// node_modules/arquero/src/op/functions/math.js
var math_default = {
  random,
  is_nan: Number.isNaN,
  is_finite: Number.isFinite,
  abs: Math.abs,
  cbrt: Math.cbrt,
  ceil: Math.ceil,
  clz32: Math.clz32,
  exp: Math.exp,
  expm1: Math.expm1,
  floor: Math.floor,
  fround: Math.fround,
  greatest: Math.max,
  least: Math.min,
  log: Math.log,
  log10: Math.log10,
  log1p: Math.log1p,
  log2: Math.log2,
  pow: Math.pow,
  round: Math.round,
  sign: Math.sign,
  sqrt: Math.sqrt,
  trunc: Math.trunc,
  degrees: (rad) => 180 * rad / Math.PI,
  radians: (deg) => Math.PI * deg / 180,
  acos: Math.acos,
  acosh: Math.acosh,
  asin: Math.asin,
  asinh: Math.asinh,
  atan: Math.atan,
  atan2: Math.atan2,
  atanh: Math.atanh,
  cos: Math.cos,
  cosh: Math.cosh,
  sin: Math.sin,
  sinh: Math.sinh,
  tan: Math.tan,
  tanh: Math.tanh
};

// node_modules/arquero/src/util/is-map.js
function is_map_default(value) {
  return value instanceof Map;
}

// node_modules/arquero/src/util/is-set.js
function is_set_default(value) {
  return value instanceof Set;
}

// node_modules/arquero/src/util/is-map-or-set.js
function is_map_or_set_default(value) {
  return is_map_default(value) || is_set_default(value);
}

// node_modules/arquero/src/op/functions/object.js
function array(iter) {
  return Array.from(iter);
}
var object_default = {
  has: (obj, key2) => is_map_or_set_default(obj) ? obj.has(key2) : obj != null ? has_default(obj, key2) : false,
  keys: (obj) => is_map_default(obj) ? array(obj.keys()) : obj != null ? Object.keys(obj) : [],
  values: (obj) => is_map_or_set_default(obj) ? array(obj.values()) : obj != null ? Object.values(obj) : [],
  entries: (obj) => is_map_or_set_default(obj) ? array(obj.entries()) : obj != null ? Object.entries(obj) : [],
  object: (entries) => entries ? Object.fromEntries(entries) : null_default
};

// node_modules/arquero/src/op/functions/recode.js
function recode_default(value, map, fallback) {
  if (map instanceof Map) {
    if (map.has(value))
      return map.get(value);
  } else if (has_default(map, value)) {
    return map[value];
  }
  return fallback !== void 0 ? fallback : value;
}

// node_modules/arquero/src/op/functions/sequence.js
function sequence_default(start, stop2, step) {
  let n2 = arguments.length;
  start = +start;
  stop2 = +stop2;
  step = n2 < 2 ? (stop2 = start, start = 0, 1) : n2 < 3 ? 1 : +step;
  n2 = Math.max(0, Math.ceil((stop2 - start) / step)) | 0;
  const seq = new Array(n2);
  for (let i2 = 0; i2 < n2; ++i2) {
    seq[i2] = start + i2 * step;
  }
  return seq;
}

// node_modules/arquero/src/op/functions/string.js
var string_default = {
  parse_date: (str) => str == null ? str : new Date(str),
  parse_float: (str) => str == null ? str : Number.parseFloat(str),
  parse_int: (str, radix) => str == null ? str : Number.parseInt(str, radix),
  endswith: (str, search, length) => str == null ? false : String(str).endsWith(search, length),
  match: (str, regexp, index) => {
    const m = str == null ? str : String(str).match(regexp);
    return index == null || m == null ? m : typeof index === "number" ? m[index] : m.groups ? m.groups[index] : null;
  },
  normalize: (str, form) => str == null ? str : String(str).normalize(form),
  padend: (str, len, fill) => str == null ? str : String(str).padEnd(len, fill),
  padstart: (str, len, fill) => str == null ? str : String(str).padStart(len, fill),
  upper: (str) => str == null ? str : String(str).toUpperCase(),
  lower: (str) => str == null ? str : String(str).toLowerCase(),
  repeat: (str, num) => str == null ? str : String(str).repeat(num),
  replace: (str, pattern, replacement) => str == null ? str : String(str).replace(pattern, String(replacement)),
  substring: (str, start, end) => str == null ? str : String(str).substring(start, end),
  split: (str, separator, limit) => str == null ? [] : String(str).split(separator, limit),
  startswith: (str, search, length) => str == null ? false : String(str).startsWith(search, length),
  trim: (str) => str == null ? str : String(str).trim()
};

// node_modules/arquero/src/op/functions/index.js
var functions_default = {
  bin: bin_default,
  equal,
  recode: recode_default,
  sequence: sequence_default,
  ...array_default,
  ...date_default,
  ...json_default,
  ...math_default,
  ...object_default,
  ...string_default
};

// node_modules/arquero/src/util/is-bigint.js
function is_bigint_default(value) {
  return typeof value === "bigint";
}

// node_modules/arquero/src/util/to-string.js
function to_string_default(v) {
  return v === void 0 ? v + "" : is_bigint_default(v) ? v + "n" : JSON.stringify(v);
}

// node_modules/arquero/src/op/op.js
function op_default(name2, fields = [], params = []) {
  return new Op(name2, to_array_default(fields), to_array_default(params));
}
var Op = class {
  constructor(name2, fields, params) {
    this.name = name2;
    this.fields = fields;
    this.params = params;
  }
  toString() {
    const args = [
      ...this.fields.map((f) => `d[${to_string_default(f)}]`),
      ...this.params.map(to_string_default)
    ];
    return `d => op.${this.name}(${args})`;
  }
  toObject() {
    return { expr: this.toString(), func: true };
  }
};

// node_modules/arquero/src/op/op-api.js
var any = (field) => op_default("any", field);
var count = () => op_default("count");
var array_agg = (field) => op_default("array_agg", field);
var array_agg_distinct = (field) => op_default("array_agg_distinct", field);
var map_agg = (key2, value) => op_default("map_agg", [key2, value]);
var object_agg = (key2, value) => op_default("object_agg", [key2, value]);
var entries_agg = (key2, value) => op_default("entries_agg", [key2, value]);
var op_api_default = {
  ...functions_default,
  /**
   * Generate an object representing the current table row.
   * @param {...string} names The column names to include in the object.
   *  If unspecified, all columns are included.
   * @return {Struct} The generated row object.
   */
  row_object: (...names2) => op_default("row_object", null, names2.flat()),
  /**
   * Aggregate function to count the number of records (rows).
   * @returns {number} The count of records.
   */
  count,
  /**
   * Aggregate function returning an arbitrary observed value.
   * @param {*} field The data field.
   * @return {*} An arbitrary observed value.
   */
  any,
  /**
   * Aggregate function to collect an array of values.
   * @param {*} field The data field.
   * @return {Array} A list of values.
   */
  array_agg,
  /**
   * Aggregate function to collect an array of distinct (unique) values.
   * @param {*} field The data field.
   * @return {Array} An array of unique values.
   */
  array_agg_distinct,
  /**
   * Aggregate function to create an object given input key and value fields.
   * @param {*} key The object key field.
   * @param {*} value The object value field.
   * @return {Struct} An object of key-value pairs.
   */
  object_agg,
  /**
   * Aggregate function to create a Map given input key and value fields.
   * @param {*} key The object key field.
   * @param {*} value The object value field.
   * @return {Map} A Map of key-value pairs.
   */
  map_agg,
  /**
   * Aggregate function to create an array in the style of Object.entries()
   * given input key and value fields.
   * @param {*} key The object key field.
   * @param {*} value The object value field.
   * @return {[[any, any]]} An array of [key, value] arrays.
   */
  entries_agg,
  /**
   * Aggregate function to count the number of valid values.
   * Invalid values are null, undefined, or NaN.
   * @param {*} field The data field.
   * @return {number} The count of valid values.
   */
  valid: (field) => op_default("valid", field),
  /**
   * Aggregate function to count the number of invalid values.
   * Invalid values are null, undefined, or NaN.
   * @param {*} field The data field.
   * @return {number} The count of invalid values.
   */
  invalid: (field) => op_default("invalid", field),
  /**
   * Aggregate function to count the number of distinct values.
   * @param {*} field The data field.
   * @return {number} The count of distinct values.
   */
  distinct: (field) => op_default("distinct", field),
  /**
   * Aggregate function to determine the mode (most frequent) value.
   * @param {*} field The data field.
   * @return {number} The mode value.
   */
  mode: (field) => op_default("mode", field),
  /**
   * Aggregate function to sum values.
   * @param {string} field The data field.
   * @return {number} The sum of the values.
   */
  sum: (field) => op_default("sum", field),
  /**
   * Aggregate function to multiply values.
   * @param {*} field The data field.
   * @return {number} The product of the values.
   */
  product: (field) => op_default("product", field),
  /**
   * Aggregate function for the mean (average) value.
   * @param {*} field The data field.
   * @return {number} The mean (average) of the values.
   */
  mean: (field) => op_default("mean", field),
  /**
   * Aggregate function for the average (mean) value.
   * @param {*} field The data field.
   * @return {number} The average (mean) of the values.
   */
  average: (field) => op_default("average", field),
  /**
   * Aggregate function for the sample variance.
   * @param {*} field The data field.
   * @return {number} The sample variance of the values.
   */
  variance: (field) => op_default("variance", field),
  /**
   * Aggregate function for the population variance.
   * @param {*} field The data field.
   * @return {number} The population variance of the values.
   */
  variancep: (field) => op_default("variancep", field),
  /**
   * Aggregate function for the sample standard deviation.
   * @param {*} field The data field.
   * @return {number} The sample standard deviation of the values.
   */
  stdev: (field) => op_default("stdev", field),
  /**
   * Aggregate function for the population standard deviation.
   * @param {*} field The data field.
   * @return {number} The population standard deviation of the values.
   */
  stdevp: (field) => op_default("stdevp", field),
  /**
   * Aggregate function for the minimum value.
   * @param {*} field The data field.
   * @return {number} The minimum value.
   */
  min: (field) => op_default("min", field),
  /**
   * Aggregate function for the maximum value.
   * @param {*} field The data field.
   * @return {number} The maximum value.
   */
  max: (field) => op_default("max", field),
  /**
   * Aggregate function to compute the quantile boundary
   * of a data field for a probability threshold.
   * @param {*} field The data field.
   * @param {number} p The probability threshold.
   * @return {number} The quantile value.
   */
  quantile: (field, p) => op_default("quantile", field, p),
  /**
   * Aggregate function for the median value.
   * This is a shorthand for the 0.5 quantile value.
   * @param {*} field The data field.
   * @return {number} The median value.
   */
  median: (field) => op_default("median", field),
  /**
   * Aggregate function for the sample covariance between two variables.
   * @param {*} field1 The first data field.
   * @param {*} field2 The second data field.
   * @return {number} The sample covariance of the values.
   */
  covariance: (field1, field2) => op_default("covariance", [field1, field2]),
  /**
   * Aggregate function for the population covariance between two variables.
   * @param {*} field1 The first data field.
   * @param {*} field2 The second data field.
   * @return {number} The population covariance of the values.
   */
  covariancep: (field1, field2) => op_default("covariancep", [field1, field2]),
  /**
   * Aggregate function for the product-moment correlation between two variables.
   * To instead compute a rank correlation, compute the average ranks for each
   * variable and then apply this function to the result.
   * @param {*} field1 The first data field.
   * @param {*} field2 The second data field.
   * @return {number} The correlation between the field values.
   */
  corr: (field1, field2) => op_default("corr", [field1, field2]),
  /**
   * Aggregate function for calculating a binning scheme in terms of
   * the minimum bin boundary, maximum bin boundary, and step size.
   * @param {*} field The data field.
   * @param {number} [maxbins=15] The maximum number of allowed bins.
   * @param {boolean} [nice=true] Flag indicating if the bin min and max
   *  should snap to "nice" human-friendly values.
   * @param {number} [minstep] The minimum allowed step size between bins.
   * @param {number} [step] The exact step size to use between bins.
   *  If specified, the maxbins and minstep arguments are ignored.
   * @return {[number, number, number]} The bin [min, max, and step] values.
   */
  bins: (field, maxbins, nice, minstep) => op_default("bins", field, [maxbins, nice, minstep]),
  /**
   * Window function to assign consecutive row numbers, starting from 1.
   * @return {number} The row number value.
   */
  row_number: () => op_default("row_number"),
  /**
   * Window function to assign a rank to each value in a group, starting
   * from 1. Peer values are assigned the same rank. Subsequent ranks
   * reflect the number of prior values: if the first two values tie for
   * rank 1, the third value is assigned rank 3.
   * @return {number} The rank value.
   */
  rank: () => op_default("rank"),
  /**
   * Window function to assign a fractional (average) rank to each value in
   * a group, starting from 1. Peer values are assigned the average of their
   * indices: if the first two values tie, both will be assigned rank 1.5.
   * @return {number} The peer-averaged rank value.
   */
  avg_rank: () => op_default("avg_rank"),
  /**
   * Window function to assign a dense rank to each value in a group,
   * starting from 1. Peer values are assigned the same rank. Subsequent
   * ranks do not reflect the number of prior values: if the first two
   * values tie for rank 1, the third value is assigned rank 2.
   * @return {number} The dense rank value.
   */
  dense_rank: () => op_default("dense_rank"),
  /**
   * Window function to assign a percentage rank to each value in a group.
   * The percent is calculated as (rank - 1) / (group_size - 1).
   * @return {number} The percentage rank value.
   */
  percent_rank: () => op_default("percent_rank"),
  /**
   * Window function to assign a cumulative distribution value between 0 and 1
   * to each value in a group.
   * @return {number} The cumulative distribution value.
   */
  cume_dist: () => op_default("cume_dist"),
  /**
   * Window function to assign a quantile (e.g., percentile) value to each
   * value in a group. Accepts an integer parameter indicating the number of
   * buckets to use (e.g., 100 for percentiles, 5 for quintiles).
   * @param {number} num The number of buckets for ntile calculation.
   * @return {number} The quantile value.
   */
  ntile: (num) => op_default("ntile", null, num),
  /**
   * Window function to assign a value that precedes the current value by
   * a specified number of positions. If no such value exists, returns a
   * default value instead.
   * @param {*} field The data field.
   * @param {number} [offset=1] The lag offset from the current value.
   * @param {*} [defaultValue=undefined] The default value.
   * @return {*} The lagging value.
   */
  lag: (field, offset2, defaultValue) => op_default("lag", field, [offset2, defaultValue]),
  /**
   * Window function to assign a value that follows the current value by
   * a specified number of positions. If no such value exists, returns a
   * default value instead.
   * @param {*} field The data field.
   * @param {number} [offset=1] The lead offset from the current value.
   * @param {*} [defaultValue=undefined] The default value.
   * @return {*} The leading value.
   */
  lead: (field, offset2, defaultValue) => op_default("lead", field, [offset2, defaultValue]),
  /**
   * Window function to assign the first value in a sliding window frame.
   * @param {*} field The data field.
   * @return {*} The first value in the current frame.
   */
  first_value: (field) => op_default("first_value", field),
  /**
   * Window function to assign the last value in a sliding window frame.
   * @param {*} field The data field.
   * @return {*} The last value in the current frame.
   */
  last_value: (field) => op_default("last_value", field),
  /**
   * Window function to assign the nth value in a sliding window frame
   * (counting from 1), or undefined if no such value exists.
   * @param {*} field The data field.
   * @param {number} nth The nth position, starting from 1.
   * @return {*} The nth value in the current frame.
   */
  nth_value: (field, nth) => op_default("nth_value", field, nth),
  /**
   * Window function to fill in missing values with preceding values.
   * @param {*} field The data field.
   * @param {*} [defaultValue=undefined] The default value.
   * @return {*} The current value if valid, otherwise the first preceding
   *  valid value. If no such value exists, returns the default value.
   */
  fill_down: (field, defaultValue) => op_default("fill_down", field, defaultValue),
  /**
   * Window function to fill in missing values with subsequent values.
   * @param {*} field The data field.
   * @param {*} [defaultValue=undefined] The default value.
   * @return {*} The current value if valid, otherwise the first subsequent
   *  valid value. If no such value exists, returns the default value.
   */
  fill_up: (field, defaultValue) => op_default("fill_up", field, defaultValue)
};

// node_modules/arquero/src/util/unique-name.js
function unique_name_default(names2, name2) {
  names2 = is_map_or_set_default(names2) ? names2 : new Set(names2);
  let uname = name2;
  let index = 0;
  while (names2.has(uname)) {
    uname = name2 + ++index;
  }
  return uname;
}

// node_modules/arquero/src/table/regroup.js
function regroup(groups, filter) {
  if (!groups || !filter)
    return groups;
  const { keys, rows, size } = groups;
  const map = new Int32Array(size);
  filter.scan((row) => map[keys[row]] = 1);
  const sum2 = map.reduce((sum3, val) => sum3 + val, 0);
  if (sum2 === size)
    return groups;
  const _rows = Array(sum2);
  let _size = 0;
  for (let i2 = 0; i2 < size; ++i2) {
    if (map[i2])
      _rows[map[i2] = _size++] = rows[i2];
  }
  const _keys = new Uint32Array(keys.length);
  filter.scan((row) => _keys[row] = map[keys[row]]);
  return { ...groups, keys: _keys, rows: _rows, size: _size };
}
function reindex(groups, scan2, filter, nrows) {
  const { keys, rows, size } = groups;
  let _rows = rows;
  let _size = size;
  let map = null;
  if (filter) {
    map = new Int32Array(size);
    scan2((row) => map[keys[row]] = 1);
    const sum2 = map.reduce((sum3, val) => sum3 + val, 0);
    if (sum2 !== size) {
      _rows = Array(sum2);
      _size = 0;
      for (let i2 = 0; i2 < size; ++i2) {
        if (map[i2])
          _rows[map[i2] = _size++] = rows[i2];
      }
    }
  }
  let r = -1;
  const _keys = new Uint32Array(nrows);
  const fn = _size !== size ? (row) => _keys[++r] = map[keys[row]] : (row) => _keys[++r] = keys[row];
  scan2(fn);
  return { ...groups, keys: _keys, rows: _rows, size: _size };
}
function nest(table3, idx, obj, type) {
  const agg2 = type === "map" || type === true ? map_agg : type === "entries" ? entries_agg : type === "object" ? object_agg : error_default('groups option must be "map", "entries", or "object".');
  const { names: names2 } = table3.groups();
  const col = unique_name_default(table3.columnNames(), "_");
  let t2 = table3.select().reify(idx).create({ data: { [col]: obj } }).rollup({ [col]: array_agg(col) });
  for (let i2 = names2.length; --i2 >= 0; ) {
    t2 = t2.groupby(names2.slice(0, i2)).rollup({ [col]: agg2(names2[i2], col) });
  }
  return t2.get(col);
}

// node_modules/arquero/src/expression/ast/constants.js
var ArrayPattern = "ArrayPattern";
var ArrowFunctionExpression = "ArrowFunctionExpression";
var FunctionExpression = "FunctionExpression";
var Identifier = "Identifier";
var Literal = "Literal";
var MemberExpression = "MemberExpression";
var ObjectExpression = "ObjectExpression";
var ObjectPattern = "ObjectPattern";
var Property = "Property";
var Column2 = "Column";
var Constant = "Constant";
var Dictionary = "Dictionary";
var Function2 = "Function";
var Parameter = "Parameter";
var Op2 = "Op";

// node_modules/arquero/src/expression/codegen.js
var visit = (node, opt2) => {
  const f = visitors[node.type];
  return f ? f(node, opt2) : error_default(`Unsupported expression construct: ${node.type}`);
};
var binary = (node, opt2) => {
  return "(" + visit(node.left, opt2) + " " + node.operator + " " + visit(node.right, opt2) + ")";
};
var func = (node, opt2) => {
  return "(" + list(node.params, opt2) + ")=>" + visit(node.body, opt2);
};
var call = (node, opt2) => {
  return visit(node.callee, opt2) + "(" + list(node.arguments, opt2) + ")";
};
var list = (array3, opt2, delim = ",") => {
  return array3.map((node) => visit(node, opt2)).join(delim);
};
var name = (node) => node.computed ? `[${to_string_default(node.name)}]` : `.${node.name}`;
var ref = (node, opt2, method) => {
  const table3 = node.table || "";
  return `data${table3}${name(node)}.${method}(${opt2.index}${table3})`;
};
var visitors = {
  Constant: (node) => node.raw,
  Column: (node, opt2) => ref(node, opt2, "get"),
  Dictionary: (node, opt2) => ref(node, opt2, "key"),
  Function: (node) => `fn.${node.name}`,
  Parameter: (node) => `$${name(node)}`,
  Op: (node, opt2) => `op(${to_string_default(node.name)},${opt2.op || opt2.index})`,
  Literal: (node) => node.raw,
  Identifier: (node) => node.name,
  TemplateLiteral: (node, opt2) => {
    const { quasis, expressions } = node;
    const n2 = expressions.length;
    let t2 = quasis[0].value.raw;
    for (let i2 = 0; i2 < n2; ) {
      t2 += "${" + visit(expressions[i2], opt2) + "}" + quasis[++i2].value.raw;
    }
    return "`" + t2 + "`";
  },
  MemberExpression: (node, opt2) => {
    const d = !node.computed;
    const o = visit(node.object, opt2);
    const p = visit(node.property, opt2);
    return o + (d ? "." + p : "[" + p + "]");
  },
  CallExpression: call,
  NewExpression: (node, opt2) => {
    return "new " + call(node, opt2);
  },
  ArrayExpression: (node, opt2) => {
    return "[" + list(node.elements, opt2) + "]";
  },
  AssignmentExpression: binary,
  BinaryExpression: binary,
  LogicalExpression: binary,
  UnaryExpression: (node, opt2) => {
    return "(" + node.operator + visit(node.argument, opt2) + ")";
  },
  ConditionalExpression: (node, opt2) => {
    return "(" + visit(node.test, opt2) + "?" + visit(node.consequent, opt2) + ":" + visit(node.alternate, opt2) + ")";
  },
  ObjectExpression: (node, opt2) => {
    return "({" + list(node.properties, opt2) + "})";
  },
  Property: (node, opt2) => {
    const key2 = visit(node.key, opt2);
    return (node.computed ? `[${key2}]` : key2) + ":" + visit(node.value, opt2);
  },
  ArrowFunctionExpression: func,
  FunctionExpression: func,
  FunctionDeclaration: func,
  ArrayPattern: (node, opt2) => {
    return "[" + list(node.elements, opt2) + "]";
  },
  ObjectPattern: (node, opt2) => {
    return "{" + list(node.properties, opt2) + "}";
  },
  VariableDeclaration: (node, opt2) => {
    return node.kind + " " + list(node.declarations, opt2, ",");
  },
  VariableDeclarator: (node, opt2) => {
    return visit(node.id, opt2) + "=" + visit(node.init, opt2);
  },
  SpreadElement: (node, opt2) => {
    return "..." + visit(node.argument, opt2);
  },
  BlockStatement: (node, opt2) => {
    return "{" + list(node.body, opt2, ";") + ";}";
  },
  BreakStatement: () => {
    return "break";
  },
  ExpressionStatement: (node, opt2) => {
    return visit(node.expression, opt2);
  },
  IfStatement: (node, opt2) => {
    return "if (" + visit(node.test, opt2) + ")" + visit(node.consequent, opt2) + (node.alternate ? " else " + visit(node.alternate, opt2) : "");
  },
  SwitchStatement: (node, opt2) => {
    return "switch (" + visit(node.discriminant, opt2) + ") {" + list(node.cases, opt2, "") + "}";
  },
  SwitchCase: (node, opt2) => {
    return (node.test ? "case " + visit(node.test, opt2) : "default") + ": " + list(node.consequent, opt2, ";") + ";";
  },
  ReturnStatement: (node, opt2) => {
    return "return " + visit(node.argument, opt2);
  },
  Program: (node, opt2) => visit(node.body[0], opt2)
};
function codegen_default(node, opt2 = { index: "row" }) {
  return visit(node, opt2);
}

// node_modules/arquero/src/util/bins.js
function bins_default(min, max, maxbins = 15, nice = true, minstep = 0, step) {
  const base = 10;
  const logb = Math.LN10;
  if (step == null) {
    const level = Math.ceil(Math.log(maxbins) / logb);
    const span = max - min || Math.abs(min) || 1;
    const div = [5, 2];
    step = Math.max(
      minstep,
      Math.pow(base, Math.round(Math.log(span) / logb) - level)
    );
    while (Math.ceil(span / step) > maxbins) {
      step *= base;
    }
    const n2 = div.length;
    for (let i2 = 0; i2 < n2; ++i2) {
      const v = step / div[i2];
      if (v >= minstep && span / v <= maxbins) {
        step = v;
      }
    }
  }
  if (nice) {
    let v = Math.log(step);
    const precision = v >= 0 ? 0 : ~~(-v / logb) + 1;
    const eps = Math.pow(base, -precision - 1);
    v = Math.floor(min / step + eps) * step;
    min = min < v ? v - step : v;
    max = Math.ceil(max / step) * step;
  }
  return [
    min,
    max === min ? min + step : max,
    step
  ];
}

// node_modules/arquero/src/util/key-function.js
function key(value) {
  const type = typeof value;
  return type === "string" ? `"${value}"` : type !== "object" || !value ? value : is_date_default(value) ? +value : is_array_default(value) || is_typed_array_default(value) ? `[${value.map(key)}]` : is_regexp_default(value) ? value + "" : objectKey(value);
}
function objectKey(value) {
  let s = "{";
  let i2 = -1;
  for (const k in value) {
    if (++i2 > 0)
      s += ",";
    s += `"${k}":${key(value[k])}`;
  }
  s += "}";
  return s;
}
function key_function_default(get2, nulls) {
  const n2 = get2.length;
  return n2 === 1 ? (row, data2) => key(get2[0](row, data2)) : (row, data2) => {
    let s = "";
    for (let i2 = 0; i2 < n2; ++i2) {
      if (i2 > 0)
        s += "|";
      const v = get2[i2](row, data2);
      if (nulls && (v == null || v !== v))
        return null;
      s += key(v);
    }
    return s;
  };
}

// node_modules/arquero/src/util/distinct-map.js
function distinct_map_default() {
  const map = /* @__PURE__ */ new Map();
  return {
    count() {
      return map.size;
    },
    values() {
      return Array.from(map.values(), (_) => _.v);
    },
    increment(v) {
      const k = key(v);
      const e = map.get(k);
      e ? ++e.n : map.set(k, { v, n: 1 });
    },
    decrement(v) {
      const k = key(v);
      const e = map.get(k);
      e.n === 1 ? map.delete(k) : --e.n;
    },
    forEach(fn) {
      map.forEach(({ v, n: n2 }) => fn(v, n2));
    }
  };
}

// node_modules/arquero/src/util/no-op.js
function no_op_default() {
}

// node_modules/arquero/src/util/product.js
function product_default(values2, start = 0, stop2 = values2.length) {
  let prod = values2[start++];
  for (let i2 = start; i2 < stop2; ++i2) {
    prod *= values2[i2];
  }
  return prod;
}

// node_modules/arquero/src/op/aggregate-functions.js
function initOp(op) {
  op.init = op.init || no_op_default;
  op.add = op.add || no_op_default;
  op.rem = op.rem || no_op_default;
  return op;
}
function initProduct(s, value) {
  s.product_v = false;
  return s.product = value;
}
var aggregate_functions_default = {
  /** @type {AggregateDef} */
  count: {
    create: () => initOp({
      value: (s) => s.count
    }),
    param: []
  },
  /** @type {AggregateDef} */
  array_agg: {
    create: () => initOp({
      init: (s) => s.values = true,
      value: (s) => s.list.values(s.stream)
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  object_agg: {
    create: () => initOp({
      init: (s) => s.values = true,
      value: (s) => Object.fromEntries(s.list.values())
    }),
    param: [2]
  },
  /** @type {AggregateDef} */
  map_agg: {
    create: () => initOp({
      init: (s) => s.values = true,
      value: (s) => new Map(s.list.values())
    }),
    param: [2]
  },
  /** @type {AggregateDef} */
  entries_agg: {
    create: () => initOp({
      init: (s) => s.values = true,
      value: (s) => s.list.values(s.stream)
    }),
    param: [2]
  },
  /** @type {AggregateDef} */
  any: {
    create: () => initOp({
      add: (s, v) => {
        if (s.any == null)
          s.any = v;
      },
      value: (s) => s.valid ? s.any : null_default
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  valid: {
    create: () => initOp({
      value: (s) => s.valid
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  invalid: {
    create: () => initOp({
      value: (s) => s.count - s.valid
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  distinct: {
    create: () => ({
      init: (s) => s.distinct = distinct_map_default(),
      value: (s) => s.distinct.count() + (s.valid === s.count ? 0 : 1),
      add: (s, v) => s.distinct.increment(v),
      rem: (s, v) => s.distinct.decrement(v)
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  array_agg_distinct: {
    create: () => initOp({
      value: (s) => s.distinct.values()
    }),
    param: [1],
    req: ["distinct"]
  },
  /** @type {AggregateDef} */
  mode: {
    create: () => initOp({
      value: (s) => {
        let mode = null_default;
        let max = 0;
        s.distinct.forEach((value, count2) => {
          if (count2 > max) {
            max = count2;
            mode = value;
          }
        });
        return mode;
      }
    }),
    param: [1],
    req: ["distinct"]
  },
  /** @type {AggregateDef} */
  sum: {
    create: () => ({
      init: (s) => s.sum = 0,
      value: (s) => s.valid ? s.sum : null_default,
      add: (s, v) => is_bigint_default(v) ? s.sum === 0 ? s.sum = v : s.sum += v : s.sum += +v,
      rem: (s, v) => s.sum -= v
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  product: {
    create: () => ({
      init: (s) => initProduct(s, 1),
      value: (s) => s.valid ? s.product_v ? initProduct(s, product_default(s.list.values())) : s.product : void 0,
      add: (s, v) => is_bigint_default(v) ? s.product === 1 ? s.product = v : s.product *= v : s.product *= v,
      rem: (s, v) => v == 0 || v === Infinity || v === -Infinity ? s.product_v = true : s.product /= v
    }),
    param: [1],
    stream: ["array_agg"]
  },
  /** @type {AggregateDef} */
  mean: {
    create: () => ({
      init: (s) => s.mean = 0,
      value: (s) => s.valid ? s.mean : null_default,
      add: (s, v) => {
        s.mean_d = v - s.mean;
        s.mean += s.mean_d / s.valid;
      },
      rem: (s, v) => {
        s.mean_d = v - s.mean;
        s.mean -= s.valid ? s.mean_d / s.valid : s.mean;
      }
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  average: {
    create: () => initOp({
      value: (s) => s.valid ? s.mean : null_default
    }),
    param: [1],
    req: ["mean"]
  },
  /** @type {AggregateDef} */
  variance: {
    create: () => ({
      init: (s) => s.dev = 0,
      value: (s) => s.valid > 1 ? s.dev / (s.valid - 1) : null_default,
      add: (s, v) => s.dev += s.mean_d * (v - s.mean),
      rem: (s, v) => s.dev -= s.mean_d * (v - s.mean)
    }),
    param: [1],
    req: ["mean"]
  },
  /** @type {AggregateDef} */
  variancep: {
    create: () => initOp({
      value: (s) => s.valid > 1 ? s.dev / s.valid : null_default
    }),
    param: [1],
    req: ["variance"]
  },
  /** @type {AggregateDef} */
  stdev: {
    create: () => initOp({
      value: (s) => s.valid > 1 ? Math.sqrt(s.dev / (s.valid - 1)) : null_default
    }),
    param: [1],
    req: ["variance"]
  },
  /** @type {AggregateDef} */
  stdevp: {
    create: () => initOp({
      value: (s) => s.valid > 1 ? Math.sqrt(s.dev / s.valid) : null_default
    }),
    param: [1],
    req: ["variance"]
  },
  /** @type {AggregateDef} */
  min: {
    create: () => ({
      init: (s) => s.min = null_default,
      value: (s) => s.min = Number.isNaN(s.min) ? s.list.min() : s.min,
      add: (s, v) => {
        if (v < s.min || s.min === null_default)
          s.min = v;
      },
      rem: (s, v) => {
        if (v <= s.min)
          s.min = NaN;
      }
    }),
    param: [1],
    stream: ["array_agg"]
  },
  /** @type {AggregateDef} */
  max: {
    create: () => ({
      init: (s) => s.max = null_default,
      value: (s) => s.max = Number.isNaN(s.max) ? s.list.max() : s.max,
      add: (s, v) => {
        if (v > s.max || s.max === null_default)
          s.max = v;
      },
      rem: (s, v) => {
        if (v >= s.max)
          s.max = NaN;
      }
    }),
    param: [1],
    stream: ["array_agg"]
  },
  /** @type {AggregateDef} */
  quantile: {
    create: (p) => initOp({
      value: (s) => s.list.quantile(p)
    }),
    param: [1, 1],
    req: ["array_agg"]
  },
  /** @type {AggregateDef} */
  median: {
    create: () => initOp({
      value: (s) => s.list.quantile(0.5)
    }),
    param: [1],
    req: ["array_agg"]
  },
  /** @type {AggregateDef} */
  covariance: {
    create: () => ({
      init: (s) => {
        s.cov = s.mean_x = s.mean_y = s.dev_x = s.dev_y = 0;
      },
      value: (s) => s.valid > 1 ? s.cov / (s.valid - 1) : null_default,
      add: (s, x, y) => {
        const dx = x - s.mean_x;
        const dy = y - s.mean_y;
        s.mean_x += dx / s.valid;
        s.mean_y += dy / s.valid;
        const dy2 = y - s.mean_y;
        s.dev_x += dx * (x - s.mean_x);
        s.dev_y += dy * dy2;
        s.cov += dx * dy2;
      },
      rem: (s, x, y) => {
        const dx = x - s.mean_x;
        const dy = y - s.mean_y;
        s.mean_x -= s.valid ? dx / s.valid : s.mean_x;
        s.mean_y -= s.valid ? dy / s.valid : s.mean_y;
        const dy2 = y - s.mean_y;
        s.dev_x -= dx * (x - s.mean_x);
        s.dev_y -= dy * dy2;
        s.cov -= dx * dy2;
      }
    }),
    param: [2]
  },
  /** @type {AggregateDef} */
  covariancep: {
    create: () => initOp({
      value: (s) => s.valid > 1 ? s.cov / s.valid : null_default
    }),
    param: [2],
    req: ["covariance"]
  },
  /** @type {AggregateDef} */
  corr: {
    create: () => initOp({
      value: (s) => s.valid > 1 ? s.cov / (Math.sqrt(s.dev_x) * Math.sqrt(s.dev_y)) : null_default
    }),
    param: [2],
    req: ["covariance"]
  },
  /** @type {AggregateDef} */
  bins: {
    create: (maxbins, nice, minstep, step) => initOp({
      value: (s) => bins_default(s.min, s.max, maxbins, nice, minstep, step)
    }),
    param: [1, 4],
    req: ["min", "max"]
  }
};

// node_modules/arquero/src/op/window-functions.js
var rank = {
  create() {
    let rank2;
    return {
      init: () => rank2 = 1,
      value: (w) => {
        const i2 = w.index;
        return i2 && !w.peer(i2) ? rank2 = i2 + 1 : rank2;
      }
    };
  },
  param: []
};
var cume_dist = {
  create() {
    let cume;
    return {
      init: () => cume = 0,
      value: (w) => {
        const { index, peer, size } = w;
        let i2 = index;
        if (cume < i2) {
          while (i2 + 1 < size && peer(i2 + 1))
            ++i2;
          cume = i2;
        }
        return (1 + cume) / size;
      }
    };
  },
  param: []
};
var window_functions_default = {
  /** @type {WindowDef} */
  row_number: {
    create() {
      return {
        init: no_op_default,
        value: (w) => w.index + 1
      };
    },
    param: []
  },
  /** @type {WindowDef} */
  rank,
  /** @type {WindowDef} */
  avg_rank: {
    create() {
      let j, rank2;
      return {
        init: () => (j = -1, rank2 = 1),
        value: (w) => {
          const i2 = w.index;
          if (i2 >= j) {
            for (rank2 = j = i2 + 1; w.peer(j); rank2 += ++j)
              ;
            rank2 /= j - i2;
          }
          return rank2;
        }
      };
    },
    param: []
  },
  /** @type {WindowDef} */
  dense_rank: {
    create() {
      let drank;
      return {
        init: () => drank = 1,
        value: (w) => {
          const i2 = w.index;
          return i2 && !w.peer(i2) ? ++drank : drank;
        }
      };
    },
    param: []
  },
  /** @type {WindowDef} */
  percent_rank: {
    create() {
      const { init: init2, value } = rank.create();
      return {
        init: init2,
        value: (w) => (value(w) - 1) / (w.size - 1)
      };
    },
    param: []
  },
  /** @type {WindowDef} */
  cume_dist,
  /** @type {WindowDef} */
  ntile: {
    create(num) {
      num = +num;
      if (!(num > 0))
        error_default("ntile num must be greater than zero.");
      const { init: init2, value } = cume_dist.create();
      return {
        init: init2,
        value: (w) => Math.ceil(num * value(w))
      };
    },
    param: [0, 1]
  },
  /** @type {WindowDef} */
  lag: {
    create(offset2, defaultValue = null_default) {
      offset2 = +offset2 || 1;
      return {
        init: no_op_default,
        value: (w, f) => {
          const i2 = w.index - offset2;
          return i2 >= 0 ? w.value(i2, f) : defaultValue;
        }
      };
    },
    param: [1, 2]
  },
  /** @type {WindowDef} */
  lead: {
    create(offset2, defaultValue = null_default) {
      offset2 = +offset2 || 1;
      return {
        init: no_op_default,
        value: (w, f) => {
          const i2 = w.index + offset2;
          return i2 < w.size ? w.value(i2, f) : defaultValue;
        }
      };
    },
    param: [1, 2]
  },
  /** @type {WindowDef} */
  first_value: {
    create() {
      return {
        init: no_op_default,
        value: (w, f) => w.value(w.i0, f)
      };
    },
    param: [1]
  },
  /** @type {WindowDef} */
  last_value: {
    create() {
      return {
        init: no_op_default,
        value: (w, f) => w.value(w.i1 - 1, f)
      };
    },
    param: [1]
  },
  /** @type {WindowDef} */
  nth_value: {
    create(nth) {
      nth = +nth;
      if (!(nth > 0))
        error_default("nth_value nth must be greater than zero.");
      return {
        init: no_op_default,
        value: (w, f) => {
          const i2 = w.i0 + (nth - 1);
          return i2 < w.i1 ? w.value(i2, f) : null_default;
        }
      };
    },
    param: [1, 1]
  },
  /** @type {WindowDef} */
  fill_down: {
    create(defaultValue = null_default) {
      let value;
      return {
        init: () => value = defaultValue,
        value: (w, f) => {
          const v = w.value(w.index, f);
          return is_valid_default(v) ? value = v : value;
        }
      };
    },
    param: [1, 1]
  },
  /** @type {WindowDef} */
  fill_up: {
    create(defaultValue = null_default) {
      let value, idx;
      return {
        init: () => (value = defaultValue, idx = -1),
        value: (w, f) => w.index <= idx ? value : (idx = find(w, f, w.index)) >= 0 ? value = w.value(idx, f) : (idx = w.size, value = defaultValue)
      };
    },
    param: [1, 1]
  }
};
function find(w, f, i2) {
  for (const n2 = w.size; i2 < n2; ++i2) {
    if (is_valid_default(w.value(i2, f)))
      return i2;
  }
  return -1;
}

// node_modules/arquero/src/op/index.js
function hasAggregate(name2) {
  return has_default(aggregate_functions_default, name2);
}
function hasWindow(name2) {
  return has_default(window_functions_default, name2);
}
function hasFunction(name2) {
  return has_default(functions_default, name2) || name2 === "row_object";
}
function getAggregate(name2) {
  return hasAggregate(name2) && aggregate_functions_default[name2];
}
function getWindow(name2) {
  return hasWindow(name2) && window_functions_default[name2];
}

// node_modules/arquero/src/expression/compile.js
function compile(code, fn, params) {
  code = `"use strict"; return ${code};`;
  return Function("fn", "$", code)(fn, params);
}
var compile_default = {
  escape: (code, func4, params) => compile(code, func4, params),
  expr: (code, params) => compile(`(row,data,op)=>${code}`, functions_default, params),
  expr2: (code, params) => compile(`(row0,data0,row,data)=>${code}`, functions_default, params),
  join: (code, params) => compile(`(row1,data1,row2,data2)=>${code}`, functions_default, params),
  param: (code, params) => compile(code, functions_default, params)
};

// node_modules/arquero/src/expression/rewrite.js
var dictOps = {
  "==": 1,
  "!=": 1,
  "===": 1,
  "!==": 1
};
function rewrite_default(ref3, name2, index = 0, col, op) {
  ref3.type = Column2;
  ref3.name = name2;
  ref3.table = index;
  if (op && col && is_function_default(col.keyFor)) {
    const lit = dictOps[op.operator] ? op.left === ref3 ? op.right : op.left : op.callee && op.callee.name === "equal" ? op.arguments[op.arguments[0] === ref3 ? 1 : 0] : null;
    if (lit && lit.type === Literal) {
      rewriteDictionary(op, ref3, lit, col.keyFor(lit.value));
    }
  }
  return ref3;
}
function rewriteDictionary(op, ref3, lit, key2) {
  if (key2 < 0) {
    op.type = Literal;
    op.value = false;
    op.raw = "false";
  } else {
    ref3.type = Dictionary;
    lit.value = key2;
    lit.raw = key2 + "";
  }
  return true;
}

// node_modules/arquero/src/util/entries.js
function entries_default(value) {
  return is_array_default(value) ? value : is_map_default(value) ? value.entries() : value ? Object.entries(value) : [];
}

// node_modules/arquero/src/expression/row-object.js
var ROW_OBJECT = "row_object";
function rowObjectExpression(node, props) {
  node.type = ObjectExpression;
  const p = node.properties = [];
  for (const prop of entries_default(props)) {
    const [name2, key2] = is_array_default(prop) ? prop : [prop, prop];
    p.push({
      type: Property,
      key: { type: Literal, raw: to_string_default(key2) },
      value: rewrite_default({ computed: true }, name2)
    });
  }
  return node;
}
function rowObjectCode(props) {
  return codegen_default(rowObjectExpression({}, props));
}
function rowObjectBuilder(props) {
  return compile_default.expr(rowObjectCode(props));
}

// node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t2[p[i2]] = s[p[i2]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g[n2])
      i2[n2] = function(v) {
        return new Promise(function(a, b) {
          q.push([n2, v, a, b]) > 1 || resume(n2, v);
        });
      };
  }
  function resume(n2, v) {
    try {
      step(g[n2](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i2, p;
  return i2 = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f) {
    i2[n2] = o[n2] ? function(v) {
      return (p = !p) ? { value: __await(o[n2](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i2;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o[n2] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n2](v), settle(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/apache-arrow/util/buffer.mjs
var buffer_exports = {};
__export(buffer_exports, {
  compareArrayLike: () => compareArrayLike,
  joinUint8Arrays: () => joinUint8Arrays,
  memcpy: () => memcpy,
  rebaseValueOffsets: () => rebaseValueOffsets,
  toArrayBufferView: () => toArrayBufferView,
  toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,
  toArrayBufferViewIterator: () => toArrayBufferViewIterator,
  toBigInt64Array: () => toBigInt64Array,
  toBigUint64Array: () => toBigUint64Array,
  toFloat32Array: () => toFloat32Array,
  toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,
  toFloat32ArrayIterator: () => toFloat32ArrayIterator,
  toFloat64Array: () => toFloat64Array,
  toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,
  toFloat64ArrayIterator: () => toFloat64ArrayIterator,
  toInt16Array: () => toInt16Array,
  toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,
  toInt16ArrayIterator: () => toInt16ArrayIterator,
  toInt32Array: () => toInt32Array,
  toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,
  toInt32ArrayIterator: () => toInt32ArrayIterator,
  toInt8Array: () => toInt8Array,
  toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,
  toInt8ArrayIterator: () => toInt8ArrayIterator,
  toUint16Array: () => toUint16Array,
  toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,
  toUint16ArrayIterator: () => toUint16ArrayIterator,
  toUint32Array: () => toUint32Array,
  toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,
  toUint32ArrayIterator: () => toUint32ArrayIterator,
  toUint8Array: () => toUint8Array,
  toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,
  toUint8ArrayIterator: () => toUint8ArrayIterator,
  toUint8ClampedArray: () => toUint8ClampedArray,
  toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,
  toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator
});

// node_modules/apache-arrow/util/utf8.mjs
var decoder = new TextDecoder("utf-8");
var decodeUtf8 = (buffer) => decoder.decode(buffer);
var encoder = new TextEncoder();
var encodeUtf8 = (value) => encoder.encode(value);

// node_modules/apache-arrow/util/compat.mjs
var isNumber = (x) => typeof x === "number";
var isBoolean = (x) => typeof x === "boolean";
var isFunction = (x) => typeof x === "function";
var isObject = (x) => x != null && Object(x) === x;
var isPromise = (x) => {
  return isObject(x) && isFunction(x.then);
};
var isIterable = (x) => {
  return isObject(x) && isFunction(x[Symbol.iterator]);
};
var isAsyncIterable = (x) => {
  return isObject(x) && isFunction(x[Symbol.asyncIterator]);
};
var isArrowJSON = (x) => {
  return isObject(x) && isObject(x["schema"]);
};
var isIteratorResult = (x) => {
  return isObject(x) && "done" in x && "value" in x;
};
var isFileHandle = (x) => {
  return isObject(x) && isFunction(x["stat"]) && isNumber(x["fd"]);
};
var isFetchResponse = (x) => {
  return isObject(x) && isReadableDOMStream(x["body"]);
};
var isReadableInterop = (x) => "_getDOMStream" in x && "_getNodeStream" in x;
var isWritableDOMStream = (x) => {
  return isObject(x) && isFunction(x["abort"]) && isFunction(x["getWriter"]) && !isReadableInterop(x);
};
var isReadableDOMStream = (x) => {
  return isObject(x) && isFunction(x["cancel"]) && isFunction(x["getReader"]) && !isReadableInterop(x);
};
var isWritableNodeStream = (x) => {
  return isObject(x) && isFunction(x["end"]) && isFunction(x["write"]) && isBoolean(x["writable"]) && !isReadableInterop(x);
};
var isReadableNodeStream = (x) => {
  return isObject(x) && isFunction(x["read"]) && isFunction(x["pipe"]) && isBoolean(x["readable"]) && !isReadableInterop(x);
};
var isFlatbuffersByteBuffer = (x) => {
  return isObject(x) && isFunction(x["clear"]) && isFunction(x["bytes"]) && isFunction(x["position"]) && isFunction(x["setPosition"]) && isFunction(x["capacity"]) && isFunction(x["getBufferIdentifier"]) && isFunction(x["createLong"]);
};

// node_modules/apache-arrow/util/buffer.mjs
var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
function collapseContiguousByteRanges(chunks) {
  const result = chunks[0] ? [chunks[0]] : [];
  let xOffset, yOffset, xLen, yLen;
  for (let x, y, i2 = 0, j = 0, n2 = chunks.length; ++i2 < n2; ) {
    x = result[j];
    y = chunks[i2];
    if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
      y && (result[++j] = y);
      continue;
    }
    ({ byteOffset: xOffset, byteLength: xLen } = x);
    ({ byteOffset: yOffset, byteLength: yLen } = y);
    if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
      y && (result[++j] = y);
      continue;
    }
    result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
  }
  return result;
}
function memcpy(target, source2, targetByteOffset = 0, sourceByteLength = source2.byteLength) {
  const targetByteLength = target.byteLength;
  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
  const src = new Uint8Array(source2.buffer, source2.byteOffset, Math.min(sourceByteLength, targetByteLength));
  dst.set(src, targetByteOffset);
  return target;
}
function joinUint8Arrays(chunks, size) {
  const result = collapseContiguousByteRanges(chunks);
  const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
  let source2, sliced, buffer;
  let offset2 = 0, index = -1;
  const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
  for (const n2 = result.length; ++index < n2; ) {
    source2 = result[index];
    sliced = source2.subarray(0, Math.min(source2.length, length - offset2));
    if (length <= offset2 + sliced.length) {
      if (sliced.length < source2.length) {
        result[index] = source2.subarray(sliced.length);
      } else if (sliced.length === source2.length) {
        index++;
      }
      buffer ? memcpy(buffer, sliced, offset2) : buffer = sliced;
      break;
    }
    memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset2);
    offset2 += sliced.length;
  }
  return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
}
function toArrayBufferView(ArrayBufferViewCtor, input) {
  let value = isIteratorResult(input) ? input.value : input;
  if (value instanceof ArrayBufferViewCtor) {
    if (ArrayBufferViewCtor === Uint8Array) {
      return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
    }
    return value;
  }
  if (!value) {
    return new ArrayBufferViewCtor(0);
  }
  if (typeof value === "string") {
    value = encodeUtf8(value);
  }
  if (value instanceof ArrayBuffer) {
    return new ArrayBufferViewCtor(value);
  }
  if (value instanceof SharedArrayBuf) {
    return new ArrayBufferViewCtor(value);
  }
  if (isFlatbuffersByteBuffer(value)) {
    return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
  }
  return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
}
var toInt8Array = (input) => toArrayBufferView(Int8Array, input);
var toInt16Array = (input) => toArrayBufferView(Int16Array, input);
var toInt32Array = (input) => toArrayBufferView(Int32Array, input);
var toBigInt64Array = (input) => toArrayBufferView(BigInt64Array, input);
var toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
var toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
var toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
var toBigUint64Array = (input) => toArrayBufferView(BigUint64Array, input);
var toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
var toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
var toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
var pump = (iterator) => {
  iterator.next();
  return iterator;
};
function* toArrayBufferViewIterator(ArrayCtor, source2) {
  const wrap = function* (x) {
    yield x;
  };
  const buffers = typeof source2 === "string" ? wrap(source2) : ArrayBuffer.isView(source2) ? wrap(source2) : source2 instanceof ArrayBuffer ? wrap(source2) : source2 instanceof SharedArrayBuf ? wrap(source2) : !isIterable(source2) ? wrap(source2) : source2;
  yield* pump(function* (it) {
    let r = null;
    do {
      r = it.next(yield toArrayBufferView(ArrayCtor, r));
    } while (!r.done);
  }(buffers[Symbol.iterator]()));
  return new ArrayCtor();
}
var toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
var toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
var toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
var toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
var toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
var toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
var toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
var toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
var toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
function toArrayBufferViewAsyncIterator(ArrayCtor, source2) {
  return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
    if (isPromise(source2)) {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source2))))));
    }
    const wrap = function(x) {
      return __asyncGenerator(this, arguments, function* () {
        yield yield __await(yield __await(x));
      });
    };
    const emit = function(source3) {
      return __asyncGenerator(this, arguments, function* () {
        yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it) {
          let r = null;
          do {
            r = it.next(yield r === null || r === void 0 ? void 0 : r.value);
          } while (!r.done);
        }(source3[Symbol.iterator]())))));
      });
    };
    const buffers = typeof source2 === "string" ? wrap(source2) : ArrayBuffer.isView(source2) ? wrap(source2) : source2 instanceof ArrayBuffer ? wrap(source2) : source2 instanceof SharedArrayBuf ? wrap(source2) : isIterable(source2) ? emit(source2) : !isAsyncIterable(source2) ? wrap(source2) : source2;
    yield __await(
      // otherwise if AsyncIterable, use it
      yield* __asyncDelegator(__asyncValues(pump(function(it) {
        return __asyncGenerator(this, arguments, function* () {
          let r = null;
          do {
            r = yield __await(it.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));
          } while (!r.done);
        });
      }(buffers[Symbol.asyncIterator]()))))
    );
    return yield __await(new ArrayCtor());
  });
}
var toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
var toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
var toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
var toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
var toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
var toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
var toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
var toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
var toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
function rebaseValueOffsets(offset2, length, valueOffsets) {
  if (offset2 !== 0) {
    valueOffsets = valueOffsets.slice(0, length);
    for (let i2 = -1, n2 = valueOffsets.length; ++i2 < n2; ) {
      valueOffsets[i2] += offset2;
    }
  }
  return valueOffsets.subarray(0, length);
}
function compareArrayLike(a, b) {
  let i2 = 0;
  const n2 = a.length;
  if (n2 !== b.length) {
    return false;
  }
  if (n2 > 0) {
    do {
      if (a[i2] !== b[i2]) {
        return false;
      }
    } while (++i2 < n2);
  }
  return true;
}

// node_modules/apache-arrow/io/adapters.mjs
var adapters_default = {
  fromIterable(source2) {
    return pump2(fromIterable2(source2));
  },
  fromAsyncIterable(source2) {
    return pump2(fromAsyncIterable(source2));
  },
  fromDOMStream(source2) {
    return pump2(fromDOMStream(source2));
  },
  fromNodeStream(stream) {
    return pump2(fromNodeStream(stream));
  },
  // @ts-ignore
  toDOMStream(source2, options) {
    throw new Error(`"toDOMStream" not available in this environment`);
  },
  // @ts-ignore
  toNodeStream(source2, options) {
    throw new Error(`"toNodeStream" not available in this environment`);
  }
};
var pump2 = (iterator) => {
  iterator.next();
  return iterator;
};
function* fromIterable2(source2) {
  let done, threw = false;
  let buffers = [], buffer;
  let cmd, size, bufferLength = 0;
  function byteRange() {
    if (cmd === "peek") {
      return joinUint8Arrays(buffers, size)[0];
    }
    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
    return buffer;
  }
  ({ cmd, size } = yield null);
  const it = toUint8ArrayIterator(source2)[Symbol.iterator]();
  try {
    do {
      ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it.next() : it.next(size - bufferLength));
      if (!done && buffer.byteLength > 0) {
        buffers.push(buffer);
        bufferLength += buffer.byteLength;
      }
      if (done || size <= bufferLength) {
        do {
          ({ cmd, size } = yield byteRange());
        } while (size < bufferLength);
      }
    } while (!done);
  } catch (e) {
    (threw = true) && typeof it.throw === "function" && it.throw(e);
  } finally {
    threw === false && typeof it.return === "function" && it.return(null);
  }
  return null;
}
function fromAsyncIterable(source2) {
  return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield yield __await(null));
    const it = toUint8ArrayAsyncIterator(source2)[Symbol.asyncIterator]();
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it.next()) : yield __await(it.next(size - bufferLength)));
        if (!done && buffer.byteLength > 0) {
          buffers.push(buffer);
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield yield __await(byteRange()));
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && typeof it.throw === "function" && (yield __await(it.throw(e)));
    } finally {
      threw === false && typeof it.return === "function" && (yield __await(it.return(new Uint8Array(0))));
    }
    return yield __await(null);
  });
}
function fromDOMStream(source2) {
  return __asyncGenerator(this, arguments, function* fromDOMStream_1() {
    let done = false, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield yield __await(null));
    const it = new AdaptiveByteReader(source2);
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it["read"]()) : yield __await(it["read"](size - bufferLength)));
        if (!done && buffer.byteLength > 0) {
          buffers.push(toUint8Array(buffer));
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield yield __await(byteRange()));
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && (yield __await(it["cancel"](e)));
    } finally {
      threw === false ? yield __await(it["cancel"]()) : source2["locked"] && it.releaseLock();
    }
    return yield __await(null);
  });
}
var AdaptiveByteReader = class {
  constructor(source2) {
    this.source = source2;
    this.reader = null;
    this.reader = this.source["getReader"]();
    this.reader["closed"].catch(() => {
    });
  }
  get closed() {
    return this.reader ? this.reader["closed"].catch(() => {
    }) : Promise.resolve();
  }
  releaseLock() {
    if (this.reader) {
      this.reader.releaseLock();
    }
    this.reader = null;
  }
  cancel(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      const { reader, source: source2 } = this;
      reader && (yield reader["cancel"](reason).catch(() => {
      }));
      source2 && (source2["locked"] && this.releaseLock());
    });
  }
  read(size) {
    return __awaiter(this, void 0, void 0, function* () {
      if (size === 0) {
        return { done: this.reader == null, value: new Uint8Array(0) };
      }
      const result = yield this.reader.read();
      !result.done && (result.value = toUint8Array(result));
      return result;
    });
  }
};
var onEvent = (stream, event) => {
  const handler = (_) => resolve2([event, _]);
  let resolve2;
  return [event, handler, new Promise((r) => (resolve2 = r) && stream["once"](event, handler))];
};
function fromNodeStream(stream) {
  return __asyncGenerator(this, arguments, function* fromNodeStream_1() {
    const events = [];
    let event = "error";
    let done = false, err = null;
    let cmd, size, bufferLength = 0;
    let buffers = [], buffer;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield yield __await(null));
    if (stream["isTTY"]) {
      yield yield __await(new Uint8Array(0));
      return yield __await(null);
    }
    try {
      events[0] = onEvent(stream, "end");
      events[1] = onEvent(stream, "error");
      do {
        events[2] = onEvent(stream, "readable");
        [event, err] = yield __await(Promise.race(events.map((x) => x[2])));
        if (event === "error") {
          break;
        }
        if (!(done = event === "end")) {
          if (!Number.isFinite(size - bufferLength)) {
            buffer = toUint8Array(stream["read"]());
          } else {
            buffer = toUint8Array(stream["read"](size - bufferLength));
            if (buffer.byteLength < size - bufferLength) {
              buffer = toUint8Array(stream["read"]());
            }
          }
          if (buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield yield __await(byteRange()));
          } while (size < bufferLength);
        }
      } while (!done);
    } finally {
      yield __await(cleanup(events, event === "error" ? err : null));
    }
    return yield __await(null);
    function cleanup(events2, err2) {
      buffer = buffers = null;
      return new Promise((resolve2, reject) => {
        for (const [evt, fn] of events2) {
          stream["off"](evt, fn);
        }
        try {
          const destroy = stream["destroy"];
          destroy && destroy.call(stream, err2);
          err2 = void 0;
        } catch (e) {
          err2 = e || err2;
        } finally {
          err2 != null ? reject(err2) : resolve2();
        }
      });
    }
  });
}

// node_modules/apache-arrow/enum.mjs
var MetadataVersion;
(function(MetadataVersion3) {
  MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
  MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
  MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
  MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
  MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
})(MetadataVersion || (MetadataVersion = {}));
var UnionMode;
(function(UnionMode3) {
  UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
  UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
})(UnionMode || (UnionMode = {}));
var Precision;
(function(Precision3) {
  Precision3[Precision3["HALF"] = 0] = "HALF";
  Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
  Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
})(Precision || (Precision = {}));
var DateUnit;
(function(DateUnit3) {
  DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
  DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit || (DateUnit = {}));
var TimeUnit;
(function(TimeUnit3) {
  TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
  TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
  TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit || (TimeUnit = {}));
var IntervalUnit;
(function(IntervalUnit3) {
  IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
  IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
  IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit || (IntervalUnit = {}));
var MessageHeader;
(function(MessageHeader3) {
  MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
  MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
  MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
  MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
  MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
  MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader || (MessageHeader = {}));
var Type;
(function(Type3) {
  Type3[Type3["NONE"] = 0] = "NONE";
  Type3[Type3["Null"] = 1] = "Null";
  Type3[Type3["Int"] = 2] = "Int";
  Type3[Type3["Float"] = 3] = "Float";
  Type3[Type3["Binary"] = 4] = "Binary";
  Type3[Type3["Utf8"] = 5] = "Utf8";
  Type3[Type3["Bool"] = 6] = "Bool";
  Type3[Type3["Decimal"] = 7] = "Decimal";
  Type3[Type3["Date"] = 8] = "Date";
  Type3[Type3["Time"] = 9] = "Time";
  Type3[Type3["Timestamp"] = 10] = "Timestamp";
  Type3[Type3["Interval"] = 11] = "Interval";
  Type3[Type3["List"] = 12] = "List";
  Type3[Type3["Struct"] = 13] = "Struct";
  Type3[Type3["Union"] = 14] = "Union";
  Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
  Type3[Type3["Map"] = 17] = "Map";
  Type3[Type3["Duration"] = 18] = "Duration";
  Type3[Type3["Dictionary"] = -1] = "Dictionary";
  Type3[Type3["Int8"] = -2] = "Int8";
  Type3[Type3["Int16"] = -3] = "Int16";
  Type3[Type3["Int32"] = -4] = "Int32";
  Type3[Type3["Int64"] = -5] = "Int64";
  Type3[Type3["Uint8"] = -6] = "Uint8";
  Type3[Type3["Uint16"] = -7] = "Uint16";
  Type3[Type3["Uint32"] = -8] = "Uint32";
  Type3[Type3["Uint64"] = -9] = "Uint64";
  Type3[Type3["Float16"] = -10] = "Float16";
  Type3[Type3["Float32"] = -11] = "Float32";
  Type3[Type3["Float64"] = -12] = "Float64";
  Type3[Type3["DateDay"] = -13] = "DateDay";
  Type3[Type3["DateMillisecond"] = -14] = "DateMillisecond";
  Type3[Type3["TimestampSecond"] = -15] = "TimestampSecond";
  Type3[Type3["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type3[Type3["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type3[Type3["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type3[Type3["TimeSecond"] = -19] = "TimeSecond";
  Type3[Type3["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type3[Type3["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type3[Type3["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type3[Type3["DenseUnion"] = -23] = "DenseUnion";
  Type3[Type3["SparseUnion"] = -24] = "SparseUnion";
  Type3[Type3["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type3[Type3["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  Type3[Type3["DurationSecond"] = -27] = "DurationSecond";
  Type3[Type3["DurationMillisecond"] = -28] = "DurationMillisecond";
  Type3[Type3["DurationMicrosecond"] = -29] = "DurationMicrosecond";
  Type3[Type3["DurationNanosecond"] = -30] = "DurationNanosecond";
})(Type || (Type = {}));
var BufferType;
(function(BufferType2) {
  BufferType2[BufferType2["OFFSET"] = 0] = "OFFSET";
  BufferType2[BufferType2["DATA"] = 1] = "DATA";
  BufferType2[BufferType2["VALIDITY"] = 2] = "VALIDITY";
  BufferType2[BufferType2["TYPE"] = 3] = "TYPE";
})(BufferType || (BufferType = {}));

// node_modules/apache-arrow/util/vector.mjs
var vector_exports = {};
__export(vector_exports, {
  clampIndex: () => clampIndex,
  clampRange: () => clampRange,
  createElementComparator: () => createElementComparator
});

// node_modules/apache-arrow/util/pretty.mjs
var pretty_exports = {};
__export(pretty_exports, {
  valueToString: () => valueToString
});
var undf = void 0;
function valueToString(x) {
  if (x === null) {
    return "null";
  }
  if (x === undf) {
    return "undefined";
  }
  switch (typeof x) {
    case "number":
      return `${x}`;
    case "bigint":
      return `${x}`;
    case "string":
      return `"${x}"`;
  }
  if (typeof x[Symbol.toPrimitive] === "function") {
    return x[Symbol.toPrimitive]("string");
  }
  if (ArrayBuffer.isView(x)) {
    if (x instanceof BigInt64Array || x instanceof BigUint64Array) {
      return `[${[...x].map((x2) => valueToString(x2))}]`;
    }
    return `[${x}]`;
  }
  return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === "bigint" ? `${y}` : y);
}

// node_modules/apache-arrow/util/bn.mjs
var bn_exports = {};
__export(bn_exports, {
  BN: () => BN,
  bigNumToBigInt: () => bigNumToBigInt,
  bigNumToString: () => bigNumToString,
  isArrowBigNumSymbol: () => isArrowBigNumSymbol
});
var isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
function BigNum(x, ...xs) {
  if (xs.length === 0) {
    return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x), this.constructor.prototype);
  }
  return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
}
BigNum.prototype[isArrowBigNumSymbol] = true;
BigNum.prototype.toJSON = function() {
  return `"${bigNumToString(this)}"`;
};
BigNum.prototype.valueOf = function() {
  return bigNumToNumber(this);
};
BigNum.prototype.toString = function() {
  return bigNumToString(this);
};
BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
  switch (hint) {
    case "number":
      return bigNumToNumber(this);
    case "string":
      return bigNumToString(this);
    case "default":
      return bigNumToBigInt(this);
  }
  return bigNumToString(this);
};
function SignedBigNum(...args) {
  return BigNum.apply(this, args);
}
function UnsignedBigNum(...args) {
  return BigNum.apply(this, args);
}
function DecimalBigNum(...args) {
  return BigNum.apply(this, args);
}
Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
Object.assign(SignedBigNum.prototype, BigNum.prototype, { "constructor": SignedBigNum, "signed": true, "TypedArray": Int32Array, "BigIntArray": BigInt64Array });
Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { "constructor": UnsignedBigNum, "signed": false, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
Object.assign(DecimalBigNum.prototype, BigNum.prototype, { "constructor": DecimalBigNum, "signed": true, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
function bigNumToNumber(bn) {
  const { buffer, byteOffset, length, "signed": signed } = bn;
  const words = new BigUint64Array(buffer, byteOffset, length);
  const negative = signed && words.at(-1) & BigInt(1) << BigInt(63);
  let number = negative ? BigInt(1) : BigInt(0);
  let i2 = BigInt(0);
  if (!negative) {
    for (const word of words) {
      number += word * (BigInt(1) << BigInt(32) * i2++);
    }
  } else {
    for (const word of words) {
      number += ~word * (BigInt(1) << BigInt(32) * i2++);
    }
    number *= BigInt(-1);
  }
  return number;
}
var bigNumToString = (a) => {
  if (a.byteLength === 8) {
    const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
    return `${bigIntArray[0]}`;
  }
  if (!a["signed"]) {
    return unsignedBigNumToString(a);
  }
  let array3 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
  const highOrderWord = new Int16Array([array3.at(-1)])[0];
  if (highOrderWord >= 0) {
    return unsignedBigNumToString(a);
  }
  array3 = array3.slice();
  let carry = 1;
  for (let i2 = 0; i2 < array3.length; i2++) {
    const elem = array3[i2];
    const updated = ~elem + carry;
    array3[i2] = updated;
    carry &= elem === 0 ? 1 : 0;
  }
  const negated = unsignedBigNumToString(array3);
  return `-${negated}`;
};
var bigNumToBigInt = (a) => {
  if (a.byteLength === 8) {
    const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
    return bigIntArray[0];
  } else {
    return bigNumToString(a);
  }
};
function unsignedBigNumToString(a) {
  let digits = "";
  const base64 = new Uint32Array(2);
  let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
  const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
  let i2 = -1;
  const n2 = base32.length - 1;
  do {
    for (base64[0] = base32[i2 = 0]; i2 < n2; ) {
      base32[i2++] = base64[1] = base64[0] / 10;
      base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i2];
    }
    base32[i2] = base64[1] = base64[0] / 10;
    base64[0] = base64[0] - base64[1] * 10;
    digits = `${base64[0]}${digits}`;
  } while (checks[0] || checks[1] || checks[2] || checks[3]);
  return digits !== null && digits !== void 0 ? digits : `0`;
}
var BN = class _BN {
  /** @nocollapse */
  static new(num, isSigned) {
    switch (isSigned) {
      case true:
        return new SignedBigNum(num);
      case false:
        return new UnsignedBigNum(num);
    }
    switch (num.constructor) {
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case BigInt64Array:
        return new SignedBigNum(num);
    }
    if (num.byteLength === 16) {
      return new DecimalBigNum(num);
    }
    return new UnsignedBigNum(num);
  }
  /** @nocollapse */
  static signed(num) {
    return new SignedBigNum(num);
  }
  /** @nocollapse */
  static unsigned(num) {
    return new UnsignedBigNum(num);
  }
  /** @nocollapse */
  static decimal(num) {
    return new DecimalBigNum(num);
  }
  constructor(num, isSigned) {
    return _BN.new(num, isSigned);
  }
};

// node_modules/apache-arrow/util/bigint.mjs
function bigIntToNumber(number) {
  if (typeof number === "bigint" && (number < Number.MIN_SAFE_INTEGER || number > Number.MAX_SAFE_INTEGER)) {
    throw new TypeError(`${number} is not safe to convert to a number.`);
  }
  return Number(number);
}

// node_modules/apache-arrow/type.mjs
var _a;
var _b;
var _c;
var _d;
var _e;
var _f;
var _g;
var _h;
var _j;
var _k;
var _l;
var _m;
var _o;
var _p;
var _q;
var _r;
var _s;
var _t;
var _u;
var _v;
var DataType = class _DataType {
  /** @nocollapse */
  static isNull(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Null;
  }
  /** @nocollapse */
  static isInt(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Int;
  }
  /** @nocollapse */
  static isFloat(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Float;
  }
  /** @nocollapse */
  static isBinary(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Binary;
  }
  /** @nocollapse */
  static isUtf8(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Utf8;
  }
  /** @nocollapse */
  static isBool(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Bool;
  }
  /** @nocollapse */
  static isDecimal(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Decimal;
  }
  /** @nocollapse */
  static isDate(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Date;
  }
  /** @nocollapse */
  static isTime(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Time;
  }
  /** @nocollapse */
  static isTimestamp(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Timestamp;
  }
  /** @nocollapse */
  static isInterval(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Interval;
  }
  /** @nocollapse */
  static isDuration(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Duration;
  }
  /** @nocollapse */
  static isList(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.List;
  }
  /** @nocollapse */
  static isStruct(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Struct;
  }
  /** @nocollapse */
  static isUnion(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Union;
  }
  /** @nocollapse */
  static isFixedSizeBinary(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeBinary;
  }
  /** @nocollapse */
  static isFixedSizeList(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeList;
  }
  /** @nocollapse */
  static isMap(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Map;
  }
  /** @nocollapse */
  static isDictionary(x) {
    return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Dictionary;
  }
  /** @nocollapse */
  static isDenseUnion(x) {
    return _DataType.isUnion(x) && x.mode === UnionMode.Dense;
  }
  /** @nocollapse */
  static isSparseUnion(x) {
    return _DataType.isUnion(x) && x.mode === UnionMode.Sparse;
  }
  get typeId() {
    return Type.NONE;
  }
};
_a = Symbol.toStringTag;
DataType[_a] = ((proto2) => {
  proto2.children = null;
  proto2.ArrayType = Array;
  return proto2[Symbol.toStringTag] = "DataType";
})(DataType.prototype);
var Null = class extends DataType {
  toString() {
    return `Null`;
  }
  get typeId() {
    return Type.Null;
  }
};
_b = Symbol.toStringTag;
Null[_b] = ((proto2) => proto2[Symbol.toStringTag] = "Null")(Null.prototype);
var Int_ = class extends DataType {
  constructor(isSigned, bitWidth) {
    super();
    this.isSigned = isSigned;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type.Int;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? BigInt64Array : BigUint64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
  }
};
_c = Symbol.toStringTag;
Int_[_c] = ((proto2) => {
  proto2.isSigned = null;
  proto2.bitWidth = null;
  return proto2[Symbol.toStringTag] = "Int";
})(Int_.prototype);
var Int8 = class extends Int_ {
  constructor() {
    super(true, 8);
  }
  get ArrayType() {
    return Int8Array;
  }
};
var Int16 = class extends Int_ {
  constructor() {
    super(true, 16);
  }
  get ArrayType() {
    return Int16Array;
  }
};
var Int32 = class extends Int_ {
  constructor() {
    super(true, 32);
  }
  get ArrayType() {
    return Int32Array;
  }
};
var Int64 = class extends Int_ {
  constructor() {
    super(true, 64);
  }
  get ArrayType() {
    return BigInt64Array;
  }
};
var Uint8 = class extends Int_ {
  constructor() {
    super(false, 8);
  }
  get ArrayType() {
    return Uint8Array;
  }
};
var Uint16 = class extends Int_ {
  constructor() {
    super(false, 16);
  }
  get ArrayType() {
    return Uint16Array;
  }
};
var Uint32 = class extends Int_ {
  constructor() {
    super(false, 32);
  }
  get ArrayType() {
    return Uint32Array;
  }
};
var Uint64 = class extends Int_ {
  constructor() {
    super(false, 64);
  }
  get ArrayType() {
    return BigUint64Array;
  }
};
Object.defineProperty(Int8.prototype, "ArrayType", { value: Int8Array });
Object.defineProperty(Int16.prototype, "ArrayType", { value: Int16Array });
Object.defineProperty(Int32.prototype, "ArrayType", { value: Int32Array });
Object.defineProperty(Int64.prototype, "ArrayType", { value: BigInt64Array });
Object.defineProperty(Uint8.prototype, "ArrayType", { value: Uint8Array });
Object.defineProperty(Uint16.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(Uint32.prototype, "ArrayType", { value: Uint32Array });
Object.defineProperty(Uint64.prototype, "ArrayType", { value: BigUint64Array });
var Float = class extends DataType {
  constructor(precision) {
    super();
    this.precision = precision;
  }
  get typeId() {
    return Type.Float;
  }
  get ArrayType() {
    switch (this.precision) {
      case Precision.HALF:
        return Uint16Array;
      case Precision.SINGLE:
        return Float32Array;
      case Precision.DOUBLE:
        return Float64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `Float${this.precision << 5 || 16}`;
  }
};
_d = Symbol.toStringTag;
Float[_d] = ((proto2) => {
  proto2.precision = null;
  return proto2[Symbol.toStringTag] = "Float";
})(Float.prototype);
var Float16 = class extends Float {
  constructor() {
    super(Precision.HALF);
  }
};
var Float32 = class extends Float {
  constructor() {
    super(Precision.SINGLE);
  }
};
var Float64 = class extends Float {
  constructor() {
    super(Precision.DOUBLE);
  }
};
Object.defineProperty(Float16.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(Float32.prototype, "ArrayType", { value: Float32Array });
Object.defineProperty(Float64.prototype, "ArrayType", { value: Float64Array });
var Binary = class extends DataType {
  constructor() {
    super();
  }
  get typeId() {
    return Type.Binary;
  }
  toString() {
    return `Binary`;
  }
};
_e = Symbol.toStringTag;
Binary[_e] = ((proto2) => {
  proto2.ArrayType = Uint8Array;
  return proto2[Symbol.toStringTag] = "Binary";
})(Binary.prototype);
var Utf8 = class extends DataType {
  constructor() {
    super();
  }
  get typeId() {
    return Type.Utf8;
  }
  toString() {
    return `Utf8`;
  }
};
_f = Symbol.toStringTag;
Utf8[_f] = ((proto2) => {
  proto2.ArrayType = Uint8Array;
  return proto2[Symbol.toStringTag] = "Utf8";
})(Utf8.prototype);
var Bool = class extends DataType {
  constructor() {
    super();
  }
  get typeId() {
    return Type.Bool;
  }
  toString() {
    return `Bool`;
  }
};
_g = Symbol.toStringTag;
Bool[_g] = ((proto2) => {
  proto2.ArrayType = Uint8Array;
  return proto2[Symbol.toStringTag] = "Bool";
})(Bool.prototype);
var Decimal = class extends DataType {
  constructor(scale2, precision, bitWidth = 128) {
    super();
    this.scale = scale2;
    this.precision = precision;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type.Decimal;
  }
  toString() {
    return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
  }
};
_h = Symbol.toStringTag;
Decimal[_h] = ((proto2) => {
  proto2.scale = null;
  proto2.precision = null;
  proto2.ArrayType = Uint32Array;
  return proto2[Symbol.toStringTag] = "Decimal";
})(Decimal.prototype);
var Date_ = class extends DataType {
  constructor(unit) {
    super();
    this.unit = unit;
  }
  get typeId() {
    return Type.Date;
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
  }
};
_j = Symbol.toStringTag;
Date_[_j] = ((proto2) => {
  proto2.unit = null;
  proto2.ArrayType = Int32Array;
  return proto2[Symbol.toStringTag] = "Date";
})(Date_.prototype);
var DateDay = class extends Date_ {
  constructor() {
    super(DateUnit.DAY);
  }
};
var DateMillisecond = class extends Date_ {
  constructor() {
    super(DateUnit.MILLISECOND);
  }
};
var Time_ = class extends DataType {
  constructor(unit, bitWidth) {
    super();
    this.unit = unit;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type.Time;
  }
  toString() {
    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 32:
        return Int32Array;
      case 64:
        return BigInt64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
};
_k = Symbol.toStringTag;
Time_[_k] = ((proto2) => {
  proto2.unit = null;
  proto2.bitWidth = null;
  return proto2[Symbol.toStringTag] = "Time";
})(Time_.prototype);
var TimeSecond = class extends Time_ {
  constructor() {
    super(TimeUnit.SECOND, 32);
  }
};
var TimeMillisecond = class extends Time_ {
  constructor() {
    super(TimeUnit.MILLISECOND, 32);
  }
};
var TimeMicrosecond = class extends Time_ {
  constructor() {
    super(TimeUnit.MICROSECOND, 64);
  }
};
var TimeNanosecond = class extends Time_ {
  constructor() {
    super(TimeUnit.NANOSECOND, 64);
  }
};
var Timestamp_ = class extends DataType {
  constructor(unit, timezone) {
    super();
    this.unit = unit;
    this.timezone = timezone;
  }
  get typeId() {
    return Type.Timestamp;
  }
  toString() {
    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
  }
};
_l = Symbol.toStringTag;
Timestamp_[_l] = ((proto2) => {
  proto2.unit = null;
  proto2.timezone = null;
  proto2.ArrayType = Int32Array;
  return proto2[Symbol.toStringTag] = "Timestamp";
})(Timestamp_.prototype);
var Interval_ = class extends DataType {
  constructor(unit) {
    super();
    this.unit = unit;
  }
  get typeId() {
    return Type.Interval;
  }
  toString() {
    return `Interval<${IntervalUnit[this.unit]}>`;
  }
};
_m = Symbol.toStringTag;
Interval_[_m] = ((proto2) => {
  proto2.unit = null;
  proto2.ArrayType = Int32Array;
  return proto2[Symbol.toStringTag] = "Interval";
})(Interval_.prototype);
var IntervalDayTime = class extends Interval_ {
  constructor() {
    super(IntervalUnit.DAY_TIME);
  }
};
var IntervalYearMonth = class extends Interval_ {
  constructor() {
    super(IntervalUnit.YEAR_MONTH);
  }
};
var Duration = class extends DataType {
  constructor(unit) {
    super();
    this.unit = unit;
  }
  get typeId() {
    return Type.Duration;
  }
  toString() {
    return `Duration<${TimeUnit[this.unit]}>`;
  }
};
_o = Symbol.toStringTag;
Duration[_o] = ((proto2) => {
  proto2.unit = null;
  proto2.ArrayType = BigInt64Array;
  return proto2[Symbol.toStringTag] = "Duration";
})(Duration.prototype);
var List = class extends DataType {
  constructor(child) {
    super();
    this.children = [child];
  }
  get typeId() {
    return Type.List;
  }
  toString() {
    return `List<${this.valueType}>`;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
};
_p = Symbol.toStringTag;
List[_p] = ((proto2) => {
  proto2.children = null;
  return proto2[Symbol.toStringTag] = "List";
})(List.prototype);
var Struct = class extends DataType {
  constructor(children) {
    super();
    this.children = children;
  }
  get typeId() {
    return Type.Struct;
  }
  toString() {
    return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
  }
};
_q = Symbol.toStringTag;
Struct[_q] = ((proto2) => {
  proto2.children = null;
  return proto2[Symbol.toStringTag] = "Struct";
})(Struct.prototype);
var Union_ = class extends DataType {
  constructor(mode, typeIds, children) {
    super();
    this.mode = mode;
    this.children = children;
    this.typeIds = typeIds = Int32Array.from(typeIds);
    this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));
  }
  get typeId() {
    return Type.Union;
  }
  toString() {
    return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
  }
};
_r = Symbol.toStringTag;
Union_[_r] = ((proto2) => {
  proto2.mode = null;
  proto2.typeIds = null;
  proto2.children = null;
  proto2.typeIdToChildIndex = null;
  proto2.ArrayType = Int8Array;
  return proto2[Symbol.toStringTag] = "Union";
})(Union_.prototype);
var FixedSizeBinary = class extends DataType {
  constructor(byteWidth) {
    super();
    this.byteWidth = byteWidth;
  }
  get typeId() {
    return Type.FixedSizeBinary;
  }
  toString() {
    return `FixedSizeBinary[${this.byteWidth}]`;
  }
};
_s = Symbol.toStringTag;
FixedSizeBinary[_s] = ((proto2) => {
  proto2.byteWidth = null;
  proto2.ArrayType = Uint8Array;
  return proto2[Symbol.toStringTag] = "FixedSizeBinary";
})(FixedSizeBinary.prototype);
var FixedSizeList = class extends DataType {
  constructor(listSize, child) {
    super();
    this.listSize = listSize;
    this.children = [child];
  }
  get typeId() {
    return Type.FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
};
_t = Symbol.toStringTag;
FixedSizeList[_t] = ((proto2) => {
  proto2.children = null;
  proto2.listSize = null;
  return proto2[Symbol.toStringTag] = "FixedSizeList";
})(FixedSizeList.prototype);
var Map_ = class extends DataType {
  constructor(entries, keysSorted = false) {
    var _w, _x, _y;
    super();
    this.children = [entries];
    this.keysSorted = keysSorted;
    if (entries) {
      entries["name"] = "entries";
      if ((_w = entries === null || entries === void 0 ? void 0 : entries.type) === null || _w === void 0 ? void 0 : _w.children) {
        const key2 = (_x = entries === null || entries === void 0 ? void 0 : entries.type) === null || _x === void 0 ? void 0 : _x.children[0];
        if (key2) {
          key2["name"] = "key";
        }
        const val = (_y = entries === null || entries === void 0 ? void 0 : entries.type) === null || _y === void 0 ? void 0 : _y.children[1];
        if (val) {
          val["name"] = "value";
        }
      }
    }
  }
  get typeId() {
    return Type.Map;
  }
  get keyType() {
    return this.children[0].type.children[0].type;
  }
  get valueType() {
    return this.children[0].type.children[1].type;
  }
  get childType() {
    return this.children[0].type;
  }
  toString() {
    return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
  }
};
_u = Symbol.toStringTag;
Map_[_u] = ((proto2) => {
  proto2.children = null;
  proto2.keysSorted = null;
  return proto2[Symbol.toStringTag] = "Map_";
})(Map_.prototype);
var getId = /* @__PURE__ */ ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
var Dictionary2 = class extends DataType {
  constructor(dictionary2, indices, id, isOrdered) {
    super();
    this.indices = indices;
    this.dictionary = dictionary2;
    this.isOrdered = isOrdered || false;
    this.id = id == null ? getId() : bigIntToNumber(id);
  }
  get typeId() {
    return Type.Dictionary;
  }
  get children() {
    return this.dictionary.children;
  }
  get valueType() {
    return this.dictionary;
  }
  get ArrayType() {
    return this.dictionary.ArrayType;
  }
  toString() {
    return `Dictionary<${this.indices}, ${this.dictionary}>`;
  }
};
_v = Symbol.toStringTag;
Dictionary2[_v] = ((proto2) => {
  proto2.id = null;
  proto2.indices = null;
  proto2.isOrdered = null;
  proto2.dictionary = null;
  return proto2[Symbol.toStringTag] = "Dictionary";
})(Dictionary2.prototype);
function strideForType(type) {
  const t2 = type;
  switch (type.typeId) {
    case Type.Decimal:
      return type.bitWidth / 32;
    case Type.Timestamp:
      return 2;
    case Type.Date:
      return 1 + t2.unit;
    case Type.Interval:
      return 1 + t2.unit;
    case Type.FixedSizeList:
      return t2.listSize;
    case Type.FixedSizeBinary:
      return t2.byteWidth;
    default:
      return 1;
  }
}

// node_modules/apache-arrow/visitor.mjs
var Visitor = class {
  visitMany(nodes, ...args) {
    return nodes.map((node, i2) => this.visit(node, ...args.map((x) => x[i2])));
  }
  visit(...args) {
    return this.getVisitFn(args[0], false).apply(this, args);
  }
  getVisitFn(node, throwIfNotFound = true) {
    return getVisitFn(this, node, throwIfNotFound);
  }
  getVisitFnByTypeId(typeId, throwIfNotFound = true) {
    return getVisitFnByTypeId(this, typeId, throwIfNotFound);
  }
  visitNull(_node, ..._args) {
    return null;
  }
  visitBool(_node, ..._args) {
    return null;
  }
  visitInt(_node, ..._args) {
    return null;
  }
  visitFloat(_node, ..._args) {
    return null;
  }
  visitUtf8(_node, ..._args) {
    return null;
  }
  visitBinary(_node, ..._args) {
    return null;
  }
  visitFixedSizeBinary(_node, ..._args) {
    return null;
  }
  visitDate(_node, ..._args) {
    return null;
  }
  visitTimestamp(_node, ..._args) {
    return null;
  }
  visitTime(_node, ..._args) {
    return null;
  }
  visitDecimal(_node, ..._args) {
    return null;
  }
  visitList(_node, ..._args) {
    return null;
  }
  visitStruct(_node, ..._args) {
    return null;
  }
  visitUnion(_node, ..._args) {
    return null;
  }
  visitDictionary(_node, ..._args) {
    return null;
  }
  visitInterval(_node, ..._args) {
    return null;
  }
  visitDuration(_node, ..._args) {
    return null;
  }
  visitFixedSizeList(_node, ..._args) {
    return null;
  }
  visitMap(_node, ..._args) {
    return null;
  }
};
function getVisitFn(visitor, node, throwIfNotFound = true) {
  if (typeof node === "number") {
    return getVisitFnByTypeId(visitor, node, throwIfNotFound);
  }
  if (typeof node === "string" && node in Type) {
    return getVisitFnByTypeId(visitor, Type[node], throwIfNotFound);
  }
  if (node && node instanceof DataType) {
    return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
  }
  if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType) {
    return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
  }
  return getVisitFnByTypeId(visitor, Type.NONE, throwIfNotFound);
}
function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
  let fn = null;
  switch (dtype) {
    case Type.Null:
      fn = visitor.visitNull;
      break;
    case Type.Bool:
      fn = visitor.visitBool;
      break;
    case Type.Int:
      fn = visitor.visitInt;
      break;
    case Type.Int8:
      fn = visitor.visitInt8 || visitor.visitInt;
      break;
    case Type.Int16:
      fn = visitor.visitInt16 || visitor.visitInt;
      break;
    case Type.Int32:
      fn = visitor.visitInt32 || visitor.visitInt;
      break;
    case Type.Int64:
      fn = visitor.visitInt64 || visitor.visitInt;
      break;
    case Type.Uint8:
      fn = visitor.visitUint8 || visitor.visitInt;
      break;
    case Type.Uint16:
      fn = visitor.visitUint16 || visitor.visitInt;
      break;
    case Type.Uint32:
      fn = visitor.visitUint32 || visitor.visitInt;
      break;
    case Type.Uint64:
      fn = visitor.visitUint64 || visitor.visitInt;
      break;
    case Type.Float:
      fn = visitor.visitFloat;
      break;
    case Type.Float16:
      fn = visitor.visitFloat16 || visitor.visitFloat;
      break;
    case Type.Float32:
      fn = visitor.visitFloat32 || visitor.visitFloat;
      break;
    case Type.Float64:
      fn = visitor.visitFloat64 || visitor.visitFloat;
      break;
    case Type.Utf8:
      fn = visitor.visitUtf8;
      break;
    case Type.Binary:
      fn = visitor.visitBinary;
      break;
    case Type.FixedSizeBinary:
      fn = visitor.visitFixedSizeBinary;
      break;
    case Type.Date:
      fn = visitor.visitDate;
      break;
    case Type.DateDay:
      fn = visitor.visitDateDay || visitor.visitDate;
      break;
    case Type.DateMillisecond:
      fn = visitor.visitDateMillisecond || visitor.visitDate;
      break;
    case Type.Timestamp:
      fn = visitor.visitTimestamp;
      break;
    case Type.TimestampSecond:
      fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
      break;
    case Type.TimestampMillisecond:
      fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
      break;
    case Type.TimestampMicrosecond:
      fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
      break;
    case Type.TimestampNanosecond:
      fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
      break;
    case Type.Time:
      fn = visitor.visitTime;
      break;
    case Type.TimeSecond:
      fn = visitor.visitTimeSecond || visitor.visitTime;
      break;
    case Type.TimeMillisecond:
      fn = visitor.visitTimeMillisecond || visitor.visitTime;
      break;
    case Type.TimeMicrosecond:
      fn = visitor.visitTimeMicrosecond || visitor.visitTime;
      break;
    case Type.TimeNanosecond:
      fn = visitor.visitTimeNanosecond || visitor.visitTime;
      break;
    case Type.Decimal:
      fn = visitor.visitDecimal;
      break;
    case Type.List:
      fn = visitor.visitList;
      break;
    case Type.Struct:
      fn = visitor.visitStruct;
      break;
    case Type.Union:
      fn = visitor.visitUnion;
      break;
    case Type.DenseUnion:
      fn = visitor.visitDenseUnion || visitor.visitUnion;
      break;
    case Type.SparseUnion:
      fn = visitor.visitSparseUnion || visitor.visitUnion;
      break;
    case Type.Dictionary:
      fn = visitor.visitDictionary;
      break;
    case Type.Interval:
      fn = visitor.visitInterval;
      break;
    case Type.IntervalDayTime:
      fn = visitor.visitIntervalDayTime || visitor.visitInterval;
      break;
    case Type.IntervalYearMonth:
      fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
      break;
    case Type.Duration:
      fn = visitor.visitDuration;
      break;
    case Type.DurationSecond:
      fn = visitor.visitDurationSecond || visitor.visitDuration;
      break;
    case Type.DurationMillisecond:
      fn = visitor.visitDurationMillisecond || visitor.visitDuration;
      break;
    case Type.DurationMicrosecond:
      fn = visitor.visitDurationMicrosecond || visitor.visitDuration;
      break;
    case Type.DurationNanosecond:
      fn = visitor.visitDurationNanosecond || visitor.visitDuration;
      break;
    case Type.FixedSizeList:
      fn = visitor.visitFixedSizeList;
      break;
    case Type.Map:
      fn = visitor.visitMap;
      break;
  }
  if (typeof fn === "function")
    return fn;
  if (!throwIfNotFound)
    return () => null;
  throw new Error(`Unrecognized type '${Type[dtype]}'`);
}
function inferDType(type) {
  switch (type.typeId) {
    case Type.Null:
      return Type.Null;
    case Type.Int: {
      const { bitWidth, isSigned } = type;
      switch (bitWidth) {
        case 8:
          return isSigned ? Type.Int8 : Type.Uint8;
        case 16:
          return isSigned ? Type.Int16 : Type.Uint16;
        case 32:
          return isSigned ? Type.Int32 : Type.Uint32;
        case 64:
          return isSigned ? Type.Int64 : Type.Uint64;
      }
      return Type.Int;
    }
    case Type.Float:
      switch (type.precision) {
        case Precision.HALF:
          return Type.Float16;
        case Precision.SINGLE:
          return Type.Float32;
        case Precision.DOUBLE:
          return Type.Float64;
      }
      return Type.Float;
    case Type.Binary:
      return Type.Binary;
    case Type.Utf8:
      return Type.Utf8;
    case Type.Bool:
      return Type.Bool;
    case Type.Decimal:
      return Type.Decimal;
    case Type.Time:
      switch (type.unit) {
        case TimeUnit.SECOND:
          return Type.TimeSecond;
        case TimeUnit.MILLISECOND:
          return Type.TimeMillisecond;
        case TimeUnit.MICROSECOND:
          return Type.TimeMicrosecond;
        case TimeUnit.NANOSECOND:
          return Type.TimeNanosecond;
      }
      return Type.Time;
    case Type.Timestamp:
      switch (type.unit) {
        case TimeUnit.SECOND:
          return Type.TimestampSecond;
        case TimeUnit.MILLISECOND:
          return Type.TimestampMillisecond;
        case TimeUnit.MICROSECOND:
          return Type.TimestampMicrosecond;
        case TimeUnit.NANOSECOND:
          return Type.TimestampNanosecond;
      }
      return Type.Timestamp;
    case Type.Date:
      switch (type.unit) {
        case DateUnit.DAY:
          return Type.DateDay;
        case DateUnit.MILLISECOND:
          return Type.DateMillisecond;
      }
      return Type.Date;
    case Type.Interval:
      switch (type.unit) {
        case IntervalUnit.DAY_TIME:
          return Type.IntervalDayTime;
        case IntervalUnit.YEAR_MONTH:
          return Type.IntervalYearMonth;
      }
      return Type.Interval;
    case Type.Duration:
      switch (type.unit) {
        case TimeUnit.SECOND:
          return Type.DurationSecond;
        case TimeUnit.MILLISECOND:
          return Type.DurationMillisecond;
        case TimeUnit.MICROSECOND:
          return Type.DurationMicrosecond;
        case TimeUnit.NANOSECOND:
          return Type.DurationNanosecond;
      }
      return Type.Duration;
    case Type.Map:
      return Type.Map;
    case Type.List:
      return Type.List;
    case Type.Struct:
      return Type.Struct;
    case Type.Union:
      switch (type.mode) {
        case UnionMode.Dense:
          return Type.DenseUnion;
        case UnionMode.Sparse:
          return Type.SparseUnion;
      }
      return Type.Union;
    case Type.FixedSizeBinary:
      return Type.FixedSizeBinary;
    case Type.FixedSizeList:
      return Type.FixedSizeList;
    case Type.Dictionary:
      return Type.Dictionary;
  }
  throw new Error(`Unrecognized type '${Type[type.typeId]}'`);
}
Visitor.prototype.visitInt8 = null;
Visitor.prototype.visitInt16 = null;
Visitor.prototype.visitInt32 = null;
Visitor.prototype.visitInt64 = null;
Visitor.prototype.visitUint8 = null;
Visitor.prototype.visitUint16 = null;
Visitor.prototype.visitUint32 = null;
Visitor.prototype.visitUint64 = null;
Visitor.prototype.visitFloat16 = null;
Visitor.prototype.visitFloat32 = null;
Visitor.prototype.visitFloat64 = null;
Visitor.prototype.visitDateDay = null;
Visitor.prototype.visitDateMillisecond = null;
Visitor.prototype.visitTimestampSecond = null;
Visitor.prototype.visitTimestampMillisecond = null;
Visitor.prototype.visitTimestampMicrosecond = null;
Visitor.prototype.visitTimestampNanosecond = null;
Visitor.prototype.visitTimeSecond = null;
Visitor.prototype.visitTimeMillisecond = null;
Visitor.prototype.visitTimeMicrosecond = null;
Visitor.prototype.visitTimeNanosecond = null;
Visitor.prototype.visitDenseUnion = null;
Visitor.prototype.visitSparseUnion = null;
Visitor.prototype.visitIntervalDayTime = null;
Visitor.prototype.visitIntervalYearMonth = null;
Visitor.prototype.visitDuration = null;
Visitor.prototype.visitDurationSecond = null;
Visitor.prototype.visitDurationMillisecond = null;
Visitor.prototype.visitDurationMicrosecond = null;
Visitor.prototype.visitDurationNanosecond = null;

// node_modules/apache-arrow/util/math.mjs
var math_exports = {};
__export(math_exports, {
  float64ToUint16: () => float64ToUint16,
  uint16ToFloat64: () => uint16ToFloat64
});
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer);
function uint16ToFloat64(h) {
  const expo = (h & 31744) >> 10;
  const sigf = (h & 1023) / 1024;
  const sign = Math.pow(-1, (h & 32768) >> 15);
  switch (expo) {
    case 31:
      return sign * (sigf ? Number.NaN : 1 / 0);
    case 0:
      return sign * (sigf ? 6103515625e-14 * sigf : 0);
  }
  return sign * Math.pow(2, expo - 15) * (1 + sigf);
}
function float64ToUint16(d) {
  if (d !== d) {
    return 32256;
  }
  f64[0] = d;
  const sign = (u32[1] & 2147483648) >> 16 & 65535;
  let expo = u32[1] & 2146435072, sigf = 0;
  if (expo >= 1089470464) {
    if (u32[0] > 0) {
      expo = 31744;
    } else {
      expo = (expo & 2080374784) >> 16;
      sigf = (u32[1] & 1048575) >> 10;
    }
  } else if (expo <= 1056964608) {
    sigf = 1048576 + (u32[1] & 1048575);
    sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
    expo = 0;
  } else {
    expo = expo - 1056964608 >> 10;
    sigf = (u32[1] & 1048575) + 512 >> 10;
  }
  return sign | expo | sigf & 65535;
}

// node_modules/apache-arrow/visitor/set.mjs
var SetVisitor = class extends Visitor {
};
function wrapSet(fn) {
  return (data2, _1, _2) => {
    if (data2.setValid(_1, _2 != null)) {
      return fn(data2, _1, _2);
    }
  };
}
var setEpochMsToDays = (data2, index, epochMs) => {
  data2[index] = Math.trunc(epochMs / 864e5);
};
var setEpochMsToMillisecondsLong = (data2, index, epochMs) => {
  data2[index] = Math.trunc(epochMs % 4294967296);
  data2[index + 1] = Math.trunc(epochMs / 4294967296);
};
var setEpochMsToMicrosecondsLong = (data2, index, epochMs) => {
  data2[index] = Math.trunc(epochMs * 1e3 % 4294967296);
  data2[index + 1] = Math.trunc(epochMs * 1e3 / 4294967296);
};
var setEpochMsToNanosecondsLong = (data2, index, epochMs) => {
  data2[index] = Math.trunc(epochMs * 1e6 % 4294967296);
  data2[index + 1] = Math.trunc(epochMs * 1e6 / 4294967296);
};
var setVariableWidthBytes = (values2, valueOffsets, index, value) => {
  if (index + 1 < valueOffsets.length) {
    const { [index]: x, [index + 1]: y } = valueOffsets;
    values2.set(value.subarray(0, y - x), x);
  }
};
var setBool = ({ offset: offset2, values: values2 }, index, val) => {
  const idx = offset2 + index;
  val ? values2[idx >> 3] |= 1 << idx % 8 : values2[idx >> 3] &= ~(1 << idx % 8);
};
var setInt = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setFloat = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setFloat16 = ({ values: values2 }, index, value) => {
  values2[index] = float64ToUint16(value);
};
var setAnyFloat = (data2, index, value) => {
  switch (data2.type.precision) {
    case Precision.HALF:
      return setFloat16(data2, index, value);
    case Precision.SINGLE:
    case Precision.DOUBLE:
      return setFloat(data2, index, value);
  }
};
var setDateDay = ({ values: values2 }, index, value) => {
  setEpochMsToDays(values2, index, value.valueOf());
};
var setDateMillisecond = ({ values: values2 }, index, value) => {
  setEpochMsToMillisecondsLong(values2, index * 2, value.valueOf());
};
var setFixedSizeBinary = ({ stride, values: values2 }, index, value) => {
  values2.set(value.subarray(0, stride), stride * index);
};
var setBinary = ({ values: values2, valueOffsets }, index, value) => setVariableWidthBytes(values2, valueOffsets, index, value);
var setUtf8 = ({ values: values2, valueOffsets }, index, value) => {
  setVariableWidthBytes(values2, valueOffsets, index, encodeUtf8(value));
};
var setDate = (data2, index, value) => {
  data2.type.unit === DateUnit.DAY ? setDateDay(data2, index, value) : setDateMillisecond(data2, index, value);
};
var setTimestampSecond = ({ values: values2 }, index, value) => setEpochMsToMillisecondsLong(values2, index * 2, value / 1e3);
var setTimestampMillisecond = ({ values: values2 }, index, value) => setEpochMsToMillisecondsLong(values2, index * 2, value);
var setTimestampMicrosecond = ({ values: values2 }, index, value) => setEpochMsToMicrosecondsLong(values2, index * 2, value);
var setTimestampNanosecond = ({ values: values2 }, index, value) => setEpochMsToNanosecondsLong(values2, index * 2, value);
var setTimestamp = (data2, index, value) => {
  switch (data2.type.unit) {
    case TimeUnit.SECOND:
      return setTimestampSecond(data2, index, value);
    case TimeUnit.MILLISECOND:
      return setTimestampMillisecond(data2, index, value);
    case TimeUnit.MICROSECOND:
      return setTimestampMicrosecond(data2, index, value);
    case TimeUnit.NANOSECOND:
      return setTimestampNanosecond(data2, index, value);
  }
};
var setTimeSecond = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setTimeMillisecond = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setTimeMicrosecond = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setTimeNanosecond = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setTime = (data2, index, value) => {
  switch (data2.type.unit) {
    case TimeUnit.SECOND:
      return setTimeSecond(data2, index, value);
    case TimeUnit.MILLISECOND:
      return setTimeMillisecond(data2, index, value);
    case TimeUnit.MICROSECOND:
      return setTimeMicrosecond(data2, index, value);
    case TimeUnit.NANOSECOND:
      return setTimeNanosecond(data2, index, value);
  }
};
var setDecimal = ({ values: values2, stride }, index, value) => {
  values2.set(value.subarray(0, stride), stride * index);
};
var setList = (data2, index, value) => {
  const values2 = data2.children[0];
  const valueOffsets = data2.valueOffsets;
  const set = instance.getVisitFn(values2);
  if (Array.isArray(value)) {
    for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
      set(values2, itr++, value[++idx]);
    }
  } else {
    for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
      set(values2, itr++, value.get(++idx));
    }
  }
};
var setMap = (data2, index, value) => {
  const values2 = data2.children[0];
  const { valueOffsets } = data2;
  const set = instance.getVisitFn(values2);
  let { [index]: idx, [index + 1]: end } = valueOffsets;
  const entries = value instanceof Map ? value.entries() : Object.entries(value);
  for (const val of entries) {
    set(values2, idx, val);
    if (++idx >= end)
      break;
  }
};
var _setStructArrayValue = (o, v) => (set, c, _, i2) => c && set(c, o, v[i2]);
var _setStructVectorValue = (o, v) => (set, c, _, i2) => c && set(c, o, v.get(i2));
var _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));
var _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);
var setStruct = (data2, index, value) => {
  const childSetters = data2.type.children.map((f) => instance.getVisitFn(f.type));
  const set = value instanceof Map ? _setStructMapValue(index, value) : value instanceof Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
  data2.type.children.forEach((f, i2) => set(childSetters[i2], data2.children[i2], f, i2));
};
var setUnion = (data2, index, value) => {
  data2.type.mode === UnionMode.Dense ? setDenseUnion(data2, index, value) : setSparseUnion(data2, index, value);
};
var setDenseUnion = (data2, index, value) => {
  const childIndex = data2.type.typeIdToChildIndex[data2.typeIds[index]];
  const child = data2.children[childIndex];
  instance.visit(child, data2.valueOffsets[index], value);
};
var setSparseUnion = (data2, index, value) => {
  const childIndex = data2.type.typeIdToChildIndex[data2.typeIds[index]];
  const child = data2.children[childIndex];
  instance.visit(child, index, value);
};
var setDictionary = (data2, index, value) => {
  var _a5;
  (_a5 = data2.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data2.values[index], value);
};
var setIntervalValue = (data2, index, value) => {
  data2.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data2, index, value) : setIntervalYearMonth(data2, index, value);
};
var setIntervalDayTime = ({ values: values2 }, index, value) => {
  values2.set(value.subarray(0, 2), 2 * index);
};
var setIntervalYearMonth = ({ values: values2 }, index, value) => {
  values2[index] = value[0] * 12 + value[1] % 12;
};
var setDurationSecond = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setDurationMillisecond = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setDurationMicrosecond = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setDurationNanosecond = ({ values: values2 }, index, value) => {
  values2[index] = value;
};
var setDuration = (data2, index, value) => {
  switch (data2.type.unit) {
    case TimeUnit.SECOND:
      return setDurationSecond(data2, index, value);
    case TimeUnit.MILLISECOND:
      return setDurationMillisecond(data2, index, value);
    case TimeUnit.MICROSECOND:
      return setDurationMicrosecond(data2, index, value);
    case TimeUnit.NANOSECOND:
      return setDurationNanosecond(data2, index, value);
  }
};
var setFixedSizeList = (data2, index, value) => {
  const { stride } = data2;
  const child = data2.children[0];
  const set = instance.getVisitFn(child);
  if (Array.isArray(value)) {
    for (let idx = -1, offset2 = index * stride; ++idx < stride; ) {
      set(child, offset2 + idx, value[idx]);
    }
  } else {
    for (let idx = -1, offset2 = index * stride; ++idx < stride; ) {
      set(child, offset2 + idx, value.get(idx));
    }
  }
};
SetVisitor.prototype.visitBool = wrapSet(setBool);
SetVisitor.prototype.visitInt = wrapSet(setInt);
SetVisitor.prototype.visitInt8 = wrapSet(setInt);
SetVisitor.prototype.visitInt16 = wrapSet(setInt);
SetVisitor.prototype.visitInt32 = wrapSet(setInt);
SetVisitor.prototype.visitInt64 = wrapSet(setInt);
SetVisitor.prototype.visitUint8 = wrapSet(setInt);
SetVisitor.prototype.visitUint16 = wrapSet(setInt);
SetVisitor.prototype.visitUint32 = wrapSet(setInt);
SetVisitor.prototype.visitUint64 = wrapSet(setInt);
SetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);
SetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);
SetVisitor.prototype.visitFloat32 = wrapSet(setFloat);
SetVisitor.prototype.visitFloat64 = wrapSet(setFloat);
SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitBinary = wrapSet(setBinary);
SetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);
SetVisitor.prototype.visitDate = wrapSet(setDate);
SetVisitor.prototype.visitDateDay = wrapSet(setDateDay);
SetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);
SetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);
SetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);
SetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);
SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);
SetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);
SetVisitor.prototype.visitTime = wrapSet(setTime);
SetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);
SetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);
SetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);
SetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);
SetVisitor.prototype.visitDecimal = wrapSet(setDecimal);
SetVisitor.prototype.visitList = wrapSet(setList);
SetVisitor.prototype.visitStruct = wrapSet(setStruct);
SetVisitor.prototype.visitUnion = wrapSet(setUnion);
SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
SetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);
SetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);
SetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);
SetVisitor.prototype.visitDuration = wrapSet(setDuration);
SetVisitor.prototype.visitDurationSecond = wrapSet(setDurationSecond);
SetVisitor.prototype.visitDurationMillisecond = wrapSet(setDurationMillisecond);
SetVisitor.prototype.visitDurationMicrosecond = wrapSet(setDurationMicrosecond);
SetVisitor.prototype.visitDurationNanosecond = wrapSet(setDurationNanosecond);
SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
SetVisitor.prototype.visitMap = wrapSet(setMap);
var instance = new SetVisitor();

// node_modules/apache-arrow/row/struct.mjs
var kParent = Symbol.for("parent");
var kRowIndex = Symbol.for("rowIndex");
var StructRow = class {
  constructor(parent, rowIndex) {
    this[kParent] = parent;
    this[kRowIndex] = rowIndex;
    return new Proxy(this, new StructRowProxyHandler());
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const i2 = this[kRowIndex];
    const parent = this[kParent];
    const keys = parent.type.children;
    const json = {};
    for (let j = -1, n2 = keys.length; ++j < n2; ) {
      json[keys[j].name] = instance2.visit(parent.children[j], i2);
    }
    return json;
  }
  toString() {
    return `{${[...this].map(([key2, val]) => `${valueToString(key2)}: ${valueToString(val)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
  [Symbol.iterator]() {
    return new StructRowIterator(this[kParent], this[kRowIndex]);
  }
};
var StructRowIterator = class {
  constructor(data2, rowIndex) {
    this.childIndex = 0;
    this.children = data2.children;
    this.rowIndex = rowIndex;
    this.childFields = data2.type.children;
    this.numChildren = this.childFields.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const i2 = this.childIndex;
    if (i2 < this.numChildren) {
      this.childIndex = i2 + 1;
      return {
        done: false,
        value: [
          this.childFields[i2].name,
          instance2.visit(this.children[i2], this.rowIndex)
        ]
      };
    }
    return { done: true, value: null };
  }
};
Object.defineProperties(StructRow.prototype, {
  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
  [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
  [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
});
var StructRowProxyHandler = class {
  isExtensible() {
    return false;
  }
  deleteProperty() {
    return false;
  }
  preventExtensions() {
    return true;
  }
  ownKeys(row) {
    return row[kParent].type.children.map((f) => f.name);
  }
  has(row, key2) {
    return row[kParent].type.children.findIndex((f) => f.name === key2) !== -1;
  }
  getOwnPropertyDescriptor(row, key2) {
    if (row[kParent].type.children.findIndex((f) => f.name === key2) !== -1) {
      return { writable: true, enumerable: true, configurable: true };
    }
    return;
  }
  get(row, key2) {
    if (Reflect.has(row, key2)) {
      return row[key2];
    }
    const idx = row[kParent].type.children.findIndex((f) => f.name === key2);
    if (idx !== -1) {
      const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);
      Reflect.set(row, key2, val);
      return val;
    }
  }
  set(row, key2, val) {
    const idx = row[kParent].type.children.findIndex((f) => f.name === key2);
    if (idx !== -1) {
      instance.visit(row[kParent].children[idx], row[kRowIndex], val);
      return Reflect.set(row, key2, val);
    } else if (Reflect.has(row, key2) || typeof key2 === "symbol") {
      return Reflect.set(row, key2, val);
    }
    return false;
  }
};

// node_modules/apache-arrow/visitor/get.mjs
var GetVisitor = class extends Visitor {
};
function wrapGet(fn) {
  return (data2, _1) => data2.getValid(_1) ? fn(data2, _1) : null;
}
var epochDaysToMs = (data2, index) => 864e5 * data2[index];
var epochMillisecondsLongToMs = (data2, index) => 4294967296 * data2[index + 1] + (data2[index] >>> 0);
var epochMicrosecondsLongToMs = (data2, index) => 4294967296 * (data2[index + 1] / 1e3) + (data2[index] >>> 0) / 1e3;
var epochNanosecondsLongToMs = (data2, index) => 4294967296 * (data2[index + 1] / 1e6) + (data2[index] >>> 0) / 1e6;
var epochMillisecondsToDate = (epochMs) => new Date(epochMs);
var epochDaysToDate = (data2, index) => epochMillisecondsToDate(epochDaysToMs(data2, index));
var epochMillisecondsLongToDate = (data2, index) => epochMillisecondsToDate(epochMillisecondsLongToMs(data2, index));
var getNull = (_data, _index) => null;
var getVariableWidthBytes = (values2, valueOffsets, index) => {
  if (index + 1 >= valueOffsets.length) {
    return null;
  }
  const x = valueOffsets[index];
  const y = valueOffsets[index + 1];
  return values2.subarray(x, y);
};
var getBool = ({ offset: offset2, values: values2 }, index) => {
  const idx = offset2 + index;
  const byte = values2[idx >> 3];
  return (byte & 1 << idx % 8) !== 0;
};
var getDateDay = ({ values: values2 }, index) => epochDaysToDate(values2, index);
var getDateMillisecond = ({ values: values2 }, index) => epochMillisecondsLongToDate(values2, index * 2);
var getNumeric = ({ stride, values: values2 }, index) => values2[stride * index];
var getFloat16 = ({ stride, values: values2 }, index) => uint16ToFloat64(values2[stride * index]);
var getBigInts = ({ values: values2 }, index) => values2[index];
var getFixedSizeBinary = ({ stride, values: values2 }, index) => values2.subarray(stride * index, stride * (index + 1));
var getBinary = ({ values: values2, valueOffsets }, index) => getVariableWidthBytes(values2, valueOffsets, index);
var getUtf8 = ({ values: values2, valueOffsets }, index) => {
  const bytes = getVariableWidthBytes(values2, valueOffsets, index);
  return bytes !== null ? decodeUtf8(bytes) : null;
};
var getInt = ({ values: values2 }, index) => values2[index];
var getFloat = ({ type, values: values2 }, index) => type.precision !== Precision.HALF ? values2[index] : uint16ToFloat64(values2[index]);
var getDate = (data2, index) => data2.type.unit === DateUnit.DAY ? getDateDay(data2, index) : getDateMillisecond(data2, index);
var getTimestampSecond = ({ values: values2 }, index) => 1e3 * epochMillisecondsLongToMs(values2, index * 2);
var getTimestampMillisecond = ({ values: values2 }, index) => epochMillisecondsLongToMs(values2, index * 2);
var getTimestampMicrosecond = ({ values: values2 }, index) => epochMicrosecondsLongToMs(values2, index * 2);
var getTimestampNanosecond = ({ values: values2 }, index) => epochNanosecondsLongToMs(values2, index * 2);
var getTimestamp = (data2, index) => {
  switch (data2.type.unit) {
    case TimeUnit.SECOND:
      return getTimestampSecond(data2, index);
    case TimeUnit.MILLISECOND:
      return getTimestampMillisecond(data2, index);
    case TimeUnit.MICROSECOND:
      return getTimestampMicrosecond(data2, index);
    case TimeUnit.NANOSECOND:
      return getTimestampNanosecond(data2, index);
  }
};
var getTimeSecond = ({ values: values2 }, index) => values2[index];
var getTimeMillisecond = ({ values: values2 }, index) => values2[index];
var getTimeMicrosecond = ({ values: values2 }, index) => values2[index];
var getTimeNanosecond = ({ values: values2 }, index) => values2[index];
var getTime = (data2, index) => {
  switch (data2.type.unit) {
    case TimeUnit.SECOND:
      return getTimeSecond(data2, index);
    case TimeUnit.MILLISECOND:
      return getTimeMillisecond(data2, index);
    case TimeUnit.MICROSECOND:
      return getTimeMicrosecond(data2, index);
    case TimeUnit.NANOSECOND:
      return getTimeNanosecond(data2, index);
  }
};
var getDecimal = ({ values: values2, stride }, index) => BN.decimal(values2.subarray(stride * index, stride * (index + 1)));
var getList = (data2, index) => {
  const { valueOffsets, stride, children } = data2;
  const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
  const child = children[0];
  const slice = child.slice(begin, end - begin);
  return new Vector([slice]);
};
var getMap = (data2, index) => {
  const { valueOffsets, children } = data2;
  const { [index]: begin, [index + 1]: end } = valueOffsets;
  const child = children[0];
  return new MapRow(child.slice(begin, end - begin));
};
var getStruct = (data2, index) => {
  return new StructRow(data2, index);
};
var getUnion = (data2, index) => {
  return data2.type.mode === UnionMode.Dense ? getDenseUnion(data2, index) : getSparseUnion(data2, index);
};
var getDenseUnion = (data2, index) => {
  const childIndex = data2.type.typeIdToChildIndex[data2.typeIds[index]];
  const child = data2.children[childIndex];
  return instance2.visit(child, data2.valueOffsets[index]);
};
var getSparseUnion = (data2, index) => {
  const childIndex = data2.type.typeIdToChildIndex[data2.typeIds[index]];
  const child = data2.children[childIndex];
  return instance2.visit(child, index);
};
var getDictionary = (data2, index) => {
  var _a5;
  return (_a5 = data2.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data2.values[index]);
};
var getInterval = (data2, index) => data2.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data2, index) : getIntervalYearMonth(data2, index);
var getIntervalDayTime = ({ values: values2 }, index) => values2.subarray(2 * index, 2 * (index + 1));
var getIntervalYearMonth = ({ values: values2 }, index) => {
  const interval = values2[index];
  const int32s = new Int32Array(2);
  int32s[0] = Math.trunc(interval / 12);
  int32s[1] = Math.trunc(interval % 12);
  return int32s;
};
var getDurationSecond = ({ values: values2 }, index) => values2[index];
var getDurationMillisecond = ({ values: values2 }, index) => values2[index];
var getDurationMicrosecond = ({ values: values2 }, index) => values2[index];
var getDurationNanosecond = ({ values: values2 }, index) => values2[index];
var getDuration = (data2, index) => {
  switch (data2.type.unit) {
    case TimeUnit.SECOND:
      return getDurationSecond(data2, index);
    case TimeUnit.MILLISECOND:
      return getDurationMillisecond(data2, index);
    case TimeUnit.MICROSECOND:
      return getDurationMicrosecond(data2, index);
    case TimeUnit.NANOSECOND:
      return getDurationNanosecond(data2, index);
  }
};
var getFixedSizeList = (data2, index) => {
  const { stride, children } = data2;
  const child = children[0];
  const slice = child.slice(index * stride, stride);
  return new Vector([slice]);
};
GetVisitor.prototype.visitNull = wrapGet(getNull);
GetVisitor.prototype.visitBool = wrapGet(getBool);
GetVisitor.prototype.visitInt = wrapGet(getInt);
GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
GetVisitor.prototype.visitFloat = wrapGet(getFloat);
GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitBinary = wrapGet(getBinary);
GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
GetVisitor.prototype.visitDate = wrapGet(getDate);
GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
GetVisitor.prototype.visitTime = wrapGet(getTime);
GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
GetVisitor.prototype.visitList = wrapGet(getList);
GetVisitor.prototype.visitStruct = wrapGet(getStruct);
GetVisitor.prototype.visitUnion = wrapGet(getUnion);
GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
GetVisitor.prototype.visitInterval = wrapGet(getInterval);
GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
GetVisitor.prototype.visitDuration = wrapGet(getDuration);
GetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);
GetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);
GetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);
GetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);
GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
GetVisitor.prototype.visitMap = wrapGet(getMap);
var instance2 = new GetVisitor();

// node_modules/apache-arrow/row/map.mjs
var kKeys = Symbol.for("keys");
var kVals = Symbol.for("vals");
var MapRow = class {
  constructor(slice) {
    this[kKeys] = new Vector([slice.children[0]]).memoize();
    this[kVals] = slice.children[1];
    return new Proxy(this, new MapRowProxyHandler());
  }
  [Symbol.iterator]() {
    return new MapRowIterator(this[kKeys], this[kVals]);
  }
  get size() {
    return this[kKeys].length;
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const keys = this[kKeys];
    const vals = this[kVals];
    const json = {};
    for (let i2 = -1, n2 = keys.length; ++i2 < n2; ) {
      json[keys.get(i2)] = instance2.visit(vals, i2);
    }
    return json;
  }
  toString() {
    return `{${[...this].map(([key2, val]) => `${valueToString(key2)}: ${valueToString(val)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
};
var MapRowIterator = class {
  constructor(keys, vals) {
    this.keys = keys;
    this.vals = vals;
    this.keyIndex = 0;
    this.numKeys = keys.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const i2 = this.keyIndex;
    if (i2 === this.numKeys) {
      return { done: true, value: null };
    }
    this.keyIndex++;
    return {
      done: false,
      value: [
        this.keys.get(i2),
        instance2.visit(this.vals, i2)
      ]
    };
  }
};
var MapRowProxyHandler = class {
  isExtensible() {
    return false;
  }
  deleteProperty() {
    return false;
  }
  preventExtensions() {
    return true;
  }
  ownKeys(row) {
    return row[kKeys].toArray().map(String);
  }
  has(row, key2) {
    return row[kKeys].includes(key2);
  }
  getOwnPropertyDescriptor(row, key2) {
    const idx = row[kKeys].indexOf(key2);
    if (idx !== -1) {
      return { writable: true, enumerable: true, configurable: true };
    }
    return;
  }
  get(row, key2) {
    if (Reflect.has(row, key2)) {
      return row[key2];
    }
    const idx = row[kKeys].indexOf(key2);
    if (idx !== -1) {
      const val = instance2.visit(Reflect.get(row, kVals), idx);
      Reflect.set(row, key2, val);
      return val;
    }
  }
  set(row, key2, val) {
    const idx = row[kKeys].indexOf(key2);
    if (idx !== -1) {
      instance.visit(Reflect.get(row, kVals), idx, val);
      return Reflect.set(row, key2, val);
    } else if (Reflect.has(row, key2)) {
      return Reflect.set(row, key2, val);
    }
    return false;
  }
};
Object.defineProperties(MapRow.prototype, {
  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
  [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
  [kVals]: { writable: true, enumerable: false, configurable: false, value: null }
});

// node_modules/apache-arrow/util/vector.mjs
function clampIndex(source2, index, then) {
  const length = source2.length;
  const adjust = index > -1 ? index : length + index % length;
  return then ? then(source2, adjust) : adjust;
}
var tmp;
function clampRange(source2, begin, end, then) {
  const { length: len = 0 } = source2;
  let lhs = typeof begin !== "number" ? 0 : begin;
  let rhs = typeof end !== "number" ? len : end;
  lhs < 0 && (lhs = (lhs % len + len) % len);
  rhs < 0 && (rhs = (rhs % len + len) % len);
  rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
  rhs > len && (rhs = len);
  return then ? then(source2, lhs, rhs) : [lhs, rhs];
}
var isNaNFast = (value) => value !== value;
function createElementComparator(search) {
  const typeofSearch = typeof search;
  if (typeofSearch !== "object" || search === null) {
    if (isNaNFast(search)) {
      return isNaNFast;
    }
    return (value) => value === search;
  }
  if (search instanceof Date) {
    const valueOfSearch = search.valueOf();
    return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
  }
  if (ArrayBuffer.isView(search)) {
    return (value) => value ? compareArrayLike(search, value) : false;
  }
  if (search instanceof Map) {
    return createMapComparator(search);
  }
  if (Array.isArray(search)) {
    return createArrayLikeComparator(search);
  }
  if (search instanceof Vector) {
    return createVectorComparator(search);
  }
  return createObjectComparator(search, true);
}
function createArrayLikeComparator(lhs) {
  const comparators = [];
  for (let i2 = -1, n2 = lhs.length; ++i2 < n2; ) {
    comparators[i2] = createElementComparator(lhs[i2]);
  }
  return createSubElementsComparator(comparators);
}
function createMapComparator(lhs) {
  let i2 = -1;
  const comparators = [];
  for (const v of lhs.values())
    comparators[++i2] = createElementComparator(v);
  return createSubElementsComparator(comparators);
}
function createVectorComparator(lhs) {
  const comparators = [];
  for (let i2 = -1, n2 = lhs.length; ++i2 < n2; ) {
    comparators[i2] = createElementComparator(lhs.get(i2));
  }
  return createSubElementsComparator(comparators);
}
function createObjectComparator(lhs, allowEmpty = false) {
  const keys = Object.keys(lhs);
  if (!allowEmpty && keys.length === 0) {
    return () => false;
  }
  const comparators = [];
  for (let i2 = -1, n2 = keys.length; ++i2 < n2; ) {
    comparators[i2] = createElementComparator(lhs[keys[i2]]);
  }
  return createSubElementsComparator(comparators, keys);
}
function createSubElementsComparator(comparators, keys) {
  return (rhs) => {
    if (!rhs || typeof rhs !== "object") {
      return false;
    }
    switch (rhs.constructor) {
      case Array:
        return compareArray(comparators, rhs);
      case Map:
        return compareObject(comparators, rhs, rhs.keys());
      case MapRow:
      case StructRow:
      case Object:
      case void 0:
        return compareObject(comparators, rhs, keys || Object.keys(rhs));
    }
    return rhs instanceof Vector ? compareVector(comparators, rhs) : false;
  };
}
function compareArray(comparators, arr) {
  const n2 = comparators.length;
  if (arr.length !== n2) {
    return false;
  }
  for (let i2 = -1; ++i2 < n2; ) {
    if (!comparators[i2](arr[i2])) {
      return false;
    }
  }
  return true;
}
function compareVector(comparators, vec) {
  const n2 = comparators.length;
  if (vec.length !== n2) {
    return false;
  }
  for (let i2 = -1; ++i2 < n2; ) {
    if (!comparators[i2](vec.get(i2))) {
      return false;
    }
  }
  return true;
}
function compareObject(comparators, obj, keys) {
  const lKeyItr = keys[Symbol.iterator]();
  const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
  const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
  let i2 = 0;
  const n2 = comparators.length;
  let rVal = rValItr.next();
  let lKey = lKeyItr.next();
  let rKey = rKeyItr.next();
  for (; i2 < n2 && !lKey.done && !rKey.done && !rVal.done; ++i2, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
    if (lKey.value !== rKey.value || !comparators[i2](rVal.value)) {
      break;
    }
  }
  if (i2 === n2 && lKey.done && rKey.done && rVal.done) {
    return true;
  }
  lKeyItr.return && lKeyItr.return();
  rKeyItr.return && rKeyItr.return();
  rValItr.return && rValItr.return();
  return false;
}

// node_modules/apache-arrow/util/bit.mjs
var bit_exports = {};
__export(bit_exports, {
  BitIterator: () => BitIterator,
  getBit: () => getBit,
  getBool: () => getBool2,
  packBools: () => packBools,
  popcnt_array: () => popcnt_array,
  popcnt_bit_range: () => popcnt_bit_range,
  popcnt_uint32: () => popcnt_uint32,
  setBool: () => setBool2,
  truncateBitmap: () => truncateBitmap
});
function getBool2(_data, _index, byte, bit) {
  return (byte & 1 << bit) !== 0;
}
function getBit(_data, _index, byte, bit) {
  return (byte & 1 << bit) >> bit;
}
function setBool2(bytes, index, value) {
  return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
}
function truncateBitmap(offset2, length, bitmap) {
  const alignedSize = bitmap.byteLength + 7 & ~7;
  if (offset2 > 0 || bitmap.byteLength < alignedSize) {
    const bytes = new Uint8Array(alignedSize);
    bytes.set(offset2 % 8 === 0 ? bitmap.subarray(offset2 >> 3) : (
      // Otherwise iterate each bit from the offset and return a new one
      packBools(new BitIterator(bitmap, offset2, length, null, getBool2)).subarray(0, alignedSize)
    ));
    return bytes;
  }
  return bitmap;
}
function packBools(values2) {
  const xs = [];
  let i2 = 0, bit = 0, byte = 0;
  for (const value of values2) {
    value && (byte |= 1 << bit);
    if (++bit === 8) {
      xs[i2++] = byte;
      byte = bit = 0;
    }
  }
  if (i2 === 0 || bit > 0) {
    xs[i2++] = byte;
  }
  const b = new Uint8Array(xs.length + 7 & ~7);
  b.set(xs);
  return b;
}
var BitIterator = class {
  constructor(bytes, begin, length, context, get2) {
    this.bytes = bytes;
    this.length = length;
    this.context = context;
    this.get = get2;
    this.bit = begin % 8;
    this.byteIndex = begin >> 3;
    this.byte = bytes[this.byteIndex++];
    this.index = 0;
  }
  next() {
    if (this.index < this.length) {
      if (this.bit === 8) {
        this.bit = 0;
        this.byte = this.bytes[this.byteIndex++];
      }
      return {
        value: this.get(this.context, this.index++, this.byte, this.bit++)
      };
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function popcnt_bit_range(data2, lhs, rhs) {
  if (rhs - lhs <= 0) {
    return 0;
  }
  if (rhs - lhs < 8) {
    let sum2 = 0;
    for (const bit of new BitIterator(data2, lhs, rhs - lhs, data2, getBit)) {
      sum2 += bit;
    }
    return sum2;
  }
  const rhsInside = rhs >> 3 << 3;
  const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
  return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    popcnt_bit_range(data2, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
    popcnt_bit_range(data2, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
    popcnt_array(data2, lhsInside >> 3, rhsInside - lhsInside >> 3)
  );
}
function popcnt_array(arr, byteOffset, byteLength) {
  let cnt = 0, pos = Math.trunc(byteOffset);
  const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
  while (len - pos >= 4) {
    cnt += popcnt_uint32(view.getUint32(pos));
    pos += 4;
  }
  while (len - pos >= 2) {
    cnt += popcnt_uint32(view.getUint16(pos));
    pos += 2;
  }
  while (len - pos >= 1) {
    cnt += popcnt_uint32(view.getUint8(pos));
    pos += 1;
  }
  return cnt;
}
function popcnt_uint32(uint32) {
  let i2 = Math.trunc(uint32);
  i2 = i2 - (i2 >>> 1 & 1431655765);
  i2 = (i2 & 858993459) + (i2 >>> 2 & 858993459);
  return (i2 + (i2 >>> 4) & 252645135) * 16843009 >>> 24;
}

// node_modules/apache-arrow/data.mjs
var kUnknownNullCount = -1;
var Data2 = class _Data {
  get typeId() {
    return this.type.typeId;
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get buffers() {
    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
  }
  get nullable() {
    if (this._nullCount !== 0) {
      const { type } = this;
      if (DataType.isSparseUnion(type)) {
        return this.children.some((child) => child.nullable);
      } else if (DataType.isDenseUnion(type)) {
        return this.children.some((child) => child.nullable);
      }
      return this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    return true;
  }
  get byteLength() {
    let byteLength = 0;
    const { valueOffsets, values: values2, nullBitmap, typeIds } = this;
    valueOffsets && (byteLength += valueOffsets.byteLength);
    values2 && (byteLength += values2.byteLength);
    nullBitmap && (byteLength += nullBitmap.byteLength);
    typeIds && (byteLength += typeIds.byteLength);
    return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
  }
  get nullCount() {
    if (DataType.isUnion(this.type)) {
      return this.children.reduce((nullCount2, child) => nullCount2 + child.nullCount, 0);
    }
    let nullCount = this._nullCount;
    let nullBitmap;
    if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
      this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
    }
    return nullCount;
  }
  constructor(type, offset2, length, nullCount, buffers, children = [], dictionary2) {
    this.type = type;
    this.children = children;
    this.dictionary = dictionary2;
    this.offset = Math.floor(Math.max(offset2 || 0, 0));
    this.length = Math.floor(Math.max(length || 0, 0));
    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
    let buffer;
    if (buffers instanceof _Data) {
      this.stride = buffers.stride;
      this.values = buffers.values;
      this.typeIds = buffers.typeIds;
      this.nullBitmap = buffers.nullBitmap;
      this.valueOffsets = buffers.valueOffsets;
    } else {
      this.stride = strideForType(type);
      if (buffers) {
        (buffer = buffers[0]) && (this.valueOffsets = buffer);
        (buffer = buffers[1]) && (this.values = buffer);
        (buffer = buffers[2]) && (this.nullBitmap = buffer);
        (buffer = buffers[3]) && (this.typeIds = buffer);
      }
    }
  }
  getValid(index) {
    const { type } = this;
    if (DataType.isUnion(type)) {
      const union = type;
      const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
      const indexInChild = union.mode === UnionMode.Dense ? this.valueOffsets[index] : index;
      return child.getValid(indexInChild);
    }
    if (this.nullable && this.nullCount > 0) {
      const pos = this.offset + index;
      const val = this.nullBitmap[pos >> 3];
      return (val & 1 << pos % 8) !== 0;
    }
    return true;
  }
  setValid(index, value) {
    let prev;
    const { type } = this;
    if (DataType.isUnion(type)) {
      const union = type;
      const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
      const indexInChild = union.mode === UnionMode.Dense ? this.valueOffsets[index] : index;
      prev = child.getValid(indexInChild);
      child.setValid(indexInChild, value);
    } else {
      let { nullBitmap } = this;
      const { offset: offset2, length } = this;
      const idx = offset2 + index;
      const mask = 1 << idx % 8;
      const byteOffset = idx >> 3;
      if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
        nullBitmap = new Uint8Array((offset2 + length + 63 & ~63) >> 3).fill(255);
        if (this.nullCount > 0) {
          nullBitmap.set(truncateBitmap(offset2, length, this.nullBitmap), 0);
        }
        Object.assign(this, { nullBitmap, _nullCount: -1 });
      }
      const byte = nullBitmap[byteOffset];
      prev = (byte & mask) !== 0;
      value ? nullBitmap[byteOffset] = byte | mask : nullBitmap[byteOffset] = byte & ~mask;
    }
    if (prev !== !!value) {
      this._nullCount = this.nullCount + (value ? -1 : 1);
    }
    return value;
  }
  clone(type = this.type, offset2 = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
    return new _Data(type, offset2, length, nullCount, buffers, children, this.dictionary);
  }
  slice(offset2, length) {
    const { stride, typeId, children } = this;
    const nullCount = +(this._nullCount === 0) - 1;
    const childStride = typeId === 16 ? stride : 1;
    const buffers = this._sliceBuffers(offset2, length, stride, typeId);
    return this.clone(
      this.type,
      this.offset + offset2,
      length,
      nullCount,
      buffers,
      // Don't slice children if we have value offsets (the variable-width types)
      children.length === 0 || this.valueOffsets ? children : this._sliceChildren(children, childStride * offset2, childStride * length)
    );
  }
  _changeLengthAndBackfillNullBitmap(newLength) {
    if (this.typeId === Type.Null) {
      return this.clone(this.type, 0, newLength, 0);
    }
    const { length, nullCount } = this;
    const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);
    bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;
    if (nullCount > 0) {
      bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);
    }
    const buffers = this.buffers;
    buffers[BufferType.VALIDITY] = bitmap;
    return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
  }
  _sliceBuffers(offset2, length, stride, typeId) {
    let arr;
    const { buffers } = this;
    (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset2, offset2 + length));
    (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset2, offset2 + length + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
    (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset2, stride * (offset2 + length)));
    return buffers;
  }
  _sliceChildren(children, offset2, length) {
    return children.map((child) => child.slice(offset2, length));
  }
};
Data2.prototype.children = Object.freeze([]);
var MakeDataVisitor = class _MakeDataVisitor extends Visitor {
  visit(props) {
    return this.getVisitFn(props["type"]).call(this, props);
  }
  visitNull(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0, ["length"]: length = 0 } = props;
    return new Data2(type, offset2, length, length);
  }
  visitBool(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitInt(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitFloat(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitUtf8(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const data2 = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [valueOffsets, data2, nullBitmap]);
  }
  visitBinary(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const data2 = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [valueOffsets, data2, nullBitmap]);
  }
  visitFixedSizeBinary(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitDate(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitTimestamp(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitTime(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitDecimal(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitList(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0, ["child"]: child } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
  }
  visitStruct(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0, ["children"]: children = [] } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const { length = children.reduce((len, { length: length2 }) => Math.max(len, length2), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, void 0, nullBitmap], children);
  }
  visitUnion(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0, ["children"]: children = [] } = props;
    const typeIds = toArrayBufferView(type.ArrayType, props["typeIds"]);
    const { ["length"]: length = typeIds.length, ["nullCount"]: nullCount = -1 } = props;
    if (DataType.isSparseUnion(type)) {
      return new Data2(type, offset2, length, nullCount, [void 0, void 0, void 0, typeIds], children);
    }
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    return new Data2(type, offset2, length, nullCount, [valueOffsets, void 0, void 0, typeIds], children);
  }
  visitDictionary(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.indices.ArrayType, props["data"]);
    const { ["dictionary"]: dictionary2 = new Vector([new _MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
    const { ["length"]: length = data2.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap], [], dictionary2);
  }
  visitInterval(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitDuration(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data2 = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length = data2.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, data2, nullBitmap]);
  }
  visitFixedSizeList(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type.valueType }) } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const { ["length"]: length = child.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [void 0, void 0, nullBitmap], [child]);
  }
  visitMap(props) {
    const { ["type"]: type, ["offset"]: offset2 = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type.childType }) } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type, offset2, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
  }
};
var makeDataVisitor = new MakeDataVisitor();
function makeData(props) {
  return makeDataVisitor.visit(props);
}

// node_modules/apache-arrow/util/chunk.mjs
var ChunkedIterator = class {
  constructor(numChunks = 0, getChunkIterator) {
    this.numChunks = numChunks;
    this.getChunkIterator = getChunkIterator;
    this.chunkIndex = 0;
    this.chunkIterator = this.getChunkIterator(0);
  }
  next() {
    while (this.chunkIndex < this.numChunks) {
      const next = this.chunkIterator.next();
      if (!next.done) {
        return next;
      }
      if (++this.chunkIndex < this.numChunks) {
        this.chunkIterator = this.getChunkIterator(this.chunkIndex);
      }
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function computeChunkNullCounts(chunks) {
  return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
}
function computeChunkOffsets(chunks) {
  return chunks.reduce((offsets, chunk, index) => {
    offsets[index + 1] = offsets[index] + chunk.length;
    return offsets;
  }, new Uint32Array(chunks.length + 1));
}
function sliceChunks(chunks, offsets, begin, end) {
  const slices = [];
  for (let i2 = -1, n2 = chunks.length; ++i2 < n2; ) {
    const chunk = chunks[i2];
    const offset2 = offsets[i2];
    const { length } = chunk;
    if (offset2 >= end) {
      break;
    }
    if (begin >= offset2 + length) {
      continue;
    }
    if (offset2 >= begin && offset2 + length <= end) {
      slices.push(chunk);
      continue;
    }
    const from2 = Math.max(0, begin - offset2);
    const to = Math.min(end - offset2, length);
    slices.push(chunk.slice(from2, to - from2));
  }
  if (slices.length === 0) {
    slices.push(chunks[0].slice(0, 0));
  }
  return slices;
}
function binarySearch(chunks, offsets, idx, fn) {
  let lhs = 0, mid = 0, rhs = offsets.length - 1;
  do {
    if (lhs >= rhs - 1) {
      return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
    }
    mid = lhs + Math.trunc((rhs - lhs) * 0.5);
    idx < offsets[mid] ? rhs = mid : lhs = mid;
  } while (lhs < rhs);
}
function isChunkedValid(data2, index) {
  return data2.getValid(index);
}
function wrapChunkedCall1(fn) {
  function chunkedFn(chunks, i2, j) {
    return fn(chunks[i2], j);
  }
  return function(index) {
    const data2 = this.data;
    return binarySearch(data2, this._offsets, index, chunkedFn);
  };
}
function wrapChunkedCall2(fn) {
  let _2;
  function chunkedFn(chunks, i2, j) {
    return fn(chunks[i2], j, _2);
  }
  return function(index, value) {
    const data2 = this.data;
    _2 = value;
    const result = binarySearch(data2, this._offsets, index, chunkedFn);
    _2 = void 0;
    return result;
  };
}
function wrapChunkedIndexOf(indexOf) {
  let _1;
  function chunkedIndexOf(data2, chunkIndex, fromIndex) {
    let begin = fromIndex, index = 0, total = 0;
    for (let i2 = chunkIndex - 1, n2 = data2.length; ++i2 < n2; ) {
      const chunk = data2[i2];
      if (~(index = indexOf(chunk, _1, begin))) {
        return total + index;
      }
      begin = 0;
      total += chunk.length;
    }
    return -1;
  }
  return function(element, offset2) {
    _1 = element;
    const data2 = this.data;
    const result = typeof offset2 !== "number" ? chunkedIndexOf(data2, 0, 0) : binarySearch(data2, this._offsets, offset2, chunkedIndexOf);
    _1 = void 0;
    return result;
  };
}

// node_modules/apache-arrow/visitor/indexof.mjs
var IndexOfVisitor = class extends Visitor {
};
function nullIndexOf(data2, searchElement) {
  return searchElement === null && data2.length > 0 ? 0 : -1;
}
function indexOfNull(data2, fromIndex) {
  const { nullBitmap } = data2;
  if (!nullBitmap || data2.nullCount <= 0) {
    return -1;
  }
  let i2 = 0;
  for (const isValid of new BitIterator(nullBitmap, data2.offset + (fromIndex || 0), data2.length, nullBitmap, getBool2)) {
    if (!isValid) {
      return i2;
    }
    ++i2;
  }
  return -1;
}
function indexOfValue(data2, searchElement, fromIndex) {
  if (searchElement === void 0) {
    return -1;
  }
  if (searchElement === null) {
    switch (data2.typeId) {
      case Type.Union:
        break;
      case Type.Dictionary:
        break;
      default:
        return indexOfNull(data2, fromIndex);
    }
  }
  const get2 = instance2.getVisitFn(data2);
  const compare = createElementComparator(searchElement);
  for (let i2 = (fromIndex || 0) - 1, n2 = data2.length; ++i2 < n2; ) {
    if (compare(get2(data2, i2))) {
      return i2;
    }
  }
  return -1;
}
function indexOfUnion(data2, searchElement, fromIndex) {
  const get2 = instance2.getVisitFn(data2);
  const compare = createElementComparator(searchElement);
  for (let i2 = (fromIndex || 0) - 1, n2 = data2.length; ++i2 < n2; ) {
    if (compare(get2(data2, i2))) {
      return i2;
    }
  }
  return -1;
}
IndexOfVisitor.prototype.visitNull = nullIndexOf;
IndexOfVisitor.prototype.visitBool = indexOfValue;
IndexOfVisitor.prototype.visitInt = indexOfValue;
IndexOfVisitor.prototype.visitInt8 = indexOfValue;
IndexOfVisitor.prototype.visitInt16 = indexOfValue;
IndexOfVisitor.prototype.visitInt32 = indexOfValue;
IndexOfVisitor.prototype.visitInt64 = indexOfValue;
IndexOfVisitor.prototype.visitUint8 = indexOfValue;
IndexOfVisitor.prototype.visitUint16 = indexOfValue;
IndexOfVisitor.prototype.visitUint32 = indexOfValue;
IndexOfVisitor.prototype.visitUint64 = indexOfValue;
IndexOfVisitor.prototype.visitFloat = indexOfValue;
IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitBinary = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
IndexOfVisitor.prototype.visitDate = indexOfValue;
IndexOfVisitor.prototype.visitDateDay = indexOfValue;
IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitTime = indexOfValue;
IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitDecimal = indexOfValue;
IndexOfVisitor.prototype.visitList = indexOfValue;
IndexOfVisitor.prototype.visitStruct = indexOfValue;
IndexOfVisitor.prototype.visitUnion = indexOfValue;
IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitDictionary = indexOfValue;
IndexOfVisitor.prototype.visitInterval = indexOfValue;
IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
IndexOfVisitor.prototype.visitDuration = indexOfValue;
IndexOfVisitor.prototype.visitDurationSecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
IndexOfVisitor.prototype.visitMap = indexOfValue;
var instance3 = new IndexOfVisitor();

// node_modules/apache-arrow/visitor/iterator.mjs
var IteratorVisitor = class extends Visitor {
};
function vectorIterator(vector) {
  const { type } = vector;
  if (vector.nullCount === 0 && vector.stride === 1 && (type.typeId === Type.Timestamp || type instanceof Int_ && type.bitWidth !== 64 || type instanceof Time_ && type.bitWidth !== 64 || type instanceof Float && type.precision !== Precision.HALF)) {
    return new ChunkedIterator(vector.data.length, (chunkIndex) => {
      const data2 = vector.data[chunkIndex];
      return data2.values.subarray(0, data2.length)[Symbol.iterator]();
    });
  }
  let offset2 = 0;
  return new ChunkedIterator(vector.data.length, (chunkIndex) => {
    const data2 = vector.data[chunkIndex];
    const length = data2.length;
    const inner = vector.slice(offset2, offset2 + length);
    offset2 += length;
    return new VectorIterator(inner);
  });
}
var VectorIterator = class {
  constructor(vector) {
    this.vector = vector;
    this.index = 0;
  }
  next() {
    if (this.index < this.vector.length) {
      return {
        value: this.vector.get(this.index++)
      };
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
IteratorVisitor.prototype.visitNull = vectorIterator;
IteratorVisitor.prototype.visitBool = vectorIterator;
IteratorVisitor.prototype.visitInt = vectorIterator;
IteratorVisitor.prototype.visitInt8 = vectorIterator;
IteratorVisitor.prototype.visitInt16 = vectorIterator;
IteratorVisitor.prototype.visitInt32 = vectorIterator;
IteratorVisitor.prototype.visitInt64 = vectorIterator;
IteratorVisitor.prototype.visitUint8 = vectorIterator;
IteratorVisitor.prototype.visitUint16 = vectorIterator;
IteratorVisitor.prototype.visitUint32 = vectorIterator;
IteratorVisitor.prototype.visitUint64 = vectorIterator;
IteratorVisitor.prototype.visitFloat = vectorIterator;
IteratorVisitor.prototype.visitFloat16 = vectorIterator;
IteratorVisitor.prototype.visitFloat32 = vectorIterator;
IteratorVisitor.prototype.visitFloat64 = vectorIterator;
IteratorVisitor.prototype.visitUtf8 = vectorIterator;
IteratorVisitor.prototype.visitBinary = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
IteratorVisitor.prototype.visitDate = vectorIterator;
IteratorVisitor.prototype.visitDateDay = vectorIterator;
IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestamp = vectorIterator;
IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
IteratorVisitor.prototype.visitTime = vectorIterator;
IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
IteratorVisitor.prototype.visitDecimal = vectorIterator;
IteratorVisitor.prototype.visitList = vectorIterator;
IteratorVisitor.prototype.visitStruct = vectorIterator;
IteratorVisitor.prototype.visitUnion = vectorIterator;
IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
IteratorVisitor.prototype.visitDictionary = vectorIterator;
IteratorVisitor.prototype.visitInterval = vectorIterator;
IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
IteratorVisitor.prototype.visitDuration = vectorIterator;
IteratorVisitor.prototype.visitDurationSecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
IteratorVisitor.prototype.visitMap = vectorIterator;
var instance4 = new IteratorVisitor();

// node_modules/apache-arrow/visitor/bytelength.mjs
var sum = (x, y) => x + y;
var GetByteLengthVisitor = class extends Visitor {
  visitNull(____, _) {
    return 0;
  }
  visitInt(data2, _) {
    return data2.type.bitWidth / 8;
  }
  visitFloat(data2, _) {
    return data2.type.ArrayType.BYTES_PER_ELEMENT;
  }
  visitBool(____, _) {
    return 1 / 8;
  }
  visitDecimal(data2, _) {
    return data2.type.bitWidth / 8;
  }
  visitDate(data2, _) {
    return (data2.type.unit + 1) * 4;
  }
  visitTime(data2, _) {
    return data2.type.bitWidth / 8;
  }
  visitTimestamp(data2, _) {
    return data2.type.unit === TimeUnit.SECOND ? 4 : 8;
  }
  visitInterval(data2, _) {
    return (data2.type.unit + 1) * 4;
  }
  visitDuration(____, _) {
    return 8;
  }
  visitStruct(data2, i2) {
    return data2.children.reduce((total, child) => total + instance5.visit(child, i2), 0);
  }
  visitFixedSizeBinary(data2, _) {
    return data2.type.byteWidth;
  }
  visitMap(data2, i2) {
    return 8 + data2.children.reduce((total, child) => total + instance5.visit(child, i2), 0);
  }
  visitDictionary(data2, i2) {
    var _a5;
    return data2.type.indices.bitWidth / 8 + (((_a5 = data2.dictionary) === null || _a5 === void 0 ? void 0 : _a5.getByteLength(data2.values[i2])) || 0);
  }
};
var getUtf8ByteLength = ({ valueOffsets }, index) => {
  return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
};
var getBinaryByteLength = ({ valueOffsets }, index) => {
  return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
};
var getListByteLength = ({ valueOffsets, stride, children }, index) => {
  const child = children[0];
  const { [index * stride]: start } = valueOffsets;
  const { [index * stride + 1]: end } = valueOffsets;
  const visit2 = instance5.getVisitFn(child.type);
  const slice = child.slice(start, end - start);
  let size = 8;
  for (let idx = -1, len = end - start; ++idx < len; ) {
    size += visit2(slice, idx);
  }
  return size;
};
var getFixedSizeListByteLength = ({ stride, children }, index) => {
  const child = children[0];
  const slice = child.slice(index * stride, stride);
  const visit2 = instance5.getVisitFn(child.type);
  let size = 0;
  for (let idx = -1, len = slice.length; ++idx < len; ) {
    size += visit2(slice, idx);
  }
  return size;
};
var getUnionByteLength = (data2, index) => {
  return data2.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data2, index) : getSparseUnionByteLength(data2, index);
};
var getDenseUnionByteLength = ({ type, children, typeIds, valueOffsets }, index) => {
  const childIndex = type.typeIdToChildIndex[typeIds[index]];
  return 8 + instance5.visit(children[childIndex], valueOffsets[index]);
};
var getSparseUnionByteLength = ({ children }, index) => {
  return 4 + instance5.visitMany(children, children.map(() => index)).reduce(sum, 0);
};
GetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;
GetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;
GetByteLengthVisitor.prototype.visitList = getListByteLength;
GetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;
GetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;
GetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;
GetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;
var instance5 = new GetByteLengthVisitor();

// node_modules/apache-arrow/vector.mjs
var _a2;
var visitorsByTypeId = {};
var vectorPrototypesByTypeId = {};
var Vector = class _Vector {
  constructor(input) {
    var _b2, _c2, _d2;
    const data2 = input[0] instanceof _Vector ? input.flatMap((x) => x.data) : input;
    if (data2.length === 0 || data2.some((x) => !(x instanceof Data2))) {
      throw new TypeError("Vector constructor expects an Array of Data instances.");
    }
    const type = (_b2 = data2[0]) === null || _b2 === void 0 ? void 0 : _b2.type;
    switch (data2.length) {
      case 0:
        this._offsets = [0];
        break;
      case 1: {
        const { get: get2, set, indexOf, byteLength } = visitorsByTypeId[type.typeId];
        const unchunkedData = data2[0];
        this.isValid = (index) => isChunkedValid(unchunkedData, index);
        this.get = (index) => get2(unchunkedData, index);
        this.set = (index, value) => set(unchunkedData, index, value);
        this.indexOf = (index) => indexOf(unchunkedData, index);
        this.getByteLength = (index) => byteLength(unchunkedData, index);
        this._offsets = [0, unchunkedData.length];
        break;
      }
      default:
        Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
        this._offsets = computeChunkOffsets(data2);
        break;
    }
    this.data = data2;
    this.type = type;
    this.stride = strideForType(type);
    this.numChildren = (_d2 = (_c2 = type.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
    this.length = this._offsets.at(-1);
  }
  /**
   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
   */
  get byteLength() {
    return this.data.reduce((byteLength, data2) => byteLength + data2.byteLength, 0);
  }
  /**
   * The number of null elements in this Vector.
   */
  get nullCount() {
    return computeChunkNullCounts(this.data);
  }
  /**
   * The Array or TypedArray constructor used for the JS representation
   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
   */
  get ArrayType() {
    return this.type.ArrayType;
  }
  /**
   * The name that should be printed when the Vector is logged in a message.
   */
  get [Symbol.toStringTag]() {
    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
  }
  /**
   * The name of this Vector.
   */
  get VectorName() {
    return `${Type[this.type.typeId]}Vector`;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(index) {
    return false;
  }
  /**
   * Get an element value by position.
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(index) {
    return null;
  }
  /**
   * Set an element value by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(index, value) {
    return;
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(element, offset2) {
    return -1;
  }
  includes(element, offset2) {
    return this.indexOf(element, offset2) > -1;
  }
  /**
   * Get the size in bytes of an element by index.
   * @param index The index at which to get the byteLength.
   */
  // @ts-ignore
  getByteLength(index) {
    return 0;
  }
  /**
   * Iterator for the Vector's elements.
   */
  [Symbol.iterator]() {
    return instance4.visit(this);
  }
  /**
   * Combines two or more Vectors of the same type.
   * @param others Additional Vectors to add to the end of this Vector.
   */
  concat(...others) {
    return new _Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
  }
  /**
   * Return a zero-copy sub-section of this Vector.
   * @param start The beginning of the specified portion of the Vector.
   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
   */
  slice(begin, end) {
    return new _Vector(clampRange(this, begin, end, ({ data: data2, _offsets }, begin2, end2) => sliceChunks(data2, _offsets, begin2, end2)));
  }
  toJSON() {
    return [...this];
  }
  /**
   * Return a JavaScript Array or TypedArray of the Vector's elements.
   *
   * @note If this Vector contains a single Data chunk and the Vector's type is a
   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
   *  method returns a zero-copy slice of the underlying TypedArray values. If there's
   *  more than one chunk, the resulting TypedArray will be a copy of the data from each
   *  chunk's underlying TypedArray values.
   *
   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
   */
  toArray() {
    const { type, data: data2, length, stride, ArrayType } = this;
    switch (type.typeId) {
      case Type.Int:
      case Type.Float:
      case Type.Decimal:
      case Type.Time:
      case Type.Timestamp:
        switch (data2.length) {
          case 0:
            return new ArrayType();
          case 1:
            return data2[0].values.subarray(0, length * stride);
          default:
            return data2.reduce((memo, { values: values2, length: chunk_length }) => {
              memo.array.set(values2.subarray(0, chunk_length * stride), memo.offset);
              memo.offset += chunk_length * stride;
              return memo;
            }, { array: new ArrayType(length * stride), offset: 0 }).array;
        }
    }
    return [...this];
  }
  /**
   * Returns a string representation of the Vector.
   *
   * @returns A string representation of the Vector.
   */
  toString() {
    return `[${[...this].join(",")}]`;
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(name2) {
    var _b2;
    return this.getChildAt((_b2 = this.type.children) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name2));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(index) {
    if (index > -1 && index < this.numChildren) {
      return new _Vector(this.data.map(({ children }) => children[index]));
    }
    return null;
  }
  get isMemoized() {
    if (DataType.isDictionary(this.type)) {
      return this.data[0].dictionary.isMemoized;
    }
    return false;
  }
  /**
   * Adds memoization to the Vector's {@link get} method. For dictionary
   * vectors, this method return a vector that memoizes only the dictionary
   * values.
   *
   * Memoization is very useful when decoding a value is expensive such as
   * Uft8. The memoization creates a cache of the size of the Vector and
   * therfore increases memory usage.
   *
   * @returns A new vector that memoizes calls to {@link get}.
   */
  memoize() {
    if (DataType.isDictionary(this.type)) {
      const dictionary2 = new MemoizedVector(this.data[0].dictionary);
      const newData = this.data.map((data2) => {
        const cloned = data2.clone();
        cloned.dictionary = dictionary2;
        return cloned;
      });
      return new _Vector(newData);
    }
    return new MemoizedVector(this);
  }
  /**
   * Returns a vector without memoization of the {@link get} method. If this
   * vector is not memoized, this method returns this vector.
   *
   * @returns A a vector without memoization.
   */
  unmemoize() {
    if (DataType.isDictionary(this.type) && this.isMemoized) {
      const dictionary2 = this.data[0].dictionary.unmemoize();
      const newData = this.data.map((data2) => {
        const newData2 = data2.clone();
        newData2.dictionary = dictionary2;
        return newData2;
      });
      return new _Vector(newData);
    }
    return this;
  }
};
_a2 = Symbol.toStringTag;
Vector[_a2] = ((proto2) => {
  proto2.type = DataType.prototype;
  proto2.data = [];
  proto2.length = 0;
  proto2.stride = 1;
  proto2.numChildren = 0;
  proto2._offsets = new Uint32Array([0]);
  proto2[Symbol.isConcatSpreadable] = true;
  const typeIds = Object.keys(Type).map((T) => Type[T]).filter((T) => typeof T === "number" && T !== Type.NONE);
  for (const typeId of typeIds) {
    const get2 = instance2.getVisitFnByTypeId(typeId);
    const set = instance.getVisitFnByTypeId(typeId);
    const indexOf = instance3.getVisitFnByTypeId(typeId);
    const byteLength = instance5.getVisitFnByTypeId(typeId);
    visitorsByTypeId[typeId] = { get: get2, set, indexOf, byteLength };
    vectorPrototypesByTypeId[typeId] = Object.create(proto2, {
      ["isValid"]: { value: wrapChunkedCall1(isChunkedValid) },
      ["get"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },
      ["set"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },
      ["indexOf"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) },
      ["getByteLength"]: { value: wrapChunkedCall1(instance5.getVisitFnByTypeId(typeId)) }
    });
  }
  return "Vector";
})(Vector.prototype);
var MemoizedVector = class _MemoizedVector extends Vector {
  constructor(vector) {
    super(vector.data);
    const get2 = this.get;
    const set = this.set;
    const slice = this.slice;
    const cache = new Array(this.length);
    Object.defineProperty(this, "get", {
      value(index) {
        const cachedValue = cache[index];
        if (cachedValue !== void 0) {
          return cachedValue;
        }
        const value = get2.call(this, index);
        cache[index] = value;
        return value;
      }
    });
    Object.defineProperty(this, "set", {
      value(index, value) {
        set.call(this, index, value);
        cache[index] = value;
      }
    });
    Object.defineProperty(this, "slice", {
      value: (begin, end) => new _MemoizedVector(slice.call(this, begin, end))
    });
    Object.defineProperty(this, "isMemoized", { value: true });
    Object.defineProperty(this, "unmemoize", {
      value: () => new Vector(this.data)
    });
    Object.defineProperty(this, "memoize", {
      value: () => this
    });
  }
};

// node_modules/apache-arrow/builder/valid.mjs
function createIsValidFunction(nullValues) {
  if (!nullValues || nullValues.length <= 0) {
    return function isValid(value) {
      return true;
    };
  }
  let fnBody = "";
  const noNaNs = nullValues.filter((x) => x === x);
  if (noNaNs.length > 0) {
    fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
  }
  if (nullValues.length !== noNaNs.length) {
    fnBody = `if (x !== x) return false;
${fnBody}`;
  }
  return new Function(`x`, `${fnBody}
return true;`);
}
function valueToCase(x) {
  if (typeof x !== "bigint") {
    return valueToString(x);
  }
  return `${valueToString(x)}n`;
}

// node_modules/apache-arrow/builder/buffer.mjs
var roundLengthUpToNearest64Bytes = (len, BPE) => (Math.ceil(len) * BPE + 63 & ~63 || 64) / BPE;
var sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);
var BufferBuilder = class {
  constructor(buffer, stride = 1) {
    this.buffer = buffer;
    this.stride = stride;
    this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
    this.ArrayType = buffer.constructor;
    this._resize(this.length = Math.ceil(buffer.length / stride));
  }
  get byteLength() {
    return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
  }
  get reservedLength() {
    return this.buffer.length / this.stride;
  }
  get reservedByteLength() {
    return this.buffer.byteLength;
  }
  // @ts-ignore
  set(index, value) {
    return this;
  }
  append(value) {
    return this.set(this.length, value);
  }
  reserve(extra) {
    if (extra > 0) {
      this.length += extra;
      const stride = this.stride;
      const length = this.length * stride;
      const reserved = this.buffer.length;
      if (length >= reserved) {
        this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
      }
    }
    return this;
  }
  flush(length = this.length) {
    length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
    const array3 = sliceOrExtendArray(this.buffer, length);
    this.clear();
    return array3;
  }
  clear() {
    this.length = 0;
    this._resize(0);
    return this;
  }
  _resize(newLength) {
    return this.buffer = memcpy(new this.ArrayType(newLength), this.buffer);
  }
};
BufferBuilder.prototype.offset = 0;
var DataBufferBuilder = class extends BufferBuilder {
  last() {
    return this.get(this.length - 1);
  }
  get(index) {
    return this.buffer[index];
  }
  set(index, value) {
    this.reserve(index - this.length + 1);
    this.buffer[index * this.stride] = value;
    return this;
  }
};
var BitmapBufferBuilder = class extends DataBufferBuilder {
  constructor(data2 = new Uint8Array(0)) {
    super(data2, 1 / 8);
    this.numValid = 0;
  }
  get numInvalid() {
    return this.length - this.numValid;
  }
  get(idx) {
    return this.buffer[idx >> 3] >> idx % 8 & 1;
  }
  set(idx, val) {
    const { buffer } = this.reserve(idx - this.length + 1);
    const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
    val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
    return this;
  }
  clear() {
    this.numValid = 0;
    return super.clear();
  }
};
var OffsetsBufferBuilder = class extends DataBufferBuilder {
  constructor(data2 = new Int32Array(1)) {
    super(data2, 1);
  }
  append(value) {
    return this.set(this.length - 1, value);
  }
  set(index, value) {
    const offset2 = this.length - 1;
    const buffer = this.reserve(index - offset2 + 1).buffer;
    if (offset2 < index++) {
      buffer.fill(buffer[offset2], offset2, index);
    }
    buffer[index] = buffer[index - 1] + value;
    return this;
  }
  flush(length = this.length - 1) {
    if (length > this.length) {
      this.set(length - 1, 0);
    }
    return super.flush(length + 1);
  }
};

// node_modules/apache-arrow/builder.mjs
var Builder = class {
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  // @ts-ignore
  static throughDOM(options) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /**
   * Construct a builder with the given Arrow DataType with optional null values,
   * which will be interpreted as "null" when set or appended to the `Builder`.
   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
   */
  constructor({ "type": type, "nullValues": nulls }) {
    this.length = 0;
    this.finished = false;
    this.type = type;
    this.children = [];
    this.nullValues = nulls;
    this.stride = strideForType(type);
    this._nulls = new BitmapBufferBuilder();
    if (nulls && nulls.length > 0) {
      this._isValid = createIsValidFunction(nulls);
    }
  }
  /**
   * Flush the `Builder` and return a `Vector<T>`.
   * @returns {Vector<T>} A `Vector<T>` of the flushed values.
   */
  toVector() {
    return new Vector([this.flush()]);
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get nullCount() {
    return this._nulls.numInvalid;
  }
  get numChildren() {
    return this.children.length;
  }
  /**
   * @returns The aggregate length (in bytes) of the values that have been written.
   */
  get byteLength() {
    let size = 0;
    const { _offsets, _values, _nulls, _typeIds, children } = this;
    _offsets && (size += _offsets.byteLength);
    _values && (size += _values.byteLength);
    _nulls && (size += _nulls.byteLength);
    _typeIds && (size += _typeIds.byteLength);
    return children.reduce((size2, child) => size2 + child.byteLength, size);
  }
  /**
   * @returns The aggregate number of rows that have been reserved to write new values.
   */
  get reservedLength() {
    return this._nulls.reservedLength;
  }
  /**
   * @returns The aggregate length (in bytes) that has been reserved to write new values.
   */
  get reservedByteLength() {
    let size = 0;
    this._offsets && (size += this._offsets.reservedByteLength);
    this._values && (size += this._values.reservedByteLength);
    this._nulls && (size += this._nulls.reservedByteLength);
    this._typeIds && (size += this._typeIds.reservedByteLength);
    return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
  }
  get valueOffsets() {
    return this._offsets ? this._offsets.buffer : null;
  }
  get values() {
    return this._values ? this._values.buffer : null;
  }
  get nullBitmap() {
    return this._nulls ? this._nulls.buffer : null;
  }
  get typeIds() {
    return this._typeIds ? this._typeIds.buffer : null;
  }
  /**
   * Appends a value (or null) to this `Builder`.
   * This is equivalent to `builder.set(builder.length, value)`.
   * @param {T['TValue'] | TNull } value The value to append.
   */
  append(value) {
    return this.set(this.length, value);
  }
  /**
   * Validates whether a value is valid (true), or null (false)
   * @param {T['TValue'] | TNull } value The value to compare against null the value representations
   */
  isValid(value) {
    return this._isValid(value);
  }
  /**
   * Write a value (or null-value sentinel) at the supplied index.
   * If the value matches one of the null-value representations, a 1-bit is
   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
   * the null `BitmapBufferBuilder`, and the value is passed to
   * `Builder.prototype.setValue()`.
   * @param {number} index The index of the value to write.
   * @param {T['TValue'] | TNull } value The value to write at the supplied index.
   * @returns {this} The updated `Builder` instance.
   */
  set(index, value) {
    if (this.setValid(index, this.isValid(value))) {
      this.setValue(index, value);
    }
    return this;
  }
  /**
   * Write a value to the underlying buffers at the supplied index, bypassing
   * the null-value check. This is a low-level method that
   * @param {number} index
   * @param {T['TValue'] | TNull } value
   */
  setValue(index, value) {
    this._setValue(this, index, value);
  }
  setValid(index, valid) {
    this.length = this._nulls.set(index, +valid).length;
    return valid;
  }
  // @ts-ignore
  addChild(child, name2 = `${this.numChildren}`) {
    throw new Error(`Cannot append children to non-nested type "${this.type}"`);
  }
  /**
   * Retrieve the child `Builder` at the supplied `index`, or null if no child
   * exists at that index.
   * @param {number} index The index of the child `Builder` to retrieve.
   * @returns {Builder | null} The child Builder at the supplied index or null.
   */
  getChildAt(index) {
    return this.children[index] || null;
  }
  /**
   * Commit all the values that have been written to their underlying
   * ArrayBuffers, including any child Builders if applicable, and reset
   * the internal `Builder` state.
   * @returns A `Data<T>` of the buffers and children representing the values written.
   */
  flush() {
    let data2;
    let typeIds;
    let nullBitmap;
    let valueOffsets;
    const { type, length, nullCount, _typeIds, _offsets, _values, _nulls } = this;
    if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {
      valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
    } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {
      data2 = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
    } else {
      data2 = _values === null || _values === void 0 ? void 0 : _values.flush(length);
    }
    if (nullCount > 0) {
      nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
    }
    const children = this.children.map((child) => child.flush());
    this.clear();
    return makeData({
      type,
      length,
      nullCount,
      children,
      "child": children[0],
      data: data2,
      typeIds,
      nullBitmap,
      valueOffsets
    });
  }
  /**
   * Finalize this `Builder`, and child builders if applicable.
   * @returns {this} The finalized `Builder` instance.
   */
  finish() {
    this.finished = true;
    for (const child of this.children)
      child.finish();
    return this;
  }
  /**
   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
   * @returns {this} The cleared `Builder` instance.
   */
  clear() {
    var _a5, _b2, _c2, _d2;
    this.length = 0;
    (_a5 = this._nulls) === null || _a5 === void 0 ? void 0 : _a5.clear();
    (_b2 = this._values) === null || _b2 === void 0 ? void 0 : _b2.clear();
    (_c2 = this._offsets) === null || _c2 === void 0 ? void 0 : _c2.clear();
    (_d2 = this._typeIds) === null || _d2 === void 0 ? void 0 : _d2.clear();
    for (const child of this.children)
      child.clear();
    return this;
  }
};
Builder.prototype.length = 1;
Builder.prototype.stride = 1;
Builder.prototype.children = null;
Builder.prototype.finished = false;
Builder.prototype.nullValues = null;
Builder.prototype._isValid = () => true;
var FixedWidthBuilder = class extends Builder {
  constructor(opts) {
    super(opts);
    this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);
  }
  setValue(index, value) {
    const values2 = this._values;
    values2.reserve(index - values2.length + 1);
    return super.setValue(index, value);
  }
};
var VariableWidthBuilder = class extends Builder {
  constructor(opts) {
    super(opts);
    this._pendingLength = 0;
    this._offsets = new OffsetsBufferBuilder();
  }
  setValue(index, value) {
    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
    const current2 = pending.get(index);
    current2 && (this._pendingLength -= current2.length);
    this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;
    pending.set(index, value);
  }
  setValid(index, isValid) {
    if (!super.setValid(index, isValid)) {
      (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index, void 0);
      return false;
    }
    return true;
  }
  clear() {
    this._pendingLength = 0;
    this._pending = void 0;
    return super.clear();
  }
  flush() {
    this._flush();
    return super.flush();
  }
  finish() {
    this._flush();
    return super.finish();
  }
  _flush() {
    const pending = this._pending;
    const pendingLength = this._pendingLength;
    this._pendingLength = 0;
    this._pending = void 0;
    if (pending && pending.size > 0) {
      this._flushPending(pending, pendingLength);
    }
    return this;
  }
};

// node_modules/apache-arrow/fb/block.mjs
var Block = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  /**
   * Index to the start of the RecordBlock (note this is past the Message header)
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * Length of the metadata
   */
  metaDataLength() {
    return this.bb.readInt32(this.bb_pos + 8);
  }
  /**
   * Length of the data (this is aligned so there can be a gap between this and
   * the metadata).
   */
  bodyLength() {
    return this.bb.readInt64(this.bb_pos + 16);
  }
  static sizeOf() {
    return 24;
  }
  static createBlock(builder, offset2, metaDataLength, bodyLength) {
    builder.prep(8, 24);
    builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));
    builder.pad(4);
    builder.writeInt32(metaDataLength);
    builder.writeInt64(BigInt(offset2 !== null && offset2 !== void 0 ? offset2 : 0));
    return builder.offset();
  }
};

// node_modules/flatbuffers/mjs/constants.js
var SIZEOF_SHORT = 2;
var SIZEOF_INT = 4;
var FILE_IDENTIFIER_LENGTH = 4;
var SIZE_PREFIX_LENGTH = 4;

// node_modules/flatbuffers/mjs/utils.js
var int32 = new Int32Array(2);
var float32 = new Float32Array(int32.buffer);
var float64 = new Float64Array(int32.buffer);
var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

// node_modules/flatbuffers/mjs/encoding.js
var Encoding;
(function(Encoding2) {
  Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));

// node_modules/flatbuffers/mjs/byte-buffer.js
var ByteBuffer = class _ByteBuffer {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
    this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(byte_size) {
    return new _ByteBuffer(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(position) {
    this.position_ = position;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset2) {
    return this.readUint8(offset2) << 24 >> 24;
  }
  readUint8(offset2) {
    return this.bytes_[offset2];
  }
  readInt16(offset2) {
    return this.readUint16(offset2) << 16 >> 16;
  }
  readUint16(offset2) {
    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8;
  }
  readInt32(offset2) {
    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8 | this.bytes_[offset2 + 2] << 16 | this.bytes_[offset2 + 3] << 24;
  }
  readUint32(offset2) {
    return this.readInt32(offset2) >>> 0;
  }
  readInt64(offset2) {
    return BigInt.asIntN(64, BigInt(this.readUint32(offset2)) + (BigInt(this.readUint32(offset2 + 4)) << BigInt(32)));
  }
  readUint64(offset2) {
    return BigInt.asUintN(64, BigInt(this.readUint32(offset2)) + (BigInt(this.readUint32(offset2 + 4)) << BigInt(32)));
  }
  readFloat32(offset2) {
    int32[0] = this.readInt32(offset2);
    return float32[0];
  }
  readFloat64(offset2) {
    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset2);
    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset2 + 4);
    return float64[0];
  }
  writeInt8(offset2, value) {
    this.bytes_[offset2] = value;
  }
  writeUint8(offset2, value) {
    this.bytes_[offset2] = value;
  }
  writeInt16(offset2, value) {
    this.bytes_[offset2] = value;
    this.bytes_[offset2 + 1] = value >> 8;
  }
  writeUint16(offset2, value) {
    this.bytes_[offset2] = value;
    this.bytes_[offset2 + 1] = value >> 8;
  }
  writeInt32(offset2, value) {
    this.bytes_[offset2] = value;
    this.bytes_[offset2 + 1] = value >> 8;
    this.bytes_[offset2 + 2] = value >> 16;
    this.bytes_[offset2 + 3] = value >> 24;
  }
  writeUint32(offset2, value) {
    this.bytes_[offset2] = value;
    this.bytes_[offset2 + 1] = value >> 8;
    this.bytes_[offset2 + 2] = value >> 16;
    this.bytes_[offset2 + 3] = value >> 24;
  }
  writeInt64(offset2, value) {
    this.writeInt32(offset2, Number(BigInt.asIntN(32, value)));
    this.writeInt32(offset2 + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
  }
  writeUint64(offset2, value) {
    this.writeUint32(offset2, Number(BigInt.asUintN(32, value)));
    this.writeUint32(offset2 + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
  }
  writeFloat32(offset2, value) {
    float32[0] = value;
    this.writeInt32(offset2, int32[0]);
  }
  writeFloat64(offset2, value) {
    float64[0] = value;
    this.writeInt32(offset2, int32[isLittleEndian ? 0 : 1]);
    this.writeInt32(offset2 + 4, int32[isLittleEndian ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    }
    let result = "";
    for (let i2 = 0; i2 < FILE_IDENTIFIER_LENGTH; i2++) {
      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i2));
    }
    return result;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t2, offset2) {
    t2.bb_pos = offset2 + this.readInt32(offset2);
    t2.bb = this;
    return t2;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(offset2, opt_encoding) {
    offset2 += this.readInt32(offset2);
    const length = this.readInt32(offset2);
    offset2 += SIZEOF_INT;
    const utf8bytes = this.bytes_.subarray(offset2, offset2 + length);
    if (opt_encoding === Encoding.UTF8_BYTES)
      return utf8bytes;
    else
      return this.text_decoder_.decode(utf8bytes);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(o, offset2) {
    if (typeof o === "string") {
      return this.__string(offset2);
    }
    return this.__union(o, offset2);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(offset2) {
    return offset2 + this.readInt32(offset2);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(offset2) {
    return offset2 + this.readInt32(offset2) + SIZEOF_INT;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(offset2) {
    return this.readInt32(offset2 + this.readInt32(offset2));
  }
  __has_identifier(ident) {
    if (ident.length != FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
    }
    for (let i2 = 0; i2 < FILE_IDENTIFIER_LENGTH; i2++) {
      if (ident.charCodeAt(i2) != this.readInt8(this.position() + SIZEOF_INT + i2)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i2 = 0; i2 < listLength; ++i2) {
      const val = listAccessor(i2);
      if (val !== null) {
        ret.push(val);
      }
    }
    return ret;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i2 = 0; i2 < listLength; ++i2) {
      const val = listAccessor(i2);
      if (val !== null) {
        ret.push(val.unpack());
      }
    }
    return ret;
  }
};

// node_modules/flatbuffers/mjs/builder.js
var Builder2 = class _Builder {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(opt_initial_size) {
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
    this.text_encoder = new TextEncoder();
    let initial_size;
    if (!opt_initial_size) {
      initial_size = 1024;
    } else {
      initial_size = opt_initial_size;
    }
    this.bb = ByteBuffer.allocate(initial_size);
    this.space = initial_size;
  }
  clear() {
    this.bb.clear();
    this.space = this.bb.capacity();
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(forceDefaults) {
    this.force_defaults = forceDefaults;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(size, additional_bytes) {
    if (size > this.minalign) {
      this.minalign = size;
    }
    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
    while (this.space < align_size + size + additional_bytes) {
      const old_buf_size = this.bb.capacity();
      this.bb = _Builder.growByteBuffer(this.bb);
      this.space += this.bb.capacity() - old_buf_size;
    }
    this.pad(align_size);
  }
  pad(byte_size) {
    for (let i2 = 0; i2 < byte_size; i2++) {
      this.bb.writeInt8(--this.space, 0);
    }
  }
  writeInt8(value) {
    this.bb.writeInt8(this.space -= 1, value);
  }
  writeInt16(value) {
    this.bb.writeInt16(this.space -= 2, value);
  }
  writeInt32(value) {
    this.bb.writeInt32(this.space -= 4, value);
  }
  writeInt64(value) {
    this.bb.writeInt64(this.space -= 8, value);
  }
  writeFloat32(value) {
    this.bb.writeFloat32(this.space -= 4, value);
  }
  writeFloat64(value) {
    this.bb.writeFloat64(this.space -= 8, value);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the buffer.
   */
  addInt8(value) {
    this.prep(1, 0);
    this.writeInt8(value);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the buffer.
   */
  addInt16(value) {
    this.prep(2, 0);
    this.writeInt16(value);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the buffer.
   */
  addInt32(value) {
    this.prep(4, 0);
    this.writeInt32(value);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the buffer.
   */
  addInt64(value) {
    this.prep(8, 0);
    this.writeInt64(value);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the buffer.
   */
  addFloat32(value) {
    this.prep(4, 0);
    this.writeFloat32(value);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the buffer.
   */
  addFloat64(value) {
    this.prep(8, 0);
    this.writeFloat64(value);
  }
  addFieldInt8(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt8(value);
      this.slot(voffset);
    }
  }
  addFieldInt16(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt16(value);
      this.slot(voffset);
    }
  }
  addFieldInt32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt32(value);
      this.slot(voffset);
    }
  }
  addFieldInt64(voffset, value, defaultValue) {
    if (this.force_defaults || value !== defaultValue) {
      this.addInt64(value);
      this.slot(voffset);
    }
  }
  addFieldFloat32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat32(value);
      this.slot(voffset);
    }
  }
  addFieldFloat64(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat64(value);
      this.slot(voffset);
    }
  }
  addFieldOffset(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addOffset(value);
      this.slot(voffset);
    }
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(voffset, value, defaultValue) {
    if (value != defaultValue) {
      this.nested(value);
      this.slot(voffset);
    }
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(obj) {
    if (obj != this.offset()) {
      throw new TypeError("FlatBuffers: struct must be serialized inline.");
    }
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested) {
      throw new TypeError("FlatBuffers: object serialization must not be nested.");
    }
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(voffset) {
    if (this.vtable !== null)
      this.vtable[voffset] = this.offset();
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(bb) {
    const old_buf_size = bb.capacity();
    if (old_buf_size & 3221225472) {
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    }
    const new_buf_size = old_buf_size << 1;
    const nbb = ByteBuffer.allocate(new_buf_size);
    nbb.setPosition(new_buf_size - old_buf_size);
    nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
    return nbb;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(offset2) {
    this.prep(SIZEOF_INT, 0);
    this.writeInt32(this.offset() - offset2 + SIZEOF_INT);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(numfields) {
    this.notNested();
    if (this.vtable == null) {
      this.vtable = [];
    }
    this.vtable_in_use = numfields;
    for (let i2 = 0; i2 < numfields; i2++) {
      this.vtable[i2] = 0;
    }
    this.isNested = true;
    this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested) {
      throw new Error("FlatBuffers: endObject called without startObject");
    }
    this.addInt32(0);
    const vtableloc = this.offset();
    let i2 = this.vtable_in_use - 1;
    for (; i2 >= 0 && this.vtable[i2] == 0; i2--) {
    }
    const trimmed_size = i2 + 1;
    for (; i2 >= 0; i2--) {
      this.addInt16(this.vtable[i2] != 0 ? vtableloc - this.vtable[i2] : 0);
    }
    const standard_fields = 2;
    this.addInt16(vtableloc - this.object_start);
    const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
    this.addInt16(len);
    let existing_vtable = 0;
    const vt1 = this.space;
    outer_loop:
      for (i2 = 0; i2 < this.vtables.length; i2++) {
        const vt2 = this.bb.capacity() - this.vtables[i2];
        if (len == this.bb.readInt16(vt2)) {
          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {
            if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
              continue outer_loop;
            }
          }
          existing_vtable = this.vtables[i2];
          break;
        }
      }
    if (existing_vtable) {
      this.space = this.bb.capacity() - vtableloc;
      this.bb.writeInt32(this.space, existing_vtable - vtableloc);
    } else {
      this.vtables.push(this.offset());
      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
    }
    this.isNested = false;
    return vtableloc;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(root_table, opt_file_identifier, opt_size_prefix) {
    const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
    if (opt_file_identifier) {
      const file_identifier = opt_file_identifier;
      this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
      if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
        throw new TypeError("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i2 = FILE_IDENTIFIER_LENGTH - 1; i2 >= 0; i2--) {
        this.writeInt8(file_identifier.charCodeAt(i2));
      }
    }
    this.prep(this.minalign, SIZEOF_INT + size_prefix);
    this.addOffset(root_table);
    if (size_prefix) {
      this.addInt32(this.bb.capacity() - this.space);
    }
    this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(root_table, opt_file_identifier) {
    this.finish(root_table, opt_file_identifier, true);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(table3, field) {
    const table_start = this.bb.capacity() - table3;
    const vtable_start = table_start - this.bb.readInt32(table_start);
    const ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;
    if (!ok) {
      throw new TypeError("FlatBuffers: field " + field + " must be set");
    }
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(elem_size, num_elems, alignment) {
    this.notNested();
    this.vector_num_elems = num_elems;
    this.prep(SIZEOF_INT, elem_size * num_elems);
    this.prep(alignment, elem_size * num_elems);
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    this.writeInt32(this.vector_num_elems);
    return this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(s) {
    if (!s) {
      return 0;
    }
    if (!this.string_maps) {
      this.string_maps = /* @__PURE__ */ new Map();
    }
    if (this.string_maps.has(s)) {
      return this.string_maps.get(s);
    }
    const offset2 = this.createString(s);
    this.string_maps.set(s, offset2);
    return offset2;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(s) {
    if (s === null || s === void 0) {
      return 0;
    }
    let utf8;
    if (s instanceof Uint8Array) {
      utf8 = s;
    } else {
      utf8 = this.text_encoder.encode(s);
    }
    this.addInt8(0);
    this.startVector(1, utf8.length, 1);
    this.bb.setPosition(this.space -= utf8.length);
    for (let i2 = 0, offset2 = this.space, bytes = this.bb.bytes(); i2 < utf8.length; i2++) {
      bytes[offset2++] = utf8[i2];
    }
    return this.endVector();
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(obj) {
    if (obj === null) {
      return 0;
    }
    if (typeof obj === "string") {
      return this.createString(obj);
    } else {
      return obj.pack(this);
    }
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(list3) {
    const ret = [];
    for (let i2 = 0; i2 < list3.length; ++i2) {
      const val = list3[i2];
      if (val !== null) {
        ret.push(this.createObjectOffset(val));
      } else {
        throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
      }
    }
    return ret;
  }
  createStructOffsetList(list3, startFunc) {
    startFunc(this, list3.length);
    this.createObjectOffsetList(list3.slice().reverse());
    return this.endVector();
  }
};

// node_modules/apache-arrow/fb/key-value.mjs
var KeyValue = class _KeyValue {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsKeyValue(bb, obj) {
    return (obj || new _KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsKeyValue(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  key(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  value(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  static startKeyValue(builder) {
    builder.startObject(2);
  }
  static addKey(builder, keyOffset) {
    builder.addFieldOffset(0, keyOffset, 0);
  }
  static addValue(builder, valueOffset) {
    builder.addFieldOffset(1, valueOffset, 0);
  }
  static endKeyValue(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createKeyValue(builder, keyOffset, valueOffset) {
    _KeyValue.startKeyValue(builder);
    _KeyValue.addKey(builder, keyOffset);
    _KeyValue.addValue(builder, valueOffset);
    return _KeyValue.endKeyValue(builder);
  }
};

// node_modules/apache-arrow/fb/metadata-version.mjs
var MetadataVersion2;
(function(MetadataVersion3) {
  MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
  MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
  MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
  MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
  MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
})(MetadataVersion2 || (MetadataVersion2 = {}));

// node_modules/apache-arrow/fb/endianness.mjs
var Endianness;
(function(Endianness2) {
  Endianness2[Endianness2["Little"] = 0] = "Little";
  Endianness2[Endianness2["Big"] = 1] = "Big";
})(Endianness || (Endianness = {}));

// node_modules/apache-arrow/fb/dictionary-kind.mjs
var DictionaryKind;
(function(DictionaryKind2) {
  DictionaryKind2[DictionaryKind2["DenseArray"] = 0] = "DenseArray";
})(DictionaryKind || (DictionaryKind = {}));

// node_modules/apache-arrow/fb/int.mjs
var Int = class _Int {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsInt(bb, obj) {
    return (obj || new _Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsInt(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  bitWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  isSigned() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  static startInt(builder) {
    builder.startObject(2);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(0, bitWidth, 0);
  }
  static addIsSigned(builder, isSigned) {
    builder.addFieldInt8(1, +isSigned, 0);
  }
  static endInt(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createInt(builder, bitWidth, isSigned) {
    _Int.startInt(builder);
    _Int.addBitWidth(builder, bitWidth);
    _Int.addIsSigned(builder, isSigned);
    return _Int.endInt(builder);
  }
};

// node_modules/apache-arrow/fb/dictionary-encoding.mjs
var DictionaryEncoding = class _DictionaryEncoding {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsDictionaryEncoding(bb, obj) {
    return (obj || new _DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  /**
   * The known dictionary id in the application where this data is used. In
   * the file or streaming formats, the dictionary ids are found in the
   * DictionaryBatch messages
   */
  id() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  /**
   * The dictionary indices are constrained to be non-negative integers. If
   * this field is null, the indices must be signed int32. To maximize
   * cross-language compatibility and performance, implementations are
   * recommended to prefer signed integer types over unsigned integer types
   * and to avoid uint64 indices unless they are required by an application.
   */
  indexType(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  /**
   * By default, dictionaries are not ordered, or the order does not have
   * semantic meaning. In some statistical, applications, dictionary-encoding
   * is used to represent ordered categorical data, and we provide a way to
   * preserve that metadata here
   */
  isOrdered() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  dictionaryKind() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DictionaryKind.DenseArray;
  }
  static startDictionaryEncoding(builder) {
    builder.startObject(4);
  }
  static addId(builder, id) {
    builder.addFieldInt64(0, id, BigInt("0"));
  }
  static addIndexType(builder, indexTypeOffset) {
    builder.addFieldOffset(1, indexTypeOffset, 0);
  }
  static addIsOrdered(builder, isOrdered) {
    builder.addFieldInt8(2, +isOrdered, 0);
  }
  static addDictionaryKind(builder, dictionaryKind) {
    builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
  }
  static endDictionaryEncoding(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// node_modules/apache-arrow/fb/binary.mjs
var Binary2 = class _Binary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsBinary(bb, obj) {
    return (obj || new _Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsBinary(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startBinary(builder) {
    builder.startObject(0);
  }
  static endBinary(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createBinary(builder) {
    _Binary.startBinary(builder);
    return _Binary.endBinary(builder);
  }
};

// node_modules/apache-arrow/fb/bool.mjs
var Bool2 = class _Bool {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsBool(bb, obj) {
    return (obj || new _Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsBool(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startBool(builder) {
    builder.startObject(0);
  }
  static endBool(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createBool(builder) {
    _Bool.startBool(builder);
    return _Bool.endBool(builder);
  }
};

// node_modules/apache-arrow/fb/date-unit.mjs
var DateUnit2;
(function(DateUnit3) {
  DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
  DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit2 || (DateUnit2 = {}));

// node_modules/apache-arrow/fb/date.mjs
var Date2 = class _Date {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsDate(bb, obj) {
    return (obj || new _Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDate(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DateUnit2.MILLISECOND;
  }
  static startDate(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, DateUnit2.MILLISECOND);
  }
  static endDate(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createDate(builder, unit) {
    _Date.startDate(builder);
    _Date.addUnit(builder, unit);
    return _Date.endDate(builder);
  }
};

// node_modules/apache-arrow/fb/decimal.mjs
var Decimal2 = class _Decimal {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsDecimal(bb, obj) {
    return (obj || new _Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDecimal(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  /**
   * Total number of decimal digits
   */
  precision() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  /**
   * Number of digits after the decimal point "."
   */
  scale() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  /**
   * Number of bits per value. The only accepted widths are 128 and 256.
   * We use bitWidth for consistency with Int::bitWidth.
   */
  bitWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 128;
  }
  static startDecimal(builder) {
    builder.startObject(3);
  }
  static addPrecision(builder, precision) {
    builder.addFieldInt32(0, precision, 0);
  }
  static addScale(builder, scale2) {
    builder.addFieldInt32(1, scale2, 0);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(2, bitWidth, 128);
  }
  static endDecimal(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createDecimal(builder, precision, scale2, bitWidth) {
    _Decimal.startDecimal(builder);
    _Decimal.addPrecision(builder, precision);
    _Decimal.addScale(builder, scale2);
    _Decimal.addBitWidth(builder, bitWidth);
    return _Decimal.endDecimal(builder);
  }
};

// node_modules/apache-arrow/fb/time-unit.mjs
var TimeUnit2;
(function(TimeUnit3) {
  TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
  TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
  TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit2 || (TimeUnit2 = {}));

// node_modules/apache-arrow/fb/duration.mjs
var Duration2 = class _Duration {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsDuration(bb, obj) {
    return (obj || new _Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDuration(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.MILLISECOND;
  }
  static startDuration(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, TimeUnit2.MILLISECOND);
  }
  static endDuration(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createDuration(builder, unit) {
    _Duration.startDuration(builder);
    _Duration.addUnit(builder, unit);
    return _Duration.endDuration(builder);
  }
};

// node_modules/apache-arrow/fb/fixed-size-binary.mjs
var FixedSizeBinary2 = class _FixedSizeBinary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsFixedSizeBinary(bb, obj) {
    return (obj || new _FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  /**
   * Number of bytes per value
   */
  byteWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  static startFixedSizeBinary(builder) {
    builder.startObject(1);
  }
  static addByteWidth(builder, byteWidth) {
    builder.addFieldInt32(0, byteWidth, 0);
  }
  static endFixedSizeBinary(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createFixedSizeBinary(builder, byteWidth) {
    _FixedSizeBinary.startFixedSizeBinary(builder);
    _FixedSizeBinary.addByteWidth(builder, byteWidth);
    return _FixedSizeBinary.endFixedSizeBinary(builder);
  }
};

// node_modules/apache-arrow/fb/fixed-size-list.mjs
var FixedSizeList2 = class _FixedSizeList {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsFixedSizeList(bb, obj) {
    return (obj || new _FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFixedSizeList(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  /**
   * Number of list items per value
   */
  listSize() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  static startFixedSizeList(builder) {
    builder.startObject(1);
  }
  static addListSize(builder, listSize) {
    builder.addFieldInt32(0, listSize, 0);
  }
  static endFixedSizeList(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createFixedSizeList(builder, listSize) {
    _FixedSizeList.startFixedSizeList(builder);
    _FixedSizeList.addListSize(builder, listSize);
    return _FixedSizeList.endFixedSizeList(builder);
  }
};

// node_modules/apache-arrow/fb/precision.mjs
var Precision2;
(function(Precision3) {
  Precision3[Precision3["HALF"] = 0] = "HALF";
  Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
  Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
})(Precision2 || (Precision2 = {}));

// node_modules/apache-arrow/fb/floating-point.mjs
var FloatingPoint = class _FloatingPoint {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsFloatingPoint(bb, obj) {
    return (obj || new _FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFloatingPoint(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  precision() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Precision2.HALF;
  }
  static startFloatingPoint(builder) {
    builder.startObject(1);
  }
  static addPrecision(builder, precision) {
    builder.addFieldInt16(0, precision, Precision2.HALF);
  }
  static endFloatingPoint(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createFloatingPoint(builder, precision) {
    _FloatingPoint.startFloatingPoint(builder);
    _FloatingPoint.addPrecision(builder, precision);
    return _FloatingPoint.endFloatingPoint(builder);
  }
};

// node_modules/apache-arrow/fb/interval-unit.mjs
var IntervalUnit2;
(function(IntervalUnit3) {
  IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
  IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
  IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit2 || (IntervalUnit2 = {}));

// node_modules/apache-arrow/fb/interval.mjs
var Interval = class _Interval {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsInterval(bb, obj) {
    return (obj || new _Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsInterval(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : IntervalUnit2.YEAR_MONTH;
  }
  static startInterval(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, IntervalUnit2.YEAR_MONTH);
  }
  static endInterval(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createInterval(builder, unit) {
    _Interval.startInterval(builder);
    _Interval.addUnit(builder, unit);
    return _Interval.endInterval(builder);
  }
};

// node_modules/apache-arrow/fb/list.mjs
var List2 = class _List {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsList(bb, obj) {
    return (obj || new _List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsList(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startList(builder) {
    builder.startObject(0);
  }
  static endList(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createList(builder) {
    _List.startList(builder);
    return _List.endList(builder);
  }
};

// node_modules/apache-arrow/fb/map.mjs
var Map2 = class _Map {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsMap(bb, obj) {
    return (obj || new _Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsMap(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  /**
   * Set to true if the keys within each value are sorted
   */
  keysSorted() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  static startMap(builder) {
    builder.startObject(1);
  }
  static addKeysSorted(builder, keysSorted) {
    builder.addFieldInt8(0, +keysSorted, 0);
  }
  static endMap(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createMap(builder, keysSorted) {
    _Map.startMap(builder);
    _Map.addKeysSorted(builder, keysSorted);
    return _Map.endMap(builder);
  }
};

// node_modules/apache-arrow/fb/null.mjs
var Null2 = class _Null {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsNull(bb, obj) {
    return (obj || new _Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsNull(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startNull(builder) {
    builder.startObject(0);
  }
  static endNull(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createNull(builder) {
    _Null.startNull(builder);
    return _Null.endNull(builder);
  }
};

// node_modules/apache-arrow/fb/struct-.mjs
var Struct_ = class _Struct_ {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsStruct_(bb, obj) {
    return (obj || new _Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsStruct_(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startStruct_(builder) {
    builder.startObject(0);
  }
  static endStruct_(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createStruct_(builder) {
    _Struct_.startStruct_(builder);
    return _Struct_.endStruct_(builder);
  }
};

// node_modules/apache-arrow/fb/time.mjs
var Time = class _Time {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsTime(bb, obj) {
    return (obj || new _Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsTime(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.MILLISECOND;
  }
  bitWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 32;
  }
  static startTime(builder) {
    builder.startObject(2);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, TimeUnit2.MILLISECOND);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(1, bitWidth, 32);
  }
  static endTime(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createTime(builder, unit, bitWidth) {
    _Time.startTime(builder);
    _Time.addUnit(builder, unit);
    _Time.addBitWidth(builder, bitWidth);
    return _Time.endTime(builder);
  }
};

// node_modules/apache-arrow/fb/timestamp.mjs
var Timestamp = class _Timestamp {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsTimestamp(bb, obj) {
    return (obj || new _Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsTimestamp(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit2.SECOND;
  }
  timezone(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  static startTimestamp(builder) {
    builder.startObject(2);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, TimeUnit2.SECOND);
  }
  static addTimezone(builder, timezoneOffset) {
    builder.addFieldOffset(1, timezoneOffset, 0);
  }
  static endTimestamp(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createTimestamp(builder, unit, timezoneOffset) {
    _Timestamp.startTimestamp(builder);
    _Timestamp.addUnit(builder, unit);
    _Timestamp.addTimezone(builder, timezoneOffset);
    return _Timestamp.endTimestamp(builder);
  }
};

// node_modules/apache-arrow/fb/union-mode.mjs
var UnionMode2;
(function(UnionMode3) {
  UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
  UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
})(UnionMode2 || (UnionMode2 = {}));

// node_modules/apache-arrow/fb/union.mjs
var Union = class _Union {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsUnion(bb, obj) {
    return (obj || new _Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsUnion(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  mode() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : UnionMode2.Sparse;
  }
  typeIds(index) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset2) + index * 4) : 0;
  }
  typeIdsLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  typeIdsArray() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset2), this.bb.__vector_len(this.bb_pos + offset2)) : null;
  }
  static startUnion(builder) {
    builder.startObject(2);
  }
  static addMode(builder, mode) {
    builder.addFieldInt16(0, mode, UnionMode2.Sparse);
  }
  static addTypeIds(builder, typeIdsOffset) {
    builder.addFieldOffset(1, typeIdsOffset, 0);
  }
  static createTypeIdsVector(builder, data2) {
    builder.startVector(4, data2.length, 4);
    for (let i2 = data2.length - 1; i2 >= 0; i2--) {
      builder.addInt32(data2[i2]);
    }
    return builder.endVector();
  }
  static startTypeIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endUnion(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createUnion(builder, mode, typeIdsOffset) {
    _Union.startUnion(builder);
    _Union.addMode(builder, mode);
    _Union.addTypeIds(builder, typeIdsOffset);
    return _Union.endUnion(builder);
  }
};

// node_modules/apache-arrow/fb/utf8.mjs
var Utf82 = class _Utf8 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsUtf8(bb, obj) {
    return (obj || new _Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsUtf8(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startUtf8(builder) {
    builder.startObject(0);
  }
  static endUtf8(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createUtf8(builder) {
    _Utf8.startUtf8(builder);
    return _Utf8.endUtf8(builder);
  }
};

// node_modules/apache-arrow/fb/type.mjs
var Type2;
(function(Type3) {
  Type3[Type3["NONE"] = 0] = "NONE";
  Type3[Type3["Null"] = 1] = "Null";
  Type3[Type3["Int"] = 2] = "Int";
  Type3[Type3["FloatingPoint"] = 3] = "FloatingPoint";
  Type3[Type3["Binary"] = 4] = "Binary";
  Type3[Type3["Utf8"] = 5] = "Utf8";
  Type3[Type3["Bool"] = 6] = "Bool";
  Type3[Type3["Decimal"] = 7] = "Decimal";
  Type3[Type3["Date"] = 8] = "Date";
  Type3[Type3["Time"] = 9] = "Time";
  Type3[Type3["Timestamp"] = 10] = "Timestamp";
  Type3[Type3["Interval"] = 11] = "Interval";
  Type3[Type3["List"] = 12] = "List";
  Type3[Type3["Struct_"] = 13] = "Struct_";
  Type3[Type3["Union"] = 14] = "Union";
  Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
  Type3[Type3["Map"] = 17] = "Map";
  Type3[Type3["Duration"] = 18] = "Duration";
  Type3[Type3["LargeBinary"] = 19] = "LargeBinary";
  Type3[Type3["LargeUtf8"] = 20] = "LargeUtf8";
  Type3[Type3["LargeList"] = 21] = "LargeList";
  Type3[Type3["RunEndEncoded"] = 22] = "RunEndEncoded";
})(Type2 || (Type2 = {}));

// node_modules/apache-arrow/fb/field.mjs
var Field = class _Field {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsField(bb, obj) {
    return (obj || new _Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsField(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  name(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  /**
   * Whether or not this field can contain nulls. Should be true in general.
   */
  nullable() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  typeType() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : Type2.NONE;
  }
  /**
   * This is the type of the decoded value if the field is dictionary encoded.
   */
  type(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;
  }
  /**
   * Present only if the field is dictionary encoded.
   */
  dictionary(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  /**
   * children apply only to nested data types like Struct, List and Union. For
   * primitive types children will have length 0.
   */
  children(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 14);
    return offset2 ? (obj || new _Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index * 4), this.bb) : null;
  }
  childrenLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 14);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 16);
    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 16);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startField(builder) {
    builder.startObject(7);
  }
  static addName(builder, nameOffset) {
    builder.addFieldOffset(0, nameOffset, 0);
  }
  static addNullable(builder, nullable) {
    builder.addFieldInt8(1, +nullable, 0);
  }
  static addTypeType(builder, typeType) {
    builder.addFieldInt8(2, typeType, Type2.NONE);
  }
  static addType(builder, typeOffset) {
    builder.addFieldOffset(3, typeOffset, 0);
  }
  static addDictionary(builder, dictionaryOffset) {
    builder.addFieldOffset(4, dictionaryOffset, 0);
  }
  static addChildren(builder, childrenOffset) {
    builder.addFieldOffset(5, childrenOffset, 0);
  }
  static createChildrenVector(builder, data2) {
    builder.startVector(4, data2.length, 4);
    for (let i2 = data2.length - 1; i2 >= 0; i2--) {
      builder.addOffset(data2[i2]);
    }
    return builder.endVector();
  }
  static startChildrenVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(6, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data2) {
    builder.startVector(4, data2.length, 4);
    for (let i2 = data2.length - 1; i2 >= 0; i2--) {
      builder.addOffset(data2[i2]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endField(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// node_modules/apache-arrow/fb/schema.mjs
var Schema = class _Schema {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsSchema(bb, obj) {
    return (obj || new _Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsSchema(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  /**
   * endianness of the buffer
   * it is Little Endian by default
   * if endianness doesn't match the underlying system then the vectors need to be converted
   */
  endianness() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Endianness.Little;
  }
  fields(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index * 4), this.bb) : null;
  }
  fieldsLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  customMetadata(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * Features used in the stream/file.
   */
  features(index) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset2) + index * 8) : BigInt(0);
  }
  featuresLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startSchema(builder) {
    builder.startObject(4);
  }
  static addEndianness(builder, endianness) {
    builder.addFieldInt16(0, endianness, Endianness.Little);
  }
  static addFields(builder, fieldsOffset) {
    builder.addFieldOffset(1, fieldsOffset, 0);
  }
  static createFieldsVector(builder, data2) {
    builder.startVector(4, data2.length, 4);
    for (let i2 = data2.length - 1; i2 >= 0; i2--) {
      builder.addOffset(data2[i2]);
    }
    return builder.endVector();
  }
  static startFieldsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(2, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data2) {
    builder.startVector(4, data2.length, 4);
    for (let i2 = data2.length - 1; i2 >= 0; i2--) {
      builder.addOffset(data2[i2]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addFeatures(builder, featuresOffset) {
    builder.addFieldOffset(3, featuresOffset, 0);
  }
  static createFeaturesVector(builder, data2) {
    builder.startVector(8, data2.length, 8);
    for (let i2 = data2.length - 1; i2 >= 0; i2--) {
      builder.addInt64(data2[i2]);
    }
    return builder.endVector();
  }
  static startFeaturesVector(builder, numElems) {
    builder.startVector(8, numElems, 8);
  }
  static endSchema(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static finishSchemaBuffer(builder, offset2) {
    builder.finish(offset2);
  }
  static finishSizePrefixedSchemaBuffer(builder, offset2) {
    builder.finish(offset2, void 0, true);
  }
  static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
    _Schema.startSchema(builder);
    _Schema.addEndianness(builder, endianness);
    _Schema.addFields(builder, fieldsOffset);
    _Schema.addCustomMetadata(builder, customMetadataOffset);
    _Schema.addFeatures(builder, featuresOffset);
    return _Schema.endSchema(builder);
  }
};

// node_modules/apache-arrow/fb/footer.mjs
var Footer = class _Footer {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsFooter(bb, obj) {
    return (obj || new _Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFooter(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  version() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;
  }
  schema(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  dictionaries(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index * 24, this.bb) : null;
  }
  dictionariesLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  recordBatches(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index * 24, this.bb) : null;
  }
  recordBatchesLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startFooter(builder) {
    builder.startObject(5);
  }
  static addVersion(builder, version3) {
    builder.addFieldInt16(0, version3, MetadataVersion2.V1);
  }
  static addSchema(builder, schemaOffset) {
    builder.addFieldOffset(1, schemaOffset, 0);
  }
  static addDictionaries(builder, dictionariesOffset) {
    builder.addFieldOffset(2, dictionariesOffset, 0);
  }
  static startDictionariesVector(builder, numElems) {
    builder.startVector(24, numElems, 8);
  }
  static addRecordBatches(builder, recordBatchesOffset) {
    builder.addFieldOffset(3, recordBatchesOffset, 0);
  }
  static startRecordBatchesVector(builder, numElems) {
    builder.startVector(24, numElems, 8);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(4, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data2) {
    builder.startVector(4, data2.length, 4);
    for (let i2 = data2.length - 1; i2 >= 0; i2--) {
      builder.addOffset(data2[i2]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endFooter(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static finishFooterBuffer(builder, offset2) {
    builder.finish(offset2);
  }
  static finishSizePrefixedFooterBuffer(builder, offset2) {
    builder.finish(offset2, void 0, true);
  }
};

// node_modules/apache-arrow/schema.mjs
var Schema2 = class _Schema {
  constructor(fields = [], metadata, dictionaries, metadataVersion = MetadataVersion.V5) {
    this.fields = fields || [];
    this.metadata = metadata || /* @__PURE__ */ new Map();
    if (!dictionaries) {
      dictionaries = generateDictionaryMap(fields);
    }
    this.dictionaries = dictionaries;
    this.metadataVersion = metadataVersion;
  }
  get [Symbol.toStringTag]() {
    return "Schema";
  }
  get names() {
    return this.fields.map((f) => f.name);
  }
  toString() {
    return `Schema<{ ${this.fields.map((f, i2) => `${i2}: ${f}`).join(", ")} }>`;
  }
  /**
   * Construct a new Schema containing only specified fields.
   *
   * @param fieldNames Names of fields to keep.
   * @returns A new Schema of fields matching the specified names.
   */
  select(fieldNames) {
    const names2 = new Set(fieldNames);
    const fields = this.fields.filter((f) => names2.has(f.name));
    return new _Schema(fields, this.metadata);
  }
  /**
   * Construct a new Schema containing only fields at the specified indices.
   *
   * @param fieldIndices Indices of fields to keep.
   * @returns A new Schema of fields at the specified indices.
   */
  selectAt(fieldIndices) {
    const fields = fieldIndices.map((i2) => this.fields[i2]).filter(Boolean);
    return new _Schema(fields, this.metadata);
  }
  assign(...args) {
    const other = args[0] instanceof _Schema ? args[0] : Array.isArray(args[0]) ? new _Schema(args[0]) : new _Schema(args);
    const curFields = [...this.fields];
    const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
    const newFields = other.fields.filter((f2) => {
      const i2 = curFields.findIndex((f) => f.name === f2.name);
      return ~i2 ? (curFields[i2] = f2.clone({
        metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i2].metadata), f2.metadata)
      })) && false : true;
    });
    const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());
    return new _Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
  }
};
Schema2.prototype.fields = null;
Schema2.prototype.metadata = null;
Schema2.prototype.dictionaries = null;
var Field2 = class _Field {
  /** @nocollapse */
  static new(...args) {
    let [name2, type, nullable, metadata] = args;
    if (args[0] && typeof args[0] === "object") {
      ({ name: name2 } = args[0]);
      type === void 0 && (type = args[0].type);
      nullable === void 0 && (nullable = args[0].nullable);
      metadata === void 0 && (metadata = args[0].metadata);
    }
    return new _Field(`${name2}`, type, nullable, metadata);
  }
  constructor(name2, type, nullable = false, metadata) {
    this.name = name2;
    this.type = type;
    this.nullable = nullable;
    this.metadata = metadata || /* @__PURE__ */ new Map();
  }
  get typeId() {
    return this.type.typeId;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    return `${this.name}: ${this.type}`;
  }
  clone(...args) {
    let [name2, type, nullable, metadata] = args;
    !args[0] || typeof args[0] !== "object" ? [name2 = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name: name2 = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
    return _Field.new(name2, type, nullable, metadata);
  }
};
Field2.prototype.type = null;
Field2.prototype.name = null;
Field2.prototype.nullable = null;
Field2.prototype.metadata = null;
function mergeMaps(m1, m2) {
  return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
}
function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
  for (let i2 = -1, n2 = fields.length; ++i2 < n2; ) {
    const field = fields[i2];
    const type = field.type;
    if (DataType.isDictionary(type)) {
      if (!dictionaries.has(type.id)) {
        dictionaries.set(type.id, type.dictionary);
      } else if (dictionaries.get(type.id) !== type.dictionary) {
        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
      }
    }
    if (type.children && type.children.length > 0) {
      generateDictionaryMap(type.children, dictionaries);
    }
  }
  return dictionaries;
}

// node_modules/apache-arrow/ipc/metadata/file.mjs
var Builder3 = Builder2;
var ByteBuffer2 = ByteBuffer;
var Footer_ = class {
  /** @nocollapse */
  static decode(buf) {
    buf = new ByteBuffer2(toUint8Array(buf));
    const footer = Footer.getRootAsFooter(buf);
    const schema = Schema2.decode(footer.schema(), /* @__PURE__ */ new Map(), footer.version());
    return new OffHeapFooter(schema, footer);
  }
  /** @nocollapse */
  static encode(footer) {
    const b = new Builder3();
    const schemaOffset = Schema2.encode(b, footer.schema);
    Footer.startRecordBatchesVector(b, footer.numRecordBatches);
    for (const rb of [...footer.recordBatches()].slice().reverse()) {
      FileBlock.encode(b, rb);
    }
    const recordBatchesOffset = b.endVector();
    Footer.startDictionariesVector(b, footer.numDictionaries);
    for (const db of [...footer.dictionaryBatches()].slice().reverse()) {
      FileBlock.encode(b, db);
    }
    const dictionaryBatchesOffset = b.endVector();
    Footer.startFooter(b);
    Footer.addSchema(b, schemaOffset);
    Footer.addVersion(b, MetadataVersion.V5);
    Footer.addRecordBatches(b, recordBatchesOffset);
    Footer.addDictionaries(b, dictionaryBatchesOffset);
    Footer.finishFooterBuffer(b, Footer.endFooter(b));
    return b.asUint8Array();
  }
  get numRecordBatches() {
    return this._recordBatches.length;
  }
  get numDictionaries() {
    return this._dictionaryBatches.length;
  }
  constructor(schema, version3 = MetadataVersion.V5, recordBatches, dictionaryBatches) {
    this.schema = schema;
    this.version = version3;
    recordBatches && (this._recordBatches = recordBatches);
    dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
  }
  *recordBatches() {
    for (let block, i2 = -1, n2 = this.numRecordBatches; ++i2 < n2; ) {
      if (block = this.getRecordBatch(i2)) {
        yield block;
      }
    }
  }
  *dictionaryBatches() {
    for (let block, i2 = -1, n2 = this.numDictionaries; ++i2 < n2; ) {
      if (block = this.getDictionaryBatch(i2)) {
        yield block;
      }
    }
  }
  getRecordBatch(index) {
    return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
  }
  getDictionaryBatch(index) {
    return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
  }
};
var OffHeapFooter = class extends Footer_ {
  get numRecordBatches() {
    return this._footer.recordBatchesLength();
  }
  get numDictionaries() {
    return this._footer.dictionariesLength();
  }
  constructor(schema, _footer) {
    super(schema, _footer.version());
    this._footer = _footer;
  }
  getRecordBatch(index) {
    if (index >= 0 && index < this.numRecordBatches) {
      const fileBlock = this._footer.recordBatches(index);
      if (fileBlock) {
        return FileBlock.decode(fileBlock);
      }
    }
    return null;
  }
  getDictionaryBatch(index) {
    if (index >= 0 && index < this.numDictionaries) {
      const fileBlock = this._footer.dictionaries(index);
      if (fileBlock) {
        return FileBlock.decode(fileBlock);
      }
    }
    return null;
  }
};
var FileBlock = class _FileBlock {
  /** @nocollapse */
  static decode(block) {
    return new _FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
  }
  /** @nocollapse */
  static encode(b, fileBlock) {
    const { metaDataLength } = fileBlock;
    const offset2 = BigInt(fileBlock.offset);
    const bodyLength = BigInt(fileBlock.bodyLength);
    return Block.createBlock(b, offset2, metaDataLength, bodyLength);
  }
  constructor(metaDataLength, bodyLength, offset2) {
    this.metaDataLength = metaDataLength;
    this.offset = bigIntToNumber(offset2);
    this.bodyLength = bigIntToNumber(bodyLength);
  }
};

// node_modules/apache-arrow/io/interfaces.mjs
var ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });
var ArrowJSON = class {
  constructor(_json) {
    this._json = _json;
  }
  get schema() {
    return this._json["schema"];
  }
  get batches() {
    return this._json["batches"] || [];
  }
  get dictionaries() {
    return this._json["dictionaries"] || [];
  }
};
var ReadableInterop = class {
  tee() {
    return this._getDOMStream().tee();
  }
  pipe(writable, options) {
    return this._getNodeStream().pipe(writable, options);
  }
  pipeTo(writable, options) {
    return this._getDOMStream().pipeTo(writable, options);
  }
  pipeThrough(duplex, options) {
    return this._getDOMStream().pipeThrough(duplex, options);
  }
  _getDOMStream() {
    return this._DOMStream || (this._DOMStream = this.toDOMStream());
  }
  _getNodeStream() {
    return this._nodeStream || (this._nodeStream = this.toNodeStream());
  }
};
var AsyncQueue = class extends ReadableInterop {
  constructor() {
    super();
    this._values = [];
    this.resolvers = [];
    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
  }
  get closed() {
    return this._closedPromise;
  }
  cancel(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.return(reason);
    });
  }
  write(value) {
    if (this._ensureOpen()) {
      this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
    }
  }
  abort(value) {
    if (this._closedPromiseResolve) {
      this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
    }
  }
  close() {
    if (this._closedPromiseResolve) {
      const { resolvers } = this;
      while (resolvers.length > 0) {
        resolvers.shift().resolve(ITERATOR_DONE);
      }
      this._closedPromiseResolve();
      this._closedPromiseResolve = void 0;
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  toDOMStream(options) {
    return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
  }
  toNodeStream(options) {
    return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
  }
  throw(_) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.abort(_);
      return ITERATOR_DONE;
    });
  }
  return(_) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.close();
      return ITERATOR_DONE;
    });
  }
  read(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "read")).value;
    });
  }
  peek(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "peek")).value;
    });
  }
  next(..._args) {
    if (this._values.length > 0) {
      return Promise.resolve({ done: false, value: this._values.shift() });
    } else if (this._error) {
      return Promise.reject({ done: true, value: this._error.error });
    } else if (!this._closedPromiseResolve) {
      return Promise.resolve(ITERATOR_DONE);
    } else {
      return new Promise((resolve2, reject) => {
        this.resolvers.push({ resolve: resolve2, reject });
      });
    }
  }
  _ensureOpen() {
    if (this._closedPromiseResolve) {
      return true;
    }
    throw new Error(`AsyncQueue is closed`);
  }
};

// node_modules/apache-arrow/io/stream.mjs
var AsyncByteQueue = class extends AsyncQueue {
  write(value) {
    if ((value = toUint8Array(value)).byteLength > 0) {
      return super.write(value);
    }
  }
  toString(sync = false) {
    return sync ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);
  }
  toUint8Array(sync = false) {
    return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {
      var _a5, e_1, _b2, _c2;
      const buffers = [];
      let byteLength = 0;
      try {
        for (var _d2 = true, _e2 = __asyncValues(this), _f2; _f2 = yield _e2.next(), _a5 = _f2.done, !_a5; _d2 = true) {
          _c2 = _f2.value;
          _d2 = false;
          const chunk = _c2;
          buffers.push(chunk);
          byteLength += chunk.byteLength;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d2 && !_a5 && (_b2 = _e2.return))
            yield _b2.call(_e2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return joinUint8Arrays(buffers, byteLength)[0];
    }))();
  }
};
var ByteStream = class {
  constructor(source2) {
    if (source2) {
      this.source = new ByteStreamSource(adapters_default.fromIterable(source2));
    }
  }
  [Symbol.iterator]() {
    return this;
  }
  next(value) {
    return this.source.next(value);
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  peek(size) {
    return this.source.peek(size);
  }
  read(size) {
    return this.source.read(size);
  }
};
var AsyncByteStream = class _AsyncByteStream {
  constructor(source2) {
    if (source2 instanceof _AsyncByteStream) {
      this.source = source2.source;
    } else if (source2 instanceof AsyncByteQueue) {
      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source2));
    } else if (isReadableNodeStream(source2)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source2));
    } else if (isReadableDOMStream(source2)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source2));
    } else if (isFetchResponse(source2)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source2.body));
    } else if (isIterable(source2)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source2));
    } else if (isPromise(source2)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source2));
    } else if (isAsyncIterable(source2)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source2));
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next(value) {
    return this.source.next(value);
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  get closed() {
    return this.source.closed;
  }
  cancel(reason) {
    return this.source.cancel(reason);
  }
  peek(size) {
    return this.source.peek(size);
  }
  read(size) {
    return this.source.read(size);
  }
};
var ByteStreamSource = class {
  constructor(source2) {
    this.source = source2;
  }
  cancel(reason) {
    this.return(reason);
  }
  peek(size) {
    return this.next(size, "peek").value;
  }
  read(size) {
    return this.next(size, "read").value;
  }
  next(size, cmd = "read") {
    return this.source.next({ cmd, size });
  }
  throw(value) {
    return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);
  }
  return(value) {
    return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);
  }
};
var AsyncByteStreamSource = class {
  constructor(source2) {
    this.source = source2;
    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
  }
  cancel(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.return(reason);
    });
  }
  get closed() {
    return this._closedPromise;
  }
  read(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "read")).value;
    });
  }
  peek(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "peek")).value;
    });
  }
  next(size, cmd = "read") {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.source.next({ cmd, size });
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;
      this._closedPromiseResolve && this._closedPromiseResolve();
      this._closedPromiseResolve = void 0;
      return Object.create(result);
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;
      this._closedPromiseResolve && this._closedPromiseResolve();
      this._closedPromiseResolve = void 0;
      return Object.create(result);
    });
  }
};

// node_modules/apache-arrow/io/file.mjs
var RandomAccessFile = class extends ByteStream {
  constructor(buffer, byteLength) {
    super();
    this.position = 0;
    this.buffer = toUint8Array(buffer);
    this.size = byteLength === void 0 ? this.buffer.byteLength : byteLength;
  }
  readInt32(position) {
    const { buffer, byteOffset } = this.readAt(position, 4);
    return new DataView(buffer, byteOffset).getInt32(0, true);
  }
  seek(position) {
    this.position = Math.min(position, this.size);
    return position < this.size;
  }
  read(nBytes) {
    const { buffer, size, position } = this;
    if (buffer && position < size) {
      if (typeof nBytes !== "number") {
        nBytes = Number.POSITIVE_INFINITY;
      }
      this.position = Math.min(size, position + Math.min(size - position, nBytes));
      return buffer.subarray(position, this.position);
    }
    return null;
  }
  readAt(position, nBytes) {
    const buf = this.buffer;
    const end = Math.min(this.size, position + nBytes);
    return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
  }
  close() {
    this.buffer && (this.buffer = null);
  }
  throw(value) {
    this.close();
    return { done: true, value };
  }
  return(value) {
    this.close();
    return { done: true, value };
  }
};
var AsyncRandomAccessFile = class extends AsyncByteStream {
  constructor(file, byteLength) {
    super();
    this.position = 0;
    this._handle = file;
    if (typeof byteLength === "number") {
      this.size = byteLength;
    } else {
      this._pending = (() => __awaiter(this, void 0, void 0, function* () {
        this.size = (yield file.stat()).size;
        delete this._pending;
      }))();
    }
  }
  readInt32(position) {
    return __awaiter(this, void 0, void 0, function* () {
      const { buffer, byteOffset } = yield this.readAt(position, 4);
      return new DataView(buffer, byteOffset).getInt32(0, true);
    });
  }
  seek(position) {
    return __awaiter(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      this.position = Math.min(position, this.size);
      return position < this.size;
    });
  }
  read(nBytes) {
    return __awaiter(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: file, size, position } = this;
      if (file && position < size) {
        if (typeof nBytes !== "number") {
          nBytes = Number.POSITIVE_INFINITY;
        }
        let pos = position, offset2 = 0, bytesRead = 0;
        const end = Math.min(size, pos + Math.min(size - pos, nBytes));
        const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
        while ((pos += bytesRead) < end && (offset2 += bytesRead) < buffer.byteLength) {
          ({ bytesRead } = yield file.read(buffer, offset2, buffer.byteLength - offset2, pos));
        }
        return buffer;
      }
      return null;
    });
  }
  readAt(position, nBytes) {
    return __awaiter(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: file, size } = this;
      if (file && position + nBytes < size) {
        const end = Math.min(size, position + nBytes);
        const buffer = new Uint8Array(end - position);
        return (yield file.read(buffer, 0, nBytes, position)).buffer;
      }
      return new Uint8Array(nBytes);
    });
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      const f = this._handle;
      this._handle = null;
      f && (yield f.close());
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.close();
      return { done: true, value };
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.close();
      return { done: true, value };
    });
  }
};

// node_modules/apache-arrow/util/int.mjs
var int_exports = {};
__export(int_exports, {
  BaseInt64: () => BaseInt64,
  Int128: () => Int128,
  Int64: () => Int642,
  Uint64: () => Uint642
});
var carryBit16 = 1 << 16;
function intAsHex(value) {
  if (value < 0) {
    value = 4294967295 + value + 1;
  }
  return `0x${value.toString(16)}`;
}
var kInt32DecimalDigits = 8;
var kPowersOfTen = [
  1,
  10,
  100,
  1e3,
  1e4,
  1e5,
  1e6,
  1e7,
  1e8
];
var BaseInt64 = class {
  constructor(buffer) {
    this.buffer = buffer;
  }
  high() {
    return this.buffer[1];
  }
  low() {
    return this.buffer[0];
  }
  _times(other) {
    const L = new Uint32Array([
      this.buffer[1] >>> 16,
      this.buffer[1] & 65535,
      this.buffer[0] >>> 16,
      this.buffer[0] & 65535
    ]);
    const R = new Uint32Array([
      other.buffer[1] >>> 16,
      other.buffer[1] & 65535,
      other.buffer[0] >>> 16,
      other.buffer[0] & 65535
    ]);
    let product = L[3] * R[3];
    this.buffer[0] = product & 65535;
    let sum2 = product >>> 16;
    product = L[2] * R[3];
    sum2 += product;
    product = L[3] * R[2] >>> 0;
    sum2 += product;
    this.buffer[0] += sum2 << 16;
    this.buffer[1] = sum2 >>> 0 < product ? carryBit16 : 0;
    this.buffer[1] += sum2 >>> 16;
    this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
    this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
    return this;
  }
  _plus(other) {
    const sum2 = this.buffer[0] + other.buffer[0] >>> 0;
    this.buffer[1] += other.buffer[1];
    if (sum2 < this.buffer[0] >>> 0) {
      ++this.buffer[1];
    }
    this.buffer[0] = sum2;
  }
  lessThan(other) {
    return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
  }
  equals(other) {
    return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
  }
  greaterThan(other) {
    return other.lessThan(this);
  }
  hex() {
    return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
  }
};
var Uint642 = class _Uint64 extends BaseInt64 {
  times(other) {
    this._times(other);
    return this;
  }
  plus(other) {
    this._plus(other);
    return this;
  }
  /** @nocollapse */
  static from(val, out_buffer = new Uint32Array(2)) {
    return _Uint64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromNumber(num, out_buffer = new Uint32Array(2)) {
    return _Uint64.fromString(num.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromString(str, out_buffer = new Uint32Array(2)) {
    const length = str.length;
    const out = new _Uint64(out_buffer);
    for (let posn = 0; posn < length; ) {
      const group2 = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
      const chunk = new _Uint64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group2), 10), 0]));
      const multiple = new _Uint64(new Uint32Array([kPowersOfTen[group2], 0]));
      out.times(multiple);
      out.plus(chunk);
      posn += group2;
    }
    return out;
  }
  /** @nocollapse */
  static convertArray(values2) {
    const data2 = new Uint32Array(values2.length * 2);
    for (let i2 = -1, n2 = values2.length; ++i2 < n2; ) {
      _Uint64.from(values2[i2], new Uint32Array(data2.buffer, data2.byteOffset + 2 * i2 * 4, 2));
    }
    return data2;
  }
  /** @nocollapse */
  static multiply(left, right) {
    const rtrn = new _Uint64(new Uint32Array(left.buffer));
    return rtrn.times(right);
  }
  /** @nocollapse */
  static add(left, right) {
    const rtrn = new _Uint64(new Uint32Array(left.buffer));
    return rtrn.plus(right);
  }
};
var Int642 = class _Int64 extends BaseInt64 {
  negate() {
    this.buffer[0] = ~this.buffer[0] + 1;
    this.buffer[1] = ~this.buffer[1];
    if (this.buffer[0] == 0) {
      ++this.buffer[1];
    }
    return this;
  }
  times(other) {
    this._times(other);
    return this;
  }
  plus(other) {
    this._plus(other);
    return this;
  }
  lessThan(other) {
    const this_high = this.buffer[1] << 0;
    const other_high = other.buffer[1] << 0;
    return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
  }
  /** @nocollapse */
  static from(val, out_buffer = new Uint32Array(2)) {
    return _Int64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromNumber(num, out_buffer = new Uint32Array(2)) {
    return _Int64.fromString(num.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromString(str, out_buffer = new Uint32Array(2)) {
    const negate = str.startsWith("-");
    const length = str.length;
    const out = new _Int64(out_buffer);
    for (let posn = negate ? 1 : 0; posn < length; ) {
      const group2 = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
      const chunk = new _Int64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group2), 10), 0]));
      const multiple = new _Int64(new Uint32Array([kPowersOfTen[group2], 0]));
      out.times(multiple);
      out.plus(chunk);
      posn += group2;
    }
    return negate ? out.negate() : out;
  }
  /** @nocollapse */
  static convertArray(values2) {
    const data2 = new Uint32Array(values2.length * 2);
    for (let i2 = -1, n2 = values2.length; ++i2 < n2; ) {
      _Int64.from(values2[i2], new Uint32Array(data2.buffer, data2.byteOffset + 2 * i2 * 4, 2));
    }
    return data2;
  }
  /** @nocollapse */
  static multiply(left, right) {
    const rtrn = new _Int64(new Uint32Array(left.buffer));
    return rtrn.times(right);
  }
  /** @nocollapse */
  static add(left, right) {
    const rtrn = new _Int64(new Uint32Array(left.buffer));
    return rtrn.plus(right);
  }
};
var Int128 = class _Int128 {
  constructor(buffer) {
    this.buffer = buffer;
  }
  high() {
    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
  }
  low() {
    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
  }
  negate() {
    this.buffer[0] = ~this.buffer[0] + 1;
    this.buffer[1] = ~this.buffer[1];
    this.buffer[2] = ~this.buffer[2];
    this.buffer[3] = ~this.buffer[3];
    if (this.buffer[0] == 0) {
      ++this.buffer[1];
    }
    if (this.buffer[1] == 0) {
      ++this.buffer[2];
    }
    if (this.buffer[2] == 0) {
      ++this.buffer[3];
    }
    return this;
  }
  times(other) {
    const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
    const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
    const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
    const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
    const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
    const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
    const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
    const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
    let product = Uint642.multiply(L3, R3);
    this.buffer[0] = product.low();
    const sum2 = new Uint642(new Uint32Array([product.high(), 0]));
    product = Uint642.multiply(L2, R3);
    sum2.plus(product);
    product = Uint642.multiply(L3, R2);
    sum2.plus(product);
    this.buffer[1] = sum2.low();
    this.buffer[3] = sum2.lessThan(product) ? 1 : 0;
    this.buffer[2] = sum2.high();
    const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
    this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
    return this;
  }
  plus(other) {
    const sums = new Uint32Array(4);
    sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
    sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
    sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
    sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
    if (sums[0] < this.buffer[0] >>> 0) {
      ++sums[1];
    }
    if (sums[1] < this.buffer[1] >>> 0) {
      ++sums[2];
    }
    if (sums[2] < this.buffer[2] >>> 0) {
      ++sums[3];
    }
    this.buffer[3] = sums[3];
    this.buffer[2] = sums[2];
    this.buffer[1] = sums[1];
    this.buffer[0] = sums[0];
    return this;
  }
  hex() {
    return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
  }
  /** @nocollapse */
  static multiply(left, right) {
    const rtrn = new _Int128(new Uint32Array(left.buffer));
    return rtrn.times(right);
  }
  /** @nocollapse */
  static add(left, right) {
    const rtrn = new _Int128(new Uint32Array(left.buffer));
    return rtrn.plus(right);
  }
  /** @nocollapse */
  static from(val, out_buffer = new Uint32Array(4)) {
    return _Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromNumber(num, out_buffer = new Uint32Array(4)) {
    return _Int128.fromString(num.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromString(str, out_buffer = new Uint32Array(4)) {
    const negate = str.startsWith("-");
    const length = str.length;
    const out = new _Int128(out_buffer);
    for (let posn = negate ? 1 : 0; posn < length; ) {
      const group2 = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
      const chunk = new _Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group2), 10), 0, 0, 0]));
      const multiple = new _Int128(new Uint32Array([kPowersOfTen[group2], 0, 0, 0]));
      out.times(multiple);
      out.plus(chunk);
      posn += group2;
    }
    return negate ? out.negate() : out;
  }
  /** @nocollapse */
  static convertArray(values2) {
    const data2 = new Uint32Array(values2.length * 4);
    for (let i2 = -1, n2 = values2.length; ++i2 < n2; ) {
      _Int128.from(values2[i2], new Uint32Array(data2.buffer, data2.byteOffset + 4 * 4 * i2, 4));
    }
    return data2;
  }
};

// node_modules/apache-arrow/visitor/vectorloader.mjs
var VectorLoader = class extends Visitor {
  constructor(bytes, nodes, buffers, dictionaries, metadataVersion = MetadataVersion.V5) {
    super();
    this.nodesIndex = -1;
    this.buffersIndex = -1;
    this.bytes = bytes;
    this.nodes = nodes;
    this.buffers = buffers;
    this.dictionaries = dictionaries;
    this.metadataVersion = metadataVersion;
  }
  visit(node) {
    return super.visit(node instanceof Field2 ? node.type : node);
  }
  visitNull(type, { length } = this.nextFieldNode()) {
    return makeData({ type, length });
  }
  visitBool(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitInt(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
  }
  visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
  }
  visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitDate(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitTime(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitList(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
  }
  visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
  }
  visitUnion(type, { length, nullCount } = this.nextFieldNode()) {
    if (this.metadataVersion < MetadataVersion.V5) {
      this.readNullBitmap(type, nullCount);
    }
    return type.mode === UnionMode.Sparse ? this.visitSparseUnion(type, { length, nullCount }) : this.visitDenseUnion(type, { length, nullCount });
  }
  visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
  }
  visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
  }
  visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
  }
  visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitDuration(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), "child": this.visit(type.children[0]) });
  }
  visitMap(type, { length, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
  }
  nextFieldNode() {
    return this.nodes[++this.nodesIndex];
  }
  nextBufferRange() {
    return this.buffers[++this.buffersIndex];
  }
  readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
    return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
  }
  readOffsets(type, buffer) {
    return this.readData(type, buffer);
  }
  readTypeIds(type, buffer) {
    return this.readData(type, buffer);
  }
  readData(_type, { length, offset: offset2 } = this.nextBufferRange()) {
    return this.bytes.subarray(offset2, offset2 + length);
  }
  readDictionary(type) {
    return this.dictionaries.get(type.id);
  }
};
var JSONVectorLoader = class extends VectorLoader {
  constructor(sources, nodes, buffers, dictionaries, metadataVersion) {
    super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
    this.sources = sources;
  }
  readNullBitmap(_type, nullCount, { offset: offset2 } = this.nextBufferRange()) {
    return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset2]);
  }
  readOffsets(_type, { offset: offset2 } = this.nextBufferRange()) {
    return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset2]));
  }
  readTypeIds(type, { offset: offset2 } = this.nextBufferRange()) {
    return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, this.sources[offset2]));
  }
  readData(type, { offset: offset2 } = this.nextBufferRange()) {
    const { sources } = this;
    if (DataType.isTimestamp(type)) {
      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));
    } else if ((DataType.isInt(type) || DataType.isTime(type)) && type.bitWidth === 64 || DataType.isDuration(type)) {
      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));
    } else if (DataType.isDate(type) && type.unit === DateUnit.MILLISECOND) {
      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));
    } else if (DataType.isDecimal(type)) {
      return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset2]));
    } else if (DataType.isBinary(type) || DataType.isFixedSizeBinary(type)) {
      return binaryDataFromJSON(sources[offset2]);
    } else if (DataType.isBool(type)) {
      return packBools(sources[offset2]);
    } else if (DataType.isUtf8(type)) {
      return encodeUtf8(sources[offset2].join(""));
    }
    return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, sources[offset2].map((x) => +x)));
  }
};
function binaryDataFromJSON(values2) {
  const joined = values2.join("");
  const data2 = new Uint8Array(joined.length / 2);
  for (let i2 = 0; i2 < joined.length; i2 += 2) {
    data2[i2 >> 1] = Number.parseInt(joined.slice(i2, i2 + 2), 16);
  }
  return data2;
}

// node_modules/apache-arrow/builder/binary.mjs
var BinaryBuilder = class extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(new Uint8Array(0));
  }
  get byteLength() {
    let size = this._pendingLength + this.length * 4;
    this._offsets && (size += this._offsets.byteLength);
    this._values && (size += this._values.byteLength);
    this._nulls && (size += this._nulls.byteLength);
    return size;
  }
  setValue(index, value) {
    return super.setValue(index, toUint8Array(value));
  }
  _flushPending(pending, pendingLength) {
    const offsets = this._offsets;
    const data2 = this._values.reserve(pendingLength).buffer;
    let offset2 = 0;
    for (const [index, value] of pending) {
      if (value === void 0) {
        offsets.set(index, 0);
      } else {
        const length = value.length;
        data2.set(value, offset2);
        offsets.set(index, length);
        offset2 += length;
      }
    }
  }
};

// node_modules/apache-arrow/builder/bool.mjs
var BoolBuilder = class extends Builder {
  constructor(options) {
    super(options);
    this._values = new BitmapBufferBuilder();
  }
  setValue(index, value) {
    this._values.set(index, +value);
  }
};

// node_modules/apache-arrow/builder/date.mjs
var DateBuilder = class extends FixedWidthBuilder {
};
DateBuilder.prototype._setValue = setDate;
var DateDayBuilder = class extends DateBuilder {
};
DateDayBuilder.prototype._setValue = setDateDay;
var DateMillisecondBuilder = class extends DateBuilder {
};
DateMillisecondBuilder.prototype._setValue = setDateMillisecond;

// node_modules/apache-arrow/builder/decimal.mjs
var DecimalBuilder = class extends FixedWidthBuilder {
};
DecimalBuilder.prototype._setValue = setDecimal;

// node_modules/apache-arrow/builder/dictionary.mjs
var DictionaryBuilder = class extends Builder {
  constructor({ "type": type, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
    super({ type: new Dictionary2(type.dictionary, type.indices, type.id, type.isOrdered) });
    this._nulls = null;
    this._dictionaryOffset = 0;
    this._keysToIndices = /* @__PURE__ */ Object.create(null);
    this.indices = makeBuilder({ "type": this.type.indices, "nullValues": nulls });
    this.dictionary = makeBuilder({ "type": this.type.dictionary, "nullValues": null });
    if (typeof hashFn === "function") {
      this.valueToKey = hashFn;
    }
  }
  get values() {
    return this.indices.values;
  }
  get nullCount() {
    return this.indices.nullCount;
  }
  get nullBitmap() {
    return this.indices.nullBitmap;
  }
  get byteLength() {
    return this.indices.byteLength + this.dictionary.byteLength;
  }
  get reservedLength() {
    return this.indices.reservedLength + this.dictionary.reservedLength;
  }
  get reservedByteLength() {
    return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
  }
  isValid(value) {
    return this.indices.isValid(value);
  }
  setValid(index, valid) {
    const indices = this.indices;
    valid = indices.setValid(index, valid);
    this.length = indices.length;
    return valid;
  }
  setValue(index, value) {
    const keysToIndices = this._keysToIndices;
    const key2 = this.valueToKey(value);
    let idx = keysToIndices[key2];
    if (idx === void 0) {
      keysToIndices[key2] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
    }
    return this.indices.setValue(index, idx);
  }
  flush() {
    const type = this.type;
    const prev = this._dictionary;
    const curr = this.dictionary.toVector();
    const data2 = this.indices.flush().clone(type);
    data2.dictionary = prev ? prev.concat(curr) : curr;
    this.finished || (this._dictionaryOffset += curr.length);
    this._dictionary = data2.dictionary;
    this.clear();
    return data2;
  }
  finish() {
    this.indices.finish();
    this.dictionary.finish();
    this._dictionaryOffset = 0;
    this._keysToIndices = /* @__PURE__ */ Object.create(null);
    return super.finish();
  }
  clear() {
    this.indices.clear();
    this.dictionary.clear();
    return super.clear();
  }
  valueToKey(val) {
    return typeof val === "string" ? val : `${val}`;
  }
};

// node_modules/apache-arrow/builder/fixedsizebinary.mjs
var FixedSizeBinaryBuilder = class extends FixedWidthBuilder {
};
FixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;

// node_modules/apache-arrow/builder/fixedsizelist.mjs
var FixedSizeListBuilder = class extends Builder {
  setValue(index, value) {
    const [child] = this.children;
    const start = index * this.stride;
    for (let i2 = -1, n2 = value.length; ++i2 < n2; ) {
      child.set(start + i2, value[i2]);
    }
  }
  addChild(child, name2 = "0") {
    if (this.numChildren > 0) {
      throw new Error("FixedSizeListBuilder can only have one child.");
    }
    const childIndex = this.children.push(child);
    this.type = new FixedSizeList(this.type.listSize, new Field2(name2, child.type, true));
    return childIndex;
  }
};

// node_modules/apache-arrow/builder/float.mjs
var FloatBuilder = class extends FixedWidthBuilder {
  setValue(index, value) {
    this._values.set(index, value);
  }
};
var Float16Builder = class extends FloatBuilder {
  setValue(index, value) {
    super.setValue(index, float64ToUint16(value));
  }
};
var Float32Builder = class extends FloatBuilder {
};
var Float64Builder = class extends FloatBuilder {
};

// node_modules/apache-arrow/builder/interval.mjs
var IntervalBuilder = class extends FixedWidthBuilder {
};
IntervalBuilder.prototype._setValue = setIntervalValue;
var IntervalDayTimeBuilder = class extends IntervalBuilder {
};
IntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;
var IntervalYearMonthBuilder = class extends IntervalBuilder {
};
IntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;

// node_modules/apache-arrow/builder/duration.mjs
var DurationBuilder = class extends FixedWidthBuilder {
};
DurationBuilder.prototype._setValue = setDuration;
var DurationSecondBuilder = class extends DurationBuilder {
};
DurationSecondBuilder.prototype._setValue = setDurationSecond;
var DurationMillisecondBuilder = class extends DurationBuilder {
};
DurationMillisecondBuilder.prototype._setValue = setDurationMillisecond;
var DurationMicrosecondBuilder = class extends DurationBuilder {
};
DurationMicrosecondBuilder.prototype._setValue = setDurationMicrosecond;
var DurationNanosecondBuilder = class extends DurationBuilder {
};
DurationNanosecondBuilder.prototype._setValue = setDurationNanosecond;

// node_modules/apache-arrow/builder/int.mjs
var IntBuilder = class extends FixedWidthBuilder {
  setValue(index, value) {
    this._values.set(index, value);
  }
};
var Int8Builder = class extends IntBuilder {
};
var Int16Builder = class extends IntBuilder {
};
var Int32Builder = class extends IntBuilder {
};
var Int64Builder = class extends IntBuilder {
};
var Uint8Builder = class extends IntBuilder {
};
var Uint16Builder = class extends IntBuilder {
};
var Uint32Builder = class extends IntBuilder {
};
var Uint64Builder = class extends IntBuilder {
};

// node_modules/apache-arrow/builder/list.mjs
var ListBuilder = class extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._offsets = new OffsetsBufferBuilder();
  }
  addChild(child, name2 = "0") {
    if (this.numChildren > 0) {
      throw new Error("ListBuilder can only have one child.");
    }
    this.children[this.numChildren] = child;
    this.type = new List(new Field2(name2, child.type, true));
    return this.numChildren - 1;
  }
  _flushPending(pending) {
    const offsets = this._offsets;
    const [child] = this.children;
    for (const [index, value] of pending) {
      if (typeof value === "undefined") {
        offsets.set(index, 0);
      } else {
        const v = value;
        const n2 = v.length;
        const start = offsets.set(index, n2).buffer[index];
        for (let i2 = -1; ++i2 < n2; ) {
          child.set(start + i2, v[i2]);
        }
      }
    }
  }
};

// node_modules/apache-arrow/builder/map.mjs
var MapBuilder = class extends VariableWidthBuilder {
  set(index, value) {
    return super.set(index, value);
  }
  setValue(index, value) {
    const row = value instanceof Map ? value : new Map(Object.entries(value));
    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
    const current2 = pending.get(index);
    current2 && (this._pendingLength -= current2.size);
    this._pendingLength += row.size;
    pending.set(index, row);
  }
  addChild(child, name2 = `${this.numChildren}`) {
    if (this.numChildren > 0) {
      throw new Error("ListBuilder can only have one child.");
    }
    this.children[this.numChildren] = child;
    this.type = new Map_(new Field2(name2, child.type, true), this.type.keysSorted);
    return this.numChildren - 1;
  }
  _flushPending(pending) {
    const offsets = this._offsets;
    const [child] = this.children;
    for (const [index, value] of pending) {
      if (value === void 0) {
        offsets.set(index, 0);
      } else {
        let { [index]: idx, [index + 1]: end } = offsets.set(index, value.size).buffer;
        for (const val of value.entries()) {
          child.set(idx, val);
          if (++idx >= end)
            break;
        }
      }
    }
  }
};

// node_modules/apache-arrow/builder/null.mjs
var NullBuilder = class extends Builder {
  // @ts-ignore
  setValue(index, value) {
  }
  setValid(index, valid) {
    this.length = Math.max(index + 1, this.length);
    return valid;
  }
};

// node_modules/apache-arrow/builder/struct.mjs
var StructBuilder = class extends Builder {
  setValue(index, value) {
    const { children, type } = this;
    switch (Array.isArray(value) || value.constructor) {
      case true:
        return type.children.forEach((_, i2) => children[i2].set(index, value[i2]));
      case Map:
        return type.children.forEach((f, i2) => children[i2].set(index, value.get(f.name)));
      default:
        return type.children.forEach((f, i2) => children[i2].set(index, value[f.name]));
    }
  }
  /** @inheritdoc */
  setValid(index, valid) {
    if (!super.setValid(index, valid)) {
      this.children.forEach((child) => child.setValid(index, valid));
    }
    return valid;
  }
  addChild(child, name2 = `${this.numChildren}`) {
    const childIndex = this.children.push(child);
    this.type = new Struct([...this.type.children, new Field2(name2, child.type, true)]);
    return childIndex;
  }
};

// node_modules/apache-arrow/builder/timestamp.mjs
var TimestampBuilder = class extends FixedWidthBuilder {
};
TimestampBuilder.prototype._setValue = setTimestamp;
var TimestampSecondBuilder = class extends TimestampBuilder {
};
TimestampSecondBuilder.prototype._setValue = setTimestampSecond;
var TimestampMillisecondBuilder = class extends TimestampBuilder {
};
TimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;
var TimestampMicrosecondBuilder = class extends TimestampBuilder {
};
TimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;
var TimestampNanosecondBuilder = class extends TimestampBuilder {
};
TimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;

// node_modules/apache-arrow/builder/time.mjs
var TimeBuilder = class extends FixedWidthBuilder {
};
TimeBuilder.prototype._setValue = setTime;
var TimeSecondBuilder = class extends TimeBuilder {
};
TimeSecondBuilder.prototype._setValue = setTimeSecond;
var TimeMillisecondBuilder = class extends TimeBuilder {
};
TimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;
var TimeMicrosecondBuilder = class extends TimeBuilder {
};
TimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;
var TimeNanosecondBuilder = class extends TimeBuilder {
};
TimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;

// node_modules/apache-arrow/builder/union.mjs
var UnionBuilder = class extends Builder {
  constructor(options) {
    super(options);
    this._typeIds = new DataBufferBuilder(new Int8Array(0), 1);
    if (typeof options["valueToChildTypeId"] === "function") {
      this._valueToChildTypeId = options["valueToChildTypeId"];
    }
  }
  get typeIdToChildIndex() {
    return this.type.typeIdToChildIndex;
  }
  append(value, childTypeId) {
    return this.set(this.length, value, childTypeId);
  }
  set(index, value, childTypeId) {
    if (childTypeId === void 0) {
      childTypeId = this._valueToChildTypeId(this, value, index);
    }
    this.setValue(index, value, childTypeId);
    return this;
  }
  setValue(index, value, childTypeId) {
    this._typeIds.set(index, childTypeId);
    const childIndex = this.type.typeIdToChildIndex[childTypeId];
    const child = this.children[childIndex];
    child === null || child === void 0 ? void 0 : child.set(index, value);
  }
  addChild(child, name2 = `${this.children.length}`) {
    const childTypeId = this.children.push(child);
    const { type: { children, mode, typeIds } } = this;
    const fields = [...children, new Field2(name2, child.type)];
    this.type = new Union_(mode, [...typeIds, childTypeId], fields);
    return childTypeId;
  }
  /** @ignore */
  // @ts-ignore
  _valueToChildTypeId(builder, value, offset2) {
    throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
  }
};
var SparseUnionBuilder = class extends UnionBuilder {
};
var DenseUnionBuilder = class extends UnionBuilder {
  constructor(options) {
    super(options);
    this._offsets = new DataBufferBuilder(new Int32Array(0));
  }
  /** @ignore */
  setValue(index, value, childTypeId) {
    const id = this._typeIds.set(index, childTypeId).buffer[index];
    const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
    const denseIndex = this._offsets.set(index, child.length).buffer[index];
    child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
  }
};

// node_modules/apache-arrow/builder/utf8.mjs
var Utf8Builder = class extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(new Uint8Array(0));
  }
  get byteLength() {
    let size = this._pendingLength + this.length * 4;
    this._offsets && (size += this._offsets.byteLength);
    this._values && (size += this._values.byteLength);
    this._nulls && (size += this._nulls.byteLength);
    return size;
  }
  setValue(index, value) {
    return super.setValue(index, encodeUtf8(value));
  }
  // @ts-ignore
  _flushPending(pending, pendingLength) {
  }
};
Utf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;

// node_modules/apache-arrow/visitor/builderctor.mjs
var GetBuilderCtor = class extends Visitor {
  visitNull() {
    return NullBuilder;
  }
  visitBool() {
    return BoolBuilder;
  }
  visitInt() {
    return IntBuilder;
  }
  visitInt8() {
    return Int8Builder;
  }
  visitInt16() {
    return Int16Builder;
  }
  visitInt32() {
    return Int32Builder;
  }
  visitInt64() {
    return Int64Builder;
  }
  visitUint8() {
    return Uint8Builder;
  }
  visitUint16() {
    return Uint16Builder;
  }
  visitUint32() {
    return Uint32Builder;
  }
  visitUint64() {
    return Uint64Builder;
  }
  visitFloat() {
    return FloatBuilder;
  }
  visitFloat16() {
    return Float16Builder;
  }
  visitFloat32() {
    return Float32Builder;
  }
  visitFloat64() {
    return Float64Builder;
  }
  visitUtf8() {
    return Utf8Builder;
  }
  visitBinary() {
    return BinaryBuilder;
  }
  visitFixedSizeBinary() {
    return FixedSizeBinaryBuilder;
  }
  visitDate() {
    return DateBuilder;
  }
  visitDateDay() {
    return DateDayBuilder;
  }
  visitDateMillisecond() {
    return DateMillisecondBuilder;
  }
  visitTimestamp() {
    return TimestampBuilder;
  }
  visitTimestampSecond() {
    return TimestampSecondBuilder;
  }
  visitTimestampMillisecond() {
    return TimestampMillisecondBuilder;
  }
  visitTimestampMicrosecond() {
    return TimestampMicrosecondBuilder;
  }
  visitTimestampNanosecond() {
    return TimestampNanosecondBuilder;
  }
  visitTime() {
    return TimeBuilder;
  }
  visitTimeSecond() {
    return TimeSecondBuilder;
  }
  visitTimeMillisecond() {
    return TimeMillisecondBuilder;
  }
  visitTimeMicrosecond() {
    return TimeMicrosecondBuilder;
  }
  visitTimeNanosecond() {
    return TimeNanosecondBuilder;
  }
  visitDecimal() {
    return DecimalBuilder;
  }
  visitList() {
    return ListBuilder;
  }
  visitStruct() {
    return StructBuilder;
  }
  visitUnion() {
    return UnionBuilder;
  }
  visitDenseUnion() {
    return DenseUnionBuilder;
  }
  visitSparseUnion() {
    return SparseUnionBuilder;
  }
  visitDictionary() {
    return DictionaryBuilder;
  }
  visitInterval() {
    return IntervalBuilder;
  }
  visitIntervalDayTime() {
    return IntervalDayTimeBuilder;
  }
  visitIntervalYearMonth() {
    return IntervalYearMonthBuilder;
  }
  visitDuration() {
    return DurationBuilder;
  }
  visitDurationSecond() {
    return DurationSecondBuilder;
  }
  visitDurationMillisecond() {
    return DurationMillisecondBuilder;
  }
  visitDurationMicrosecond() {
    return DurationMicrosecondBuilder;
  }
  visistDurationNanosecond() {
    return DurationNanosecondBuilder;
  }
  visitFixedSizeList() {
    return FixedSizeListBuilder;
  }
  visitMap() {
    return MapBuilder;
  }
};
var instance6 = new GetBuilderCtor();

// node_modules/apache-arrow/visitor/typecomparator.mjs
var TypeComparator = class extends Visitor {
  compareSchemas(schema, other) {
    return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
  }
  compareManyFields(fields, others) {
    return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i2) => this.compareFields(f, others[i2]));
  }
  compareFields(field, other) {
    return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && this.visit(field.type, other.type);
  }
};
function compareConstructor(type, other) {
  return other instanceof type.constructor;
}
function compareAny(type, other) {
  return type === other || compareConstructor(type, other);
}
function compareInt(type, other) {
  return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
}
function compareFloat(type, other) {
  return type === other || compareConstructor(type, other) && type.precision === other.precision;
}
function compareFixedSizeBinary(type, other) {
  return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
}
function compareDate(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit;
}
function compareTimestamp(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
}
function compareTime(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
}
function compareList(type, other) {
  return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
}
function compareStruct(type, other) {
  return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
}
function compareUnion(type, other) {
  return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i2) => x === other.typeIds[i2]) && instance7.compareManyFields(type.children, other.children);
}
function compareDictionary(type, other) {
  return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && instance7.visit(type.indices, other.indices) && instance7.visit(type.dictionary, other.dictionary);
}
function compareInterval(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit;
}
function compareDuration(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit;
}
function compareFixedSizeList(type, other) {
  return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
}
function compareMap(type, other) {
  return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
}
TypeComparator.prototype.visitNull = compareAny;
TypeComparator.prototype.visitBool = compareAny;
TypeComparator.prototype.visitInt = compareInt;
TypeComparator.prototype.visitInt8 = compareInt;
TypeComparator.prototype.visitInt16 = compareInt;
TypeComparator.prototype.visitInt32 = compareInt;
TypeComparator.prototype.visitInt64 = compareInt;
TypeComparator.prototype.visitUint8 = compareInt;
TypeComparator.prototype.visitUint16 = compareInt;
TypeComparator.prototype.visitUint32 = compareInt;
TypeComparator.prototype.visitUint64 = compareInt;
TypeComparator.prototype.visitFloat = compareFloat;
TypeComparator.prototype.visitFloat16 = compareFloat;
TypeComparator.prototype.visitFloat32 = compareFloat;
TypeComparator.prototype.visitFloat64 = compareFloat;
TypeComparator.prototype.visitUtf8 = compareAny;
TypeComparator.prototype.visitBinary = compareAny;
TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
TypeComparator.prototype.visitDate = compareDate;
TypeComparator.prototype.visitDateDay = compareDate;
TypeComparator.prototype.visitDateMillisecond = compareDate;
TypeComparator.prototype.visitTimestamp = compareTimestamp;
TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
TypeComparator.prototype.visitTime = compareTime;
TypeComparator.prototype.visitTimeSecond = compareTime;
TypeComparator.prototype.visitTimeMillisecond = compareTime;
TypeComparator.prototype.visitTimeMicrosecond = compareTime;
TypeComparator.prototype.visitTimeNanosecond = compareTime;
TypeComparator.prototype.visitDecimal = compareAny;
TypeComparator.prototype.visitList = compareList;
TypeComparator.prototype.visitStruct = compareStruct;
TypeComparator.prototype.visitUnion = compareUnion;
TypeComparator.prototype.visitDenseUnion = compareUnion;
TypeComparator.prototype.visitSparseUnion = compareUnion;
TypeComparator.prototype.visitDictionary = compareDictionary;
TypeComparator.prototype.visitInterval = compareInterval;
TypeComparator.prototype.visitIntervalDayTime = compareInterval;
TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
TypeComparator.prototype.visitDuration = compareDuration;
TypeComparator.prototype.visitDurationSecond = compareDuration;
TypeComparator.prototype.visitDurationMillisecond = compareDuration;
TypeComparator.prototype.visitDurationMicrosecond = compareDuration;
TypeComparator.prototype.visitDurationNanosecond = compareDuration;
TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
TypeComparator.prototype.visitMap = compareMap;
var instance7 = new TypeComparator();
function compareSchemas(schema, other) {
  return instance7.compareSchemas(schema, other);
}
function compareFields(field, other) {
  return instance7.compareFields(field, other);
}
function compareTypes(type, other) {
  return instance7.visit(type, other);
}

// node_modules/apache-arrow/factories.mjs
function makeBuilder(options) {
  const type = options.type;
  const builder = new (instance6.getVisitFn(type)())(options);
  if (type.children && type.children.length > 0) {
    const children = options["children"] || [];
    const defaultOptions2 = { "nullValues": options["nullValues"] };
    const getChildOptions = Array.isArray(children) ? (_, i2) => children[i2] || defaultOptions2 : ({ name: name2 }) => children[name2] || defaultOptions2;
    for (const [index, field] of type.children.entries()) {
      const { type: type2 } = field;
      const opts = getChildOptions(field, index);
      builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type2 })));
    }
  }
  return builder;
}

// node_modules/apache-arrow/util/recordbatch.mjs
function distributeVectorsIntoRecordBatches(schema, vecs) {
  return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
}
function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
  const fields = [...schema.fields];
  const batches = [];
  const memo = { numBatches: cols.reduce((n2, c) => Math.max(n2, c.length), 0) };
  let numBatches = 0, batchLength = 0;
  let i2 = -1;
  const numColumns = cols.length;
  let child, children = [];
  while (memo.numBatches-- > 0) {
    for (batchLength = Number.POSITIVE_INFINITY, i2 = -1; ++i2 < numColumns; ) {
      children[i2] = child = cols[i2].shift();
      batchLength = Math.min(batchLength, child ? child.length : batchLength);
    }
    if (Number.isFinite(batchLength)) {
      children = distributeChildren(fields, batchLength, children, cols, memo);
      if (batchLength > 0) {
        batches[numBatches++] = makeData({
          type: new Struct(fields),
          length: batchLength,
          nullCount: 0,
          children: children.slice()
        });
      }
    }
  }
  return [
    schema = schema.assign(fields),
    batches.map((data2) => new RecordBatch(schema, data2))
  ];
}
function distributeChildren(fields, batchLength, children, columns2, memo) {
  var _a5;
  const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
  for (let i2 = -1, n2 = columns2.length; ++i2 < n2; ) {
    const child = children[i2];
    const length = child === null || child === void 0 ? void 0 : child.length;
    if (length >= batchLength) {
      if (length === batchLength) {
        children[i2] = child;
      } else {
        children[i2] = child.slice(0, batchLength);
        memo.numBatches = Math.max(memo.numBatches, columns2[i2].unshift(child.slice(batchLength, length - batchLength)));
      }
    } else {
      const field = fields[i2];
      fields[i2] = field.clone({ nullable: true });
      children[i2] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({
        type: field.type,
        length: batchLength,
        nullCount: batchLength,
        nullBitmap: new Uint8Array(nullBitmapSize)
      });
    }
  }
  return children;
}

// node_modules/apache-arrow/table.mjs
var _a3;
var Table2 = class _Table {
  constructor(...args) {
    var _b2, _c2;
    if (args.length === 0) {
      this.batches = [];
      this.schema = new Schema2([]);
      this._offsets = [0];
      return this;
    }
    let schema;
    let offsets;
    if (args[0] instanceof Schema2) {
      schema = args.shift();
    }
    if (args.at(-1) instanceof Uint32Array) {
      offsets = args.pop();
    }
    const unwrap = (x) => {
      if (x) {
        if (x instanceof RecordBatch) {
          return [x];
        } else if (x instanceof _Table) {
          return x.batches;
        } else if (x instanceof Data2) {
          if (x.type instanceof Struct) {
            return [new RecordBatch(new Schema2(x.type.children), x)];
          }
        } else if (Array.isArray(x)) {
          return x.flatMap((v) => unwrap(v));
        } else if (typeof x[Symbol.iterator] === "function") {
          return [...x].flatMap((v) => unwrap(v));
        } else if (typeof x === "object") {
          const keys = Object.keys(x);
          const vecs = keys.map((k) => new Vector([x[k]]));
          const schema2 = new Schema2(keys.map((k, i2) => new Field2(String(k), vecs[i2].type)));
          const [, batches2] = distributeVectorsIntoRecordBatches(schema2, vecs);
          return batches2.length === 0 ? [new RecordBatch(x)] : batches2;
        }
      }
      return [];
    };
    const batches = args.flatMap((v) => unwrap(v));
    schema = (_c2 = schema !== null && schema !== void 0 ? schema : (_b2 = batches[0]) === null || _b2 === void 0 ? void 0 : _b2.schema) !== null && _c2 !== void 0 ? _c2 : new Schema2([]);
    if (!(schema instanceof Schema2)) {
      throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
    }
    for (const batch of batches) {
      if (!(batch instanceof RecordBatch)) {
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      }
      if (!compareSchemas(schema, batch.schema)) {
        throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
      }
    }
    this.schema = schema;
    this.batches = batches;
    this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);
  }
  /**
   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
   */
  get data() {
    return this.batches.map(({ data: data2 }) => data2);
  }
  /**
   * The number of columns in this Table.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this Table.
   */
  get numRows() {
    return this.data.reduce((numRows, data2) => numRows + data2.length, 0);
  }
  /**
   * The number of null rows in this Table.
   */
  get nullCount() {
    if (this._nullCount === -1) {
      this._nullCount = computeChunkNullCounts(this.data);
    }
    return this._nullCount;
  }
  /**
   * Check whether an element is null.
   *
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(index) {
    return false;
  }
  /**
   * Get an element value by position.
   *
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(index) {
    return null;
  }
  /**
   * Set an element value by position.
   *
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(index, value) {
    return;
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   *
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(element, offset2) {
    return -1;
  }
  /**
   * Get the size in bytes of an element by index.
   * @param index The index at which to get the byteLength.
   */
  // @ts-ignore
  getByteLength(index) {
    return 0;
  }
  /**
   * Iterator for rows in this Table.
   */
  [Symbol.iterator]() {
    if (this.batches.length > 0) {
      return instance4.visit(new Vector(this.data));
    }
    return new Array(0)[Symbol.iterator]();
  }
  /**
   * Return a JavaScript Array of the Table rows.
   *
   * @returns An Array of Table rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Returns a string representation of the Table rows.
   *
   * @returns A string representation of the Table rows.
   */
  toString() {
    return `[
  ${this.toArray().join(",\n  ")}
]`;
  }
  /**
   * Combines two or more Tables of the same schema.
   *
   * @param others Additional Tables to add to the end of this Tables.
   */
  concat(...others) {
    const schema = this.schema;
    const data2 = this.data.concat(others.flatMap(({ data: data3 }) => data3));
    return new _Table(schema, data2.map((data3) => new RecordBatch(schema, data3)));
  }
  /**
   * Return a zero-copy sub-section of this Table.
   *
   * @param begin The beginning of the specified portion of the Table.
   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
   */
  slice(begin, end) {
    const schema = this.schema;
    [begin, end] = clampRange({ length: this.numRows }, begin, end);
    const data2 = sliceChunks(this.data, this._offsets, begin, end);
    return new _Table(schema, data2.map((chunk) => new RecordBatch(schema, chunk)));
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   *
   * @param name The name of the child to retrieve.
   */
  getChild(name2) {
    return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name2));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   *
   * @param index The index of the child to retrieve.
   */
  getChildAt(index) {
    if (index > -1 && index < this.schema.fields.length) {
      const data2 = this.data.map((data3) => data3.children[index]);
      if (data2.length === 0) {
        const { type } = this.schema.fields[index];
        const empty2 = makeData({ type, length: 0, nullCount: 0 });
        data2.push(empty2._changeLengthAndBackfillNullBitmap(this.numRows));
      }
      return new Vector(data2);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   *
   * @param name The name of the child to overwrite.
   * @returns A new Table with the supplied child for the specified name.
   */
  setChild(name2, child) {
    var _b2;
    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name2), child);
  }
  setChildAt(index, child) {
    let schema = this.schema;
    let batches = [...this.batches];
    if (index > -1 && index < this.numCols) {
      if (!child) {
        child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
      }
      const fields = schema.fields.slice();
      const field = fields[index].clone({ type: child.type });
      const children = this.schema.fields.map((_, i2) => this.getChildAt(i2));
      [fields[index], children[index]] = [field, child];
      [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);
    }
    return new _Table(schema, batches);
  }
  /**
   * Construct a new Table containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new Table of columns matching the specified names.
   */
  select(columnNames) {
    const nameToIndex = this.schema.fields.reduce((m, f, i2) => m.set(f.name, i2), /* @__PURE__ */ new Map());
    return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
  }
  /**
   * Construct a new Table containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new Table of columns at the specified indices.
   */
  selectAt(columnIndices) {
    const schema = this.schema.selectAt(columnIndices);
    const data2 = this.batches.map((batch) => batch.selectAt(columnIndices));
    return new _Table(schema, data2);
  }
  assign(other) {
    const fields = this.schema.fields;
    const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
      const [indices2, oldToNew2] = memo;
      const i2 = fields.findIndex((f) => f.name === f2.name);
      ~i2 ? oldToNew2[i2] = newIdx : indices2.push(newIdx);
      return memo;
    }, [[], []]);
    const schema = this.schema.assign(other.schema);
    const columns2 = [
      ...fields.map((_, i2) => [i2, oldToNew[i2]]).map(([i2, j]) => j === void 0 ? this.getChildAt(i2) : other.getChildAt(j)),
      ...indices.map((i2) => other.getChildAt(i2))
    ].filter(Boolean);
    return new _Table(...distributeVectorsIntoRecordBatches(schema, columns2));
  }
};
_a3 = Symbol.toStringTag;
Table2[_a3] = ((proto2) => {
  proto2.schema = null;
  proto2.batches = [];
  proto2._offsets = new Uint32Array([0]);
  proto2._nullCount = -1;
  proto2[Symbol.isConcatSpreadable] = true;
  proto2["isValid"] = wrapChunkedCall1(isChunkedValid);
  proto2["get"] = wrapChunkedCall1(instance2.getVisitFn(Type.Struct));
  proto2["set"] = wrapChunkedCall2(instance.getVisitFn(Type.Struct));
  proto2["indexOf"] = wrapChunkedIndexOf(instance3.getVisitFn(Type.Struct));
  proto2["getByteLength"] = wrapChunkedCall1(instance5.getVisitFn(Type.Struct));
  return "Table";
})(Table2.prototype);

// node_modules/apache-arrow/recordbatch.mjs
var _a4;
var RecordBatch = class _RecordBatch {
  constructor(...args) {
    switch (args.length) {
      case 2: {
        [this.schema] = args;
        if (!(this.schema instanceof Schema2)) {
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        }
        [
          ,
          this.data = makeData({
            nullCount: 0,
            type: new Struct(this.schema.fields),
            children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))
          })
        ] = args;
        if (!(this.data instanceof Data2)) {
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        }
        [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
        break;
      }
      case 1: {
        const [obj] = args;
        const { fields, children, length } = Object.keys(obj).reduce((memo, name2, i2) => {
          memo.children[i2] = obj[name2];
          memo.length = Math.max(memo.length, obj[name2].length);
          memo.fields[i2] = Field2.new({ name: name2, type: obj[name2].type, nullable: true });
          return memo;
        }, {
          length: 0,
          fields: new Array(),
          children: new Array()
        });
        const schema = new Schema2(fields);
        const data2 = makeData({ type: new Struct(fields), length, children, nullCount: 0 });
        [this.schema, this.data] = ensureSameLengthData(schema, data2.children, length);
        break;
      }
      default:
        throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
    }
  }
  get dictionaries() {
    return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
  }
  /**
   * The number of columns in this RecordBatch.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this RecordBatch.
   */
  get numRows() {
    return this.data.length;
  }
  /**
   * The number of null rows in this RecordBatch.
   */
  get nullCount() {
    return this.data.nullCount;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  isValid(index) {
    return this.data.getValid(index);
  }
  /**
   * Get a row by position.
   * @param index The index of the element to read.
   */
  get(index) {
    return instance2.visit(this.data, index);
  }
  /**
   * Set a row by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  set(index, value) {
    return instance.visit(this.data, index, value);
  }
  /**
   * Retrieve the index of the first occurrence of a row in an RecordBatch.
   * @param element The row to locate in the RecordBatch.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  indexOf(element, offset2) {
    return instance3.visit(this.data, element, offset2);
  }
  /**
   * Get the size (in bytes) of a row by index.
   * @param index The row index for which to compute the byteLength.
   */
  getByteLength(index) {
    return instance5.visit(this.data, index);
  }
  /**
   * Iterator for rows in this RecordBatch.
   */
  [Symbol.iterator]() {
    return instance4.visit(new Vector([this.data]));
  }
  /**
   * Return a JavaScript Array of the RecordBatch rows.
   * @returns An Array of RecordBatch rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Combines two or more RecordBatch of the same schema.
   * @param others Additional RecordBatch to add to the end of this RecordBatch.
   */
  concat(...others) {
    return new Table2(this.schema, [this, ...others]);
  }
  /**
   * Return a zero-copy sub-section of this RecordBatch.
   * @param start The beginning of the specified portion of the RecordBatch.
   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
   */
  slice(begin, end) {
    const [slice] = new Vector([this.data]).slice(begin, end).data;
    return new _RecordBatch(this.schema, slice);
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(name2) {
    var _b2;
    return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name2));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(index) {
    if (index > -1 && index < this.schema.fields.length) {
      return new Vector([this.data.children[index]]);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   * @param name The name of the child to overwrite.
   * @returns A new RecordBatch with the new child for the specified name.
   */
  setChild(name2, child) {
    var _b2;
    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name2), child);
  }
  setChildAt(index, child) {
    let schema = this.schema;
    let data2 = this.data;
    if (index > -1 && index < this.numCols) {
      if (!child) {
        child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
      }
      const fields = schema.fields.slice();
      const children = data2.children.slice();
      const field = fields[index].clone({ type: child.type });
      [fields[index], children[index]] = [field, child.data[0]];
      schema = new Schema2(fields, new Map(this.schema.metadata));
      data2 = makeData({ type: new Struct(fields), children });
    }
    return new _RecordBatch(schema, data2);
  }
  /**
   * Construct a new RecordBatch containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new RecordBatch of columns matching the specified names.
   */
  select(columnNames) {
    const schema = this.schema.select(columnNames);
    const type = new Struct(schema.fields);
    const children = [];
    for (const name2 of columnNames) {
      const index = this.schema.fields.findIndex((f) => f.name === name2);
      if (~index) {
        children[index] = this.data.children[index];
      }
    }
    return new _RecordBatch(schema, makeData({ type, length: this.numRows, children }));
  }
  /**
   * Construct a new RecordBatch containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new RecordBatch of columns matching at the specified indices.
   */
  selectAt(columnIndices) {
    const schema = this.schema.selectAt(columnIndices);
    const children = columnIndices.map((i2) => this.data.children[i2]).filter(Boolean);
    const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });
    return new _RecordBatch(schema, subset);
  }
};
_a4 = Symbol.toStringTag;
RecordBatch[_a4] = ((proto2) => {
  proto2._nullCount = -1;
  proto2[Symbol.isConcatSpreadable] = true;
  return "RecordBatch";
})(RecordBatch.prototype);
function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {
  var _b2;
  const fields = [...schema.fields];
  const children = [...chunks];
  const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
  for (const [idx, field] of schema.fields.entries()) {
    const chunk = chunks[idx];
    if (!chunk || chunk.length !== maxLength) {
      fields[idx] = field.clone({ nullable: true });
      children[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({
        type: field.type,
        length: maxLength,
        nullCount: maxLength,
        nullBitmap: new Uint8Array(nullBitmapSize)
      });
    }
  }
  return [
    schema.assign(fields),
    makeData({ type: new Struct(fields), length: maxLength, children })
  ];
}
function collectDictionaries(fields, children, dictionaries = /* @__PURE__ */ new Map()) {
  var _b2, _c2;
  if (((_b2 = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b2 !== void 0 ? _b2 : 0) > 0 && (fields === null || fields === void 0 ? void 0 : fields.length) === (children === null || children === void 0 ? void 0 : children.length)) {
    for (let i2 = -1, n2 = fields.length; ++i2 < n2; ) {
      const { type } = fields[i2];
      const data2 = children[i2];
      for (const next of [data2, ...((_c2 = data2 === null || data2 === void 0 ? void 0 : data2.dictionary) === null || _c2 === void 0 ? void 0 : _c2.data) || []]) {
        collectDictionaries(type.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);
      }
      if (DataType.isDictionary(type)) {
        const { id } = type;
        if (!dictionaries.has(id)) {
          if (data2 === null || data2 === void 0 ? void 0 : data2.dictionary) {
            dictionaries.set(id, data2.dictionary);
          }
        } else if (dictionaries.get(id) !== data2.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
    }
  }
  return dictionaries;
}
var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {
  constructor(schema) {
    const children = schema.fields.map((f) => makeData({ type: f.type }));
    const data2 = makeData({ type: new Struct(schema.fields), nullCount: 0, children });
    super(schema, data2);
  }
};

// node_modules/apache-arrow/fb/body-compression-method.mjs
var BodyCompressionMethod;
(function(BodyCompressionMethod2) {
  BodyCompressionMethod2[BodyCompressionMethod2["BUFFER"] = 0] = "BUFFER";
})(BodyCompressionMethod || (BodyCompressionMethod = {}));

// node_modules/apache-arrow/fb/compression-type.mjs
var CompressionType;
(function(CompressionType2) {
  CompressionType2[CompressionType2["LZ4_FRAME"] = 0] = "LZ4_FRAME";
  CompressionType2[CompressionType2["ZSTD"] = 1] = "ZSTD";
})(CompressionType || (CompressionType = {}));

// node_modules/apache-arrow/fb/body-compression.mjs
var BodyCompression = class _BodyCompression {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsBodyCompression(bb, obj) {
    return (obj || new _BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsBodyCompression(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  /**
   * Compressor library.
   * For LZ4_FRAME, each compressed buffer must consist of a single frame.
   */
  codec() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : CompressionType.LZ4_FRAME;
  }
  /**
   * Indicates the way the record batch body was compressed
   */
  method() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : BodyCompressionMethod.BUFFER;
  }
  static startBodyCompression(builder) {
    builder.startObject(2);
  }
  static addCodec(builder, codec) {
    builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
  }
  static addMethod(builder, method) {
    builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);
  }
  static endBodyCompression(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createBodyCompression(builder, codec, method) {
    _BodyCompression.startBodyCompression(builder);
    _BodyCompression.addCodec(builder, codec);
    _BodyCompression.addMethod(builder, method);
    return _BodyCompression.endBodyCompression(builder);
  }
};

// node_modules/apache-arrow/fb/buffer.mjs
var Buffer = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  /**
   * The relative offset into the shared memory page where the bytes for this
   * buffer starts
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The absolute length (in bytes) of the memory buffer. The memory is found
   * from offset (inclusive) to offset + length (non-inclusive). When building
   * messages using the encapsulated IPC message, padding bytes may be written
   * after a buffer, but such padding bytes do not need to be accounted for in
   * the size here.
   */
  length() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createBuffer(builder, offset2, length) {
    builder.prep(8, 16);
    builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
    builder.writeInt64(BigInt(offset2 !== null && offset2 !== void 0 ? offset2 : 0));
    return builder.offset();
  }
};

// node_modules/apache-arrow/fb/field-node.mjs
var FieldNode = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  /**
   * The number of value slots in the Arrow array at this level of a nested
   * tree
   */
  length() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The number of observed nulls. Fields with null_count == 0 may choose not
   * to write their physical validity bitmap out as a materialized buffer,
   * instead setting the length of the bitmap buffer to 0.
   */
  nullCount() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createFieldNode(builder, length, null_count) {
    builder.prep(8, 16);
    builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));
    builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
    return builder.offset();
  }
};

// node_modules/apache-arrow/fb/record-batch.mjs
var RecordBatch2 = class _RecordBatch {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsRecordBatch(bb, obj) {
    return (obj || new _RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsRecordBatch(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  /**
   * number of records / rows. The arrays in the batch should all have this
   * length
   */
  length() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  /**
   * Nodes correspond to the pre-ordered flattened logical schema
   */
  nodes(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset2) + index * 16, this.bb) : null;
  }
  nodesLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * Buffers correspond to the pre-ordered flattened buffer tree
   *
   * The number of buffers appended to this list depends on the schema. For
   * example, most primitive arrays will have 2 buffers, 1 for the validity
   * bitmap and 1 for the values. For struct arrays, there will only be a
   * single buffer for the validity (nulls) bitmap
   */
  buffers(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? (obj || new Buffer()).__init(this.bb.__vector(this.bb_pos + offset2) + index * 16, this.bb) : null;
  }
  buffersLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * Optional compression of the message body
   */
  compression(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  static startRecordBatch(builder) {
    builder.startObject(4);
  }
  static addLength(builder, length) {
    builder.addFieldInt64(0, length, BigInt("0"));
  }
  static addNodes(builder, nodesOffset) {
    builder.addFieldOffset(1, nodesOffset, 0);
  }
  static startNodesVector(builder, numElems) {
    builder.startVector(16, numElems, 8);
  }
  static addBuffers(builder, buffersOffset) {
    builder.addFieldOffset(2, buffersOffset, 0);
  }
  static startBuffersVector(builder, numElems) {
    builder.startVector(16, numElems, 8);
  }
  static addCompression(builder, compressionOffset) {
    builder.addFieldOffset(3, compressionOffset, 0);
  }
  static endRecordBatch(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// node_modules/apache-arrow/fb/dictionary-batch.mjs
var DictionaryBatch = class _DictionaryBatch {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsDictionaryBatch(bb, obj) {
    return (obj || new _DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  id() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  data(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  /**
   * If isDelta is true the values in the dictionary are to be appended to a
   * dictionary with the indicated id. If isDelta is false this dictionary
   * should replace the existing dictionary.
   */
  isDelta() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  static startDictionaryBatch(builder) {
    builder.startObject(3);
  }
  static addId(builder, id) {
    builder.addFieldInt64(0, id, BigInt("0"));
  }
  static addData(builder, dataOffset) {
    builder.addFieldOffset(1, dataOffset, 0);
  }
  static addIsDelta(builder, isDelta) {
    builder.addFieldInt8(2, +isDelta, 0);
  }
  static endDictionaryBatch(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// node_modules/apache-arrow/fb/sparse-matrix-compressed-axis.mjs
var SparseMatrixCompressedAxis;
(function(SparseMatrixCompressedAxis2) {
  SparseMatrixCompressedAxis2[SparseMatrixCompressedAxis2["Row"] = 0] = "Row";
  SparseMatrixCompressedAxis2[SparseMatrixCompressedAxis2["Column"] = 1] = "Column";
})(SparseMatrixCompressedAxis || (SparseMatrixCompressedAxis = {}));

// node_modules/apache-arrow/fb/sparse-tensor-index.mjs
var SparseTensorIndex;
(function(SparseTensorIndex2) {
  SparseTensorIndex2[SparseTensorIndex2["NONE"] = 0] = "NONE";
  SparseTensorIndex2[SparseTensorIndex2["SparseTensorIndexCOO"] = 1] = "SparseTensorIndexCOO";
  SparseTensorIndex2[SparseTensorIndex2["SparseMatrixIndexCSX"] = 2] = "SparseMatrixIndexCSX";
  SparseTensorIndex2[SparseTensorIndex2["SparseTensorIndexCSF"] = 3] = "SparseTensorIndexCSF";
})(SparseTensorIndex || (SparseTensorIndex = {}));

// node_modules/apache-arrow/fb/message-header.mjs
var MessageHeader2;
(function(MessageHeader3) {
  MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
  MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
  MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
  MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
  MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
  MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader2 || (MessageHeader2 = {}));

// node_modules/apache-arrow/fb/message.mjs
var Message = class _Message {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i2, bb) {
    this.bb_pos = i2;
    this.bb = bb;
    return this;
  }
  static getRootAsMessage(bb, obj) {
    return (obj || new _Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsMessage(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  version() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion2.V1;
  }
  headerType() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : MessageHeader2.NONE;
  }
  header(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;
  }
  bodyLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  customMetadata(index, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startMessage(builder) {
    builder.startObject(5);
  }
  static addVersion(builder, version3) {
    builder.addFieldInt16(0, version3, MetadataVersion2.V1);
  }
  static addHeaderType(builder, headerType) {
    builder.addFieldInt8(1, headerType, MessageHeader2.NONE);
  }
  static addHeader(builder, headerOffset) {
    builder.addFieldOffset(2, headerOffset, 0);
  }
  static addBodyLength(builder, bodyLength) {
    builder.addFieldInt64(3, bodyLength, BigInt("0"));
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(4, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data2) {
    builder.startVector(4, data2.length, 4);
    for (let i2 = data2.length - 1; i2 >= 0; i2--) {
      builder.addOffset(data2[i2]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endMessage(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static finishMessageBuffer(builder, offset2) {
    builder.finish(offset2);
  }
  static finishSizePrefixedMessageBuffer(builder, offset2) {
    builder.finish(offset2, void 0, true);
  }
  static createMessage(builder, version3, headerType, headerOffset, bodyLength, customMetadataOffset) {
    _Message.startMessage(builder);
    _Message.addVersion(builder, version3);
    _Message.addHeaderType(builder, headerType);
    _Message.addHeader(builder, headerOffset);
    _Message.addBodyLength(builder, bodyLength);
    _Message.addCustomMetadata(builder, customMetadataOffset);
    return _Message.endMessage(builder);
  }
};

// node_modules/apache-arrow/visitor/typeassembler.mjs
var TypeAssembler = class extends Visitor {
  visit(node, builder) {
    return node == null || builder == null ? void 0 : super.visit(node, builder);
  }
  visitNull(_node, b) {
    Null2.startNull(b);
    return Null2.endNull(b);
  }
  visitInt(node, b) {
    Int.startInt(b);
    Int.addBitWidth(b, node.bitWidth);
    Int.addIsSigned(b, node.isSigned);
    return Int.endInt(b);
  }
  visitFloat(node, b) {
    FloatingPoint.startFloatingPoint(b);
    FloatingPoint.addPrecision(b, node.precision);
    return FloatingPoint.endFloatingPoint(b);
  }
  visitBinary(_node, b) {
    Binary2.startBinary(b);
    return Binary2.endBinary(b);
  }
  visitBool(_node, b) {
    Bool2.startBool(b);
    return Bool2.endBool(b);
  }
  visitUtf8(_node, b) {
    Utf82.startUtf8(b);
    return Utf82.endUtf8(b);
  }
  visitDecimal(node, b) {
    Decimal2.startDecimal(b);
    Decimal2.addScale(b, node.scale);
    Decimal2.addPrecision(b, node.precision);
    Decimal2.addBitWidth(b, node.bitWidth);
    return Decimal2.endDecimal(b);
  }
  visitDate(node, b) {
    Date2.startDate(b);
    Date2.addUnit(b, node.unit);
    return Date2.endDate(b);
  }
  visitTime(node, b) {
    Time.startTime(b);
    Time.addUnit(b, node.unit);
    Time.addBitWidth(b, node.bitWidth);
    return Time.endTime(b);
  }
  visitTimestamp(node, b) {
    const timezone = node.timezone && b.createString(node.timezone) || void 0;
    Timestamp.startTimestamp(b);
    Timestamp.addUnit(b, node.unit);
    if (timezone !== void 0) {
      Timestamp.addTimezone(b, timezone);
    }
    return Timestamp.endTimestamp(b);
  }
  visitInterval(node, b) {
    Interval.startInterval(b);
    Interval.addUnit(b, node.unit);
    return Interval.endInterval(b);
  }
  visitDuration(node, b) {
    Duration2.startDuration(b);
    Duration2.addUnit(b, node.unit);
    return Duration2.endDuration(b);
  }
  visitList(_node, b) {
    List2.startList(b);
    return List2.endList(b);
  }
  visitStruct(_node, b) {
    Struct_.startStruct_(b);
    return Struct_.endStruct_(b);
  }
  visitUnion(node, b) {
    Union.startTypeIdsVector(b, node.typeIds.length);
    const typeIds = Union.createTypeIdsVector(b, node.typeIds);
    Union.startUnion(b);
    Union.addMode(b, node.mode);
    Union.addTypeIds(b, typeIds);
    return Union.endUnion(b);
  }
  visitDictionary(node, b) {
    const indexType = this.visit(node.indices, b);
    DictionaryEncoding.startDictionaryEncoding(b);
    DictionaryEncoding.addId(b, BigInt(node.id));
    DictionaryEncoding.addIsOrdered(b, node.isOrdered);
    if (indexType !== void 0) {
      DictionaryEncoding.addIndexType(b, indexType);
    }
    return DictionaryEncoding.endDictionaryEncoding(b);
  }
  visitFixedSizeBinary(node, b) {
    FixedSizeBinary2.startFixedSizeBinary(b);
    FixedSizeBinary2.addByteWidth(b, node.byteWidth);
    return FixedSizeBinary2.endFixedSizeBinary(b);
  }
  visitFixedSizeList(node, b) {
    FixedSizeList2.startFixedSizeList(b);
    FixedSizeList2.addListSize(b, node.listSize);
    return FixedSizeList2.endFixedSizeList(b);
  }
  visitMap(node, b) {
    Map2.startMap(b);
    Map2.addKeysSorted(b, node.keysSorted);
    return Map2.endMap(b);
  }
};
var instance8 = new TypeAssembler();

// node_modules/apache-arrow/ipc/metadata/json.mjs
function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
  return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["metadata"]), dictionaries);
}
function recordBatchFromJSON(b) {
  return new RecordBatch3(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]));
}
function dictionaryBatchFromJSON(b) {
  return new DictionaryBatch2(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
}
function schemaFieldsFromJSON(_schema, dictionaries) {
  return (_schema["fields"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
}
function fieldChildrenFromJSON(_field, dictionaries) {
  return (_field["children"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
}
function fieldNodesFromJSON(xs) {
  return (xs || []).reduce((fieldNodes, column) => [
    ...fieldNodes,
    new FieldNode2(column["count"], nullCountFromJSON(column["VALIDITY"])),
    ...fieldNodesFromJSON(column["children"])
  ], []);
}
function buffersFromJSON(xs, buffers = []) {
  for (let i2 = -1, n2 = (xs || []).length; ++i2 < n2; ) {
    const column = xs[i2];
    column["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column["VALIDITY"].length));
    column["TYPE_ID"] && buffers.push(new BufferRegion(buffers.length, column["TYPE_ID"].length));
    column["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column["OFFSET"].length));
    column["DATA"] && buffers.push(new BufferRegion(buffers.length, column["DATA"].length));
    buffers = buffersFromJSON(column["children"], buffers);
  }
  return buffers;
}
function nullCountFromJSON(validity) {
  return (validity || []).reduce((sum2, val) => sum2 + +(val === 0), 0);
}
function fieldFromJSON(_field, dictionaries) {
  let id;
  let keys;
  let field;
  let dictMeta;
  let type;
  let dictType;
  if (!dictionaries || !(dictMeta = _field["dictionary"])) {
    type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
    field = new Field2(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
  } else if (!dictionaries.has(id = dictMeta["id"])) {
    keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
    dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
    dictType = new Dictionary2(type, keys, id, dictMeta["isOrdered"]);
    field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
  } else {
    keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
    dictType = new Dictionary2(dictionaries.get(id), keys, id, dictMeta["isOrdered"]);
    field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
  }
  return field || null;
}
function customMetadataFromJSON(metadata = []) {
  return new Map(metadata.map(({ key: key2, value }) => [key2, value]));
}
function indexTypeFromJSON(_type) {
  return new Int_(_type["isSigned"], _type["bitWidth"]);
}
function typeFromJSON(f, children) {
  const typeId = f["type"]["name"];
  switch (typeId) {
    case "NONE":
      return new Null();
    case "null":
      return new Null();
    case "binary":
      return new Binary();
    case "utf8":
      return new Utf8();
    case "bool":
      return new Bool();
    case "list":
      return new List((children || [])[0]);
    case "struct":
      return new Struct(children || []);
    case "struct_":
      return new Struct(children || []);
  }
  switch (typeId) {
    case "int": {
      const t2 = f["type"];
      return new Int_(t2["isSigned"], t2["bitWidth"]);
    }
    case "floatingpoint": {
      const t2 = f["type"];
      return new Float(Precision[t2["precision"]]);
    }
    case "decimal": {
      const t2 = f["type"];
      return new Decimal(t2["scale"], t2["precision"], t2["bitWidth"]);
    }
    case "date": {
      const t2 = f["type"];
      return new Date_(DateUnit[t2["unit"]]);
    }
    case "time": {
      const t2 = f["type"];
      return new Time_(TimeUnit[t2["unit"]], t2["bitWidth"]);
    }
    case "timestamp": {
      const t2 = f["type"];
      return new Timestamp_(TimeUnit[t2["unit"]], t2["timezone"]);
    }
    case "interval": {
      const t2 = f["type"];
      return new Interval_(IntervalUnit[t2["unit"]]);
    }
    case "duration": {
      const t2 = f["type"];
      return new Duration(TimeUnit[t2["unit"]]);
    }
    case "union": {
      const t2 = f["type"];
      const [m, ...ms] = (t2["mode"] + "").toLowerCase();
      const mode = m.toUpperCase() + ms.join("");
      return new Union_(UnionMode[mode], t2["typeIds"] || [], children || []);
    }
    case "fixedsizebinary": {
      const t2 = f["type"];
      return new FixedSizeBinary(t2["byteWidth"]);
    }
    case "fixedsizelist": {
      const t2 = f["type"];
      return new FixedSizeList(t2["listSize"], (children || [])[0]);
    }
    case "map": {
      const t2 = f["type"];
      return new Map_((children || [])[0], t2["keysSorted"]);
    }
  }
  throw new Error(`Unrecognized type: "${typeId}"`);
}

// node_modules/apache-arrow/ipc/metadata/message.mjs
var Builder4 = Builder2;
var ByteBuffer3 = ByteBuffer;
var Message2 = class _Message {
  /** @nocollapse */
  static fromJSON(msg, headerType) {
    const message = new _Message(0, MetadataVersion.V5, headerType);
    message._createHeader = messageHeaderFromJSON(msg, headerType);
    return message;
  }
  /** @nocollapse */
  static decode(buf) {
    buf = new ByteBuffer3(toUint8Array(buf));
    const _message = Message.getRootAsMessage(buf);
    const bodyLength = _message.bodyLength();
    const version3 = _message.version();
    const headerType = _message.headerType();
    const message = new _Message(bodyLength, version3, headerType);
    message._createHeader = decodeMessageHeader(_message, headerType);
    return message;
  }
  /** @nocollapse */
  static encode(message) {
    const b = new Builder4();
    let headerOffset = -1;
    if (message.isSchema()) {
      headerOffset = Schema2.encode(b, message.header());
    } else if (message.isRecordBatch()) {
      headerOffset = RecordBatch3.encode(b, message.header());
    } else if (message.isDictionaryBatch()) {
      headerOffset = DictionaryBatch2.encode(b, message.header());
    }
    Message.startMessage(b);
    Message.addVersion(b, MetadataVersion.V5);
    Message.addHeader(b, headerOffset);
    Message.addHeaderType(b, message.headerType);
    Message.addBodyLength(b, BigInt(message.bodyLength));
    Message.finishMessageBuffer(b, Message.endMessage(b));
    return b.asUint8Array();
  }
  /** @nocollapse */
  static from(header, bodyLength = 0) {
    if (header instanceof Schema2) {
      return new _Message(0, MetadataVersion.V5, MessageHeader.Schema, header);
    }
    if (header instanceof RecordBatch3) {
      return new _Message(bodyLength, MetadataVersion.V5, MessageHeader.RecordBatch, header);
    }
    if (header instanceof DictionaryBatch2) {
      return new _Message(bodyLength, MetadataVersion.V5, MessageHeader.DictionaryBatch, header);
    }
    throw new Error(`Unrecognized Message header: ${header}`);
  }
  get type() {
    return this.headerType;
  }
  get version() {
    return this._version;
  }
  get headerType() {
    return this._headerType;
  }
  get bodyLength() {
    return this._bodyLength;
  }
  header() {
    return this._createHeader();
  }
  isSchema() {
    return this.headerType === MessageHeader.Schema;
  }
  isRecordBatch() {
    return this.headerType === MessageHeader.RecordBatch;
  }
  isDictionaryBatch() {
    return this.headerType === MessageHeader.DictionaryBatch;
  }
  constructor(bodyLength, version3, headerType, header) {
    this._version = version3;
    this._headerType = headerType;
    this.body = new Uint8Array(0);
    header && (this._createHeader = () => header);
    this._bodyLength = bigIntToNumber(bodyLength);
  }
};
var RecordBatch3 = class {
  get nodes() {
    return this._nodes;
  }
  get length() {
    return this._length;
  }
  get buffers() {
    return this._buffers;
  }
  constructor(length, nodes, buffers) {
    this._nodes = nodes;
    this._buffers = buffers;
    this._length = bigIntToNumber(length);
  }
};
var DictionaryBatch2 = class {
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get isDelta() {
    return this._isDelta;
  }
  get length() {
    return this.data.length;
  }
  get nodes() {
    return this.data.nodes;
  }
  get buffers() {
    return this.data.buffers;
  }
  constructor(data2, id, isDelta = false) {
    this._data = data2;
    this._isDelta = isDelta;
    this._id = bigIntToNumber(id);
  }
};
var BufferRegion = class {
  constructor(offset2, length) {
    this.offset = bigIntToNumber(offset2);
    this.length = bigIntToNumber(length);
  }
};
var FieldNode2 = class {
  constructor(length, nullCount) {
    this.length = bigIntToNumber(length);
    this.nullCount = bigIntToNumber(nullCount);
  }
};
function messageHeaderFromJSON(message, type) {
  return () => {
    switch (type) {
      case MessageHeader.Schema:
        return Schema2.fromJSON(message);
      case MessageHeader.RecordBatch:
        return RecordBatch3.fromJSON(message);
      case MessageHeader.DictionaryBatch:
        return DictionaryBatch2.fromJSON(message);
    }
    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
  };
}
function decodeMessageHeader(message, type) {
  return () => {
    switch (type) {
      case MessageHeader.Schema:
        return Schema2.decode(message.header(new Schema()), /* @__PURE__ */ new Map(), message.version());
      case MessageHeader.RecordBatch:
        return RecordBatch3.decode(message.header(new RecordBatch2()), message.version());
      case MessageHeader.DictionaryBatch:
        return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());
    }
    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
  };
}
Field2["encode"] = encodeField;
Field2["decode"] = decodeField;
Field2["fromJSON"] = fieldFromJSON;
Schema2["encode"] = encodeSchema;
Schema2["decode"] = decodeSchema;
Schema2["fromJSON"] = schemaFromJSON;
RecordBatch3["encode"] = encodeRecordBatch;
RecordBatch3["decode"] = decodeRecordBatch;
RecordBatch3["fromJSON"] = recordBatchFromJSON;
DictionaryBatch2["encode"] = encodeDictionaryBatch;
DictionaryBatch2["decode"] = decodeDictionaryBatch;
DictionaryBatch2["fromJSON"] = dictionaryBatchFromJSON;
FieldNode2["encode"] = encodeFieldNode;
FieldNode2["decode"] = decodeFieldNode;
BufferRegion["encode"] = encodeBufferRegion;
BufferRegion["decode"] = decodeBufferRegion;
function decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map(), version3 = MetadataVersion.V5) {
  const fields = decodeSchemaFields(_schema, dictionaries);
  return new Schema2(fields, decodeCustomMetadata(_schema), dictionaries, version3);
}
function decodeRecordBatch(batch, version3 = MetadataVersion.V5) {
  if (batch.compression() !== null) {
    throw new Error("Record batch compression not implemented");
  }
  return new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version3));
}
function decodeDictionaryBatch(batch, version3 = MetadataVersion.V5) {
  return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version3), batch.id(), batch.isDelta());
}
function decodeBufferRegion(b) {
  return new BufferRegion(b.offset(), b.length());
}
function decodeFieldNode(f) {
  return new FieldNode2(f.length(), f.nullCount());
}
function decodeFieldNodes(batch) {
  const nodes = [];
  for (let f, i2 = -1, j = -1, n2 = batch.nodesLength(); ++i2 < n2; ) {
    if (f = batch.nodes(i2)) {
      nodes[++j] = FieldNode2.decode(f);
    }
  }
  return nodes;
}
function decodeBuffers(batch, version3) {
  const bufferRegions = [];
  for (let b, i2 = -1, j = -1, n2 = batch.buffersLength(); ++i2 < n2; ) {
    if (b = batch.buffers(i2)) {
      if (version3 < MetadataVersion.V4) {
        b.bb_pos += 8 * (i2 + 1);
      }
      bufferRegions[++j] = BufferRegion.decode(b);
    }
  }
  return bufferRegions;
}
function decodeSchemaFields(schema, dictionaries) {
  const fields = [];
  for (let f, i2 = -1, j = -1, n2 = schema.fieldsLength(); ++i2 < n2; ) {
    if (f = schema.fields(i2)) {
      fields[++j] = Field2.decode(f, dictionaries);
    }
  }
  return fields;
}
function decodeFieldChildren(field, dictionaries) {
  const children = [];
  for (let f, i2 = -1, j = -1, n2 = field.childrenLength(); ++i2 < n2; ) {
    if (f = field.children(i2)) {
      children[++j] = Field2.decode(f, dictionaries);
    }
  }
  return children;
}
function decodeField(f, dictionaries) {
  let id;
  let field;
  let type;
  let keys;
  let dictType;
  let dictMeta;
  if (!dictionaries || !(dictMeta = f.dictionary())) {
    type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
    field = new Field2(f.name(), type, f.nullable(), decodeCustomMetadata(f));
  } else if (!dictionaries.has(id = bigIntToNumber(dictMeta.id()))) {
    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
    dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
    dictType = new Dictionary2(type, keys, id, dictMeta.isOrdered());
    field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
  } else {
    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
    dictType = new Dictionary2(dictionaries.get(id), keys, id, dictMeta.isOrdered());
    field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
  }
  return field || null;
}
function decodeCustomMetadata(parent) {
  const data2 = /* @__PURE__ */ new Map();
  if (parent) {
    for (let entry, key2, i2 = -1, n2 = Math.trunc(parent.customMetadataLength()); ++i2 < n2; ) {
      if ((entry = parent.customMetadata(i2)) && (key2 = entry.key()) != null) {
        data2.set(key2, entry.value());
      }
    }
  }
  return data2;
}
function decodeIndexType(_type) {
  return new Int_(_type.isSigned(), _type.bitWidth());
}
function decodeFieldType(f, children) {
  const typeId = f.typeType();
  switch (typeId) {
    case Type2["NONE"]:
      return new Null();
    case Type2["Null"]:
      return new Null();
    case Type2["Binary"]:
      return new Binary();
    case Type2["Utf8"]:
      return new Utf8();
    case Type2["Bool"]:
      return new Bool();
    case Type2["List"]:
      return new List((children || [])[0]);
    case Type2["Struct_"]:
      return new Struct(children || []);
  }
  switch (typeId) {
    case Type2["Int"]: {
      const t2 = f.type(new Int());
      return new Int_(t2.isSigned(), t2.bitWidth());
    }
    case Type2["FloatingPoint"]: {
      const t2 = f.type(new FloatingPoint());
      return new Float(t2.precision());
    }
    case Type2["Decimal"]: {
      const t2 = f.type(new Decimal2());
      return new Decimal(t2.scale(), t2.precision(), t2.bitWidth());
    }
    case Type2["Date"]: {
      const t2 = f.type(new Date2());
      return new Date_(t2.unit());
    }
    case Type2["Time"]: {
      const t2 = f.type(new Time());
      return new Time_(t2.unit(), t2.bitWidth());
    }
    case Type2["Timestamp"]: {
      const t2 = f.type(new Timestamp());
      return new Timestamp_(t2.unit(), t2.timezone());
    }
    case Type2["Interval"]: {
      const t2 = f.type(new Interval());
      return new Interval_(t2.unit());
    }
    case Type2["Duration"]: {
      const t2 = f.type(new Duration2());
      return new Duration(t2.unit());
    }
    case Type2["Union"]: {
      const t2 = f.type(new Union());
      return new Union_(t2.mode(), t2.typeIdsArray() || [], children || []);
    }
    case Type2["FixedSizeBinary"]: {
      const t2 = f.type(new FixedSizeBinary2());
      return new FixedSizeBinary(t2.byteWidth());
    }
    case Type2["FixedSizeList"]: {
      const t2 = f.type(new FixedSizeList2());
      return new FixedSizeList(t2.listSize(), (children || [])[0]);
    }
    case Type2["Map"]: {
      const t2 = f.type(new Map2());
      return new Map_((children || [])[0], t2.keysSorted());
    }
  }
  throw new Error(`Unrecognized type: "${Type2[typeId]}" (${typeId})`);
}
function encodeSchema(b, schema) {
  const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));
  Schema.startFieldsVector(b, fieldOffsets.length);
  const fieldsVectorOffset = Schema.createFieldsVector(b, fieldOffsets);
  const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
    const key2 = b.createString(`${k}`);
    const val = b.createString(`${v}`);
    KeyValue.startKeyValue(b);
    KeyValue.addKey(b, key2);
    KeyValue.addValue(b, val);
    return KeyValue.endKeyValue(b);
  }));
  Schema.startSchema(b);
  Schema.addFields(b, fieldsVectorOffset);
  Schema.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);
  if (metadataOffset !== -1) {
    Schema.addCustomMetadata(b, metadataOffset);
  }
  return Schema.endSchema(b);
}
function encodeField(b, field) {
  let nameOffset = -1;
  let typeOffset = -1;
  let dictionaryOffset = -1;
  const type = field.type;
  let typeId = field.typeId;
  if (!DataType.isDictionary(type)) {
    typeOffset = instance8.visit(type, b);
  } else {
    typeId = type.dictionary.typeId;
    dictionaryOffset = instance8.visit(type, b);
    typeOffset = instance8.visit(type.dictionary, b);
  }
  const childOffsets = (type.children || []).map((f) => Field2.encode(b, f));
  const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);
  const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
    const key2 = b.createString(`${k}`);
    const val = b.createString(`${v}`);
    KeyValue.startKeyValue(b);
    KeyValue.addKey(b, key2);
    KeyValue.addValue(b, val);
    return KeyValue.endKeyValue(b);
  }));
  if (field.name) {
    nameOffset = b.createString(field.name);
  }
  Field.startField(b);
  Field.addType(b, typeOffset);
  Field.addTypeType(b, typeId);
  Field.addChildren(b, childrenVectorOffset);
  Field.addNullable(b, !!field.nullable);
  if (nameOffset !== -1) {
    Field.addName(b, nameOffset);
  }
  if (dictionaryOffset !== -1) {
    Field.addDictionary(b, dictionaryOffset);
  }
  if (metadataOffset !== -1) {
    Field.addCustomMetadata(b, metadataOffset);
  }
  return Field.endField(b);
}
function encodeRecordBatch(b, recordBatch) {
  const nodes = recordBatch.nodes || [];
  const buffers = recordBatch.buffers || [];
  RecordBatch2.startNodesVector(b, nodes.length);
  for (const n2 of nodes.slice().reverse())
    FieldNode2.encode(b, n2);
  const nodesVectorOffset = b.endVector();
  RecordBatch2.startBuffersVector(b, buffers.length);
  for (const b_ of buffers.slice().reverse())
    BufferRegion.encode(b, b_);
  const buffersVectorOffset = b.endVector();
  RecordBatch2.startRecordBatch(b);
  RecordBatch2.addLength(b, BigInt(recordBatch.length));
  RecordBatch2.addNodes(b, nodesVectorOffset);
  RecordBatch2.addBuffers(b, buffersVectorOffset);
  return RecordBatch2.endRecordBatch(b);
}
function encodeDictionaryBatch(b, dictionaryBatch) {
  const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);
  DictionaryBatch.startDictionaryBatch(b);
  DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));
  DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
  DictionaryBatch.addData(b, dataOffset);
  return DictionaryBatch.endDictionaryBatch(b);
}
function encodeFieldNode(b, node) {
  return FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));
}
function encodeBufferRegion(b, node) {
  return Buffer.createBuffer(b, BigInt(node.offset), BigInt(node.length));
}
var platformIsLittleEndian = (() => {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(
    0,
    256,
    true
    /* littleEndian */
  );
  return new Int16Array(buffer)[0] === 256;
})();

// node_modules/apache-arrow/ipc/message.mjs
var invalidMessageType = (type) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;
var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;
var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
var MessageReader = class {
  constructor(source2) {
    this.source = source2 instanceof ByteStream ? source2 : new ByteStream(source2);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let r;
    if ((r = this.readMetadataLength()).done) {
      return ITERATOR_DONE;
    }
    if (r.value === -1 && (r = this.readMetadataLength()).done) {
      return ITERATOR_DONE;
    }
    if ((r = this.readMetadata(r.value)).done) {
      return ITERATOR_DONE;
    }
    return r;
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  readMessage(type) {
    let r;
    if ((r = this.next()).done) {
      return null;
    }
    if (type != null && r.value.headerType !== type) {
      throw new Error(invalidMessageType(type));
    }
    return r.value;
  }
  readMessageBody(bodyLength) {
    if (bodyLength <= 0) {
      return new Uint8Array(0);
    }
    const buf = toUint8Array(this.source.read(bodyLength));
    if (buf.byteLength < bodyLength) {
      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
    }
    return (
      /* 1. */
      buf.byteOffset % 8 === 0 && /* 2. */
      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
    );
  }
  readSchema(throwIfNull = false) {
    const type = MessageHeader.Schema;
    const message = this.readMessage(type);
    const schema = message === null || message === void 0 ? void 0 : message.header();
    if (throwIfNull && !schema) {
      throw new Error(nullMessage(type));
    }
    return schema;
  }
  readMetadataLength() {
    const buf = this.source.read(PADDING);
    const bb = buf && new ByteBuffer(buf);
    const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
    return { done: len === 0, value: len };
  }
  readMetadata(metadataLength) {
    const buf = this.source.read(metadataLength);
    if (!buf) {
      return ITERATOR_DONE;
    }
    if (buf.byteLength < metadataLength) {
      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
    }
    return { done: false, value: Message2.decode(buf) };
  }
};
var AsyncMessageReader = class {
  constructor(source2, byteLength) {
    this.source = source2 instanceof AsyncByteStream ? source2 : isFileHandle(source2) ? new AsyncRandomAccessFile(source2, byteLength) : new AsyncByteStream(source2);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next() {
    return __awaiter(this, void 0, void 0, function* () {
      let r;
      if ((r = yield this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if ((r = yield this.readMetadata(r.value)).done) {
        return ITERATOR_DONE;
      }
      return r;
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.source.throw(value);
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.source.return(value);
    });
  }
  readMessage(type) {
    return __awaiter(this, void 0, void 0, function* () {
      let r;
      if ((r = yield this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    });
  }
  readMessageBody(bodyLength) {
    return __awaiter(this, void 0, void 0, function* () {
      if (bodyLength <= 0) {
        return new Uint8Array(0);
      }
      const buf = toUint8Array(yield this.source.read(bodyLength));
      if (buf.byteLength < bodyLength) {
        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
      }
      return (
        /* 1. */
        buf.byteOffset % 8 === 0 && /* 2. */
        buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
      );
    });
  }
  readSchema(throwIfNull = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const type = MessageHeader.Schema;
      const message = yield this.readMessage(type);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (throwIfNull && !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    });
  }
  readMetadataLength() {
    return __awaiter(this, void 0, void 0, function* () {
      const buf = yield this.source.read(PADDING);
      const bb = buf && new ByteBuffer(buf);
      const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
      return { done: len === 0, value: len };
    });
  }
  readMetadata(metadataLength) {
    return __awaiter(this, void 0, void 0, function* () {
      const buf = yield this.source.read(metadataLength);
      if (!buf) {
        return ITERATOR_DONE;
      }
      if (buf.byteLength < metadataLength) {
        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
      }
      return { done: false, value: Message2.decode(buf) };
    });
  }
};
var JSONMessageReader = class extends MessageReader {
  constructor(source2) {
    super(new Uint8Array(0));
    this._schema = false;
    this._body = [];
    this._batchIndex = 0;
    this._dictionaryIndex = 0;
    this._json = source2 instanceof ArrowJSON ? source2 : new ArrowJSON(source2);
  }
  next() {
    const { _json } = this;
    if (!this._schema) {
      this._schema = true;
      const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);
      return { done: false, value: message };
    }
    if (this._dictionaryIndex < _json.dictionaries.length) {
      const batch = _json.dictionaries[this._dictionaryIndex++];
      this._body = batch["data"]["columns"];
      const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);
      return { done: false, value: message };
    }
    if (this._batchIndex < _json.batches.length) {
      const batch = _json.batches[this._batchIndex++];
      this._body = batch["columns"];
      const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);
      return { done: false, value: message };
    }
    this._body = [];
    return ITERATOR_DONE;
  }
  readMessageBody(_bodyLength) {
    return flattenDataSources(this._body);
    function flattenDataSources(xs) {
      return (xs || []).reduce((buffers, column) => [
        ...buffers,
        ...column["VALIDITY"] && [column["VALIDITY"]] || [],
        ...column["TYPE_ID"] && [column["TYPE_ID"]] || [],
        ...column["OFFSET"] && [column["OFFSET"]] || [],
        ...column["DATA"] && [column["DATA"]] || [],
        ...flattenDataSources(column["children"])
      ], []);
    }
  }
  readMessage(type) {
    let r;
    if ((r = this.next()).done) {
      return null;
    }
    if (type != null && r.value.headerType !== type) {
      throw new Error(invalidMessageType(type));
    }
    return r.value;
  }
  readSchema() {
    const type = MessageHeader.Schema;
    const message = this.readMessage(type);
    const schema = message === null || message === void 0 ? void 0 : message.header();
    if (!message || !schema) {
      throw new Error(nullMessage(type));
    }
    return schema;
  }
};
var PADDING = 4;
var MAGIC_STR = "ARROW1";
var MAGIC = new Uint8Array(MAGIC_STR.length);
for (let i2 = 0; i2 < MAGIC_STR.length; i2 += 1) {
  MAGIC[i2] = MAGIC_STR.codePointAt(i2);
}
function checkForMagicArrowString(buffer, index = 0) {
  for (let i2 = -1, n2 = MAGIC.length; ++i2 < n2; ) {
    if (MAGIC[i2] !== buffer[index + i2]) {
      return false;
    }
  }
  return true;
}
var magicLength = MAGIC.length;
var magicAndPadding = magicLength + PADDING;
var magicX2AndPadding = magicLength * 2 + PADDING;

// node_modules/apache-arrow/ipc/reader.mjs
var RecordBatchReader = class _RecordBatchReader extends ReadableInterop {
  constructor(impl) {
    super();
    this._impl = impl;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(value) {
    return this._impl.throw(value);
  }
  return(value) {
    return this._impl.return(value);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(schema) {
    this._impl.reset(schema);
    this._DOMStream = void 0;
    this._nodeStream = void 0;
    return this;
  }
  open(options) {
    const opening = this._impl.open(options);
    return isPromise(opening) ? opening.then(() => this) : this;
  }
  readRecordBatch(index) {
    return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
  }
  toNodeStream() {
    return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  static throughDOM(writableStrategy, readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /** @nocollapse */
  static from(source2) {
    if (source2 instanceof _RecordBatchReader) {
      return source2;
    } else if (isArrowJSON(source2)) {
      return fromArrowJSON(source2);
    } else if (isFileHandle(source2)) {
      return fromFileHandle(source2);
    } else if (isPromise(source2)) {
      return (() => __awaiter(this, void 0, void 0, function* () {
        return yield _RecordBatchReader.from(yield source2);
      }))();
    } else if (isFetchResponse(source2) || isReadableDOMStream(source2) || isReadableNodeStream(source2) || isAsyncIterable(source2)) {
      return fromAsyncByteStream(new AsyncByteStream(source2));
    }
    return fromByteStream(new ByteStream(source2));
  }
  /** @nocollapse */
  static readAll(source2) {
    if (source2 instanceof _RecordBatchReader) {
      return source2.isSync() ? readAllSync(source2) : readAllAsync(source2);
    } else if (isArrowJSON(source2) || ArrayBuffer.isView(source2) || isIterable(source2) || isIteratorResult(source2)) {
      return readAllSync(source2);
    }
    return readAllAsync(source2);
  }
};
var RecordBatchStreamReader = class extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, arguments, function* _a5() {
      yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));
    });
  }
};
var AsyncRecordBatchStreamReader = class extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    var _a5, e_1, _b2, _c2;
    return __awaiter(this, void 0, void 0, function* () {
      const batches = new Array();
      try {
        for (var _d2 = true, _e2 = __asyncValues(this), _f2; _f2 = yield _e2.next(), _a5 = _f2.done, !_a5; _d2 = true) {
          _c2 = _f2.value;
          _d2 = false;
          const batch = _c2;
          batches.push(batch);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d2 && !_a5 && (_b2 = _e2.return))
            yield _b2.call(_e2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return batches;
    });
  }
  [Symbol.iterator]() {
    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
};
var RecordBatchFileReader = class extends RecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
};
var AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
};
var RecordBatchReaderImpl = class {
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  constructor(dictionaries = /* @__PURE__ */ new Map()) {
    this.closed = false;
    this.autoDestroy = true;
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.dictionaries = dictionaries;
  }
  isSync() {
    return false;
  }
  isAsync() {
    return false;
  }
  isFile() {
    return false;
  }
  isStream() {
    return false;
  }
  reset(schema) {
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.schema = schema;
    this.dictionaries = /* @__PURE__ */ new Map();
    return this;
  }
  _loadRecordBatch(header, body) {
    const children = this._loadVectors(header, body, this.schema.fields);
    const data2 = makeData({ type: new Struct(this.schema.fields), length: header.length, children });
    return new RecordBatch(this.schema, data2);
  }
  _loadDictionaryBatch(header, body) {
    const { id, isDelta } = header;
    const { dictionaries, schema } = this;
    const dictionary2 = dictionaries.get(id);
    if (isDelta || !dictionary2) {
      const type = schema.dictionaries.get(id);
      const data2 = this._loadVectors(header.data, body, [type]);
      return (dictionary2 && isDelta ? dictionary2.concat(new Vector(data2)) : new Vector(data2)).memoize();
    }
    return dictionary2.memoize();
  }
  _loadVectors(header, body, types2) {
    return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types2);
  }
};
var RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
  constructor(source2, dictionaries) {
    super(dictionaries);
    this._reader = !isArrowJSON(source2) ? new MessageReader(this._handle = source2) : new JSONMessageReader(this._handle = source2);
  }
  isSync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    if (!this.closed && (this.closed = true)) {
      this.reset()._reader.return();
      this._reader = null;
      this.dictionaries = null;
    }
  }
  open(options) {
    if (!this.closed) {
      this.autoDestroy = shouldAutoDestroy(this, options);
      if (!(this.schema || (this.schema = this._reader.readSchema()))) {
        this.cancel();
      }
    }
    return this;
  }
  throw(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.throw(value);
    }
    return ITERATOR_DONE;
  }
  return(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.return(value);
    }
    return ITERATOR_DONE;
  }
  next() {
    if (this.closed) {
      return ITERATOR_DONE;
    }
    let message;
    const { _reader: reader } = this;
    while (message = this._readNextMessageAndValidate()) {
      if (message.isSchema()) {
        this.reset(message.header());
      } else if (message.isRecordBatch()) {
        this._recordBatchIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return { done: false, value: recordBatch };
      } else if (message.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const vector = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector);
      }
    }
    if (this.schema && this._recordBatchIndex === 0) {
      this._recordBatchIndex++;
      return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
    }
    return this.return();
  }
  _readNextMessageAndValidate(type) {
    return this._reader.readMessage(type);
  }
};
var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
  constructor(source2, dictionaries) {
    super(dictionaries);
    this._reader = new AsyncMessageReader(this._handle = source2);
  }
  isAsync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && (this.closed = true)) {
        yield this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    });
  }
  open(options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
          yield this.cancel();
        }
      }
      return this;
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.throw(value);
      }
      return ITERATOR_DONE;
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.return(value);
      }
      return ITERATOR_DONE;
    });
  }
  next() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return ITERATOR_DONE;
      }
      let message;
      const { _reader: reader } = this;
      while (message = yield this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          yield this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return { done: false, value: recordBatch };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
      }
      return yield this.return();
    });
  }
  _readNextMessageAndValidate(type) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this._reader.readMessage(type);
    });
  }
};
var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source2, dictionaries) {
    super(source2 instanceof RandomAccessFile ? source2 : new RandomAccessFile(source2), dictionaries);
  }
  isSync() {
    return true;
  }
  isFile() {
    return true;
  }
  open(options) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const block of this._footer.dictionaryBatches()) {
        block && this._readDictionaryBatch(this._dictionaryIndex++);
      }
    }
    return super.open(options);
  }
  readRecordBatch(index) {
    var _a5;
    if (this.closed) {
      return null;
    }
    if (!this._footer) {
      this.open();
    }
    const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(MessageHeader.RecordBatch);
      if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return recordBatch;
      }
    }
    return null;
  }
  _readDictionaryBatch(index) {
    var _a5;
    const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(MessageHeader.DictionaryBatch);
      if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const vector = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector);
      }
    }
  }
  _readFooter() {
    const { _handle } = this;
    const offset2 = _handle.size - magicAndPadding;
    const length = _handle.readInt32(offset2);
    const buffer = _handle.readAt(offset2 - length, length);
    return Footer_.decode(buffer);
  }
  _readNextMessageAndValidate(type) {
    var _a5;
    if (!this._footer) {
      this.open();
    }
    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(this._recordBatchIndex);
      if (block && this._handle.seek(block.offset)) {
        return this._reader.readMessage(type);
      }
    }
    return null;
  }
};
var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source2, ...rest) {
    const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
    const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
    super(source2 instanceof AsyncRandomAccessFile ? source2 : new AsyncRandomAccessFile(source2, byteLength), dictionaries);
  }
  isFile() {
    return true;
  }
  isAsync() {
    return true;
  }
  open(options) {
    const _super = Object.create(null, {
      open: { get: () => super.open }
    });
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
        }
      }
      return yield _super.open.call(this, options);
    });
  }
  readRecordBatch(index) {
    var _a5;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        yield this.open();
      }
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(MessageHeader.RecordBatch);
        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return recordBatch;
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(index) {
    var _a5;
    return __awaiter(this, void 0, void 0, function* () {
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);
        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
    });
  }
  _readFooter() {
    return __awaiter(this, void 0, void 0, function* () {
      const { _handle } = this;
      _handle._pending && (yield _handle._pending);
      const offset2 = _handle.size - magicAndPadding;
      const length = yield _handle.readInt32(offset2);
      const buffer = yield _handle.readAt(offset2 - length, length);
      return Footer_.decode(buffer);
    });
  }
  _readNextMessageAndValidate(type) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this._footer) {
        yield this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = this._footer.getRecordBatch(this._recordBatchIndex);
        if (block && (yield this._handle.seek(block.offset))) {
          return yield this._reader.readMessage(type);
        }
      }
      return null;
    });
  }
};
var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
  constructor(source2, dictionaries) {
    super(source2, dictionaries);
  }
  _loadVectors(header, body, types2) {
    return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types2);
  }
};
function shouldAutoDestroy(self2, options) {
  return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self2["autoDestroy"];
}
function* readAllSync(source2) {
  const reader = RecordBatchReader.from(source2);
  try {
    if (!reader.open({ autoDestroy: false }).closed) {
      do {
        yield reader;
      } while (!reader.reset().open().closed);
    }
  } finally {
    reader.cancel();
  }
}
function readAllAsync(source2) {
  return __asyncGenerator(this, arguments, function* readAllAsync_1() {
    const reader = yield __await(RecordBatchReader.from(source2));
    try {
      if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {
        do {
          yield yield __await(reader);
        } while (!(yield __await(reader.reset().open())).closed);
      }
    } finally {
      yield __await(reader.cancel());
    }
  });
}
function fromArrowJSON(source2) {
  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source2));
}
function fromByteStream(source2) {
  const bytes = source2.peek(magicLength + 7 & ~7);
  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source2)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source2.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {
  }()));
}
function fromAsyncByteStream(source2) {
  return __awaiter(this, void 0, void 0, function* () {
    const bytes = yield source2.peek(magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source2)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source2.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
      return __asyncGenerator(this, arguments, function* () {
      });
    }()));
  });
}
function fromFileHandle(source2) {
  return __awaiter(this, void 0, void 0, function* () {
    const { size } = yield source2.stat();
    const file = new AsyncRandomAccessFile(source2, size);
    if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {
      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
    }
    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
  });
}

// node_modules/apache-arrow/visitor/vectorassembler.mjs
var VectorAssembler = class _VectorAssembler extends Visitor {
  /** @nocollapse */
  static assemble(...args) {
    const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);
    const assembler = new _VectorAssembler();
    assembler.visitMany(unwrap(args));
    return assembler;
  }
  constructor() {
    super();
    this._byteLength = 0;
    this._nodes = [];
    this._buffers = [];
    this._bufferRegions = [];
  }
  visit(data2) {
    if (data2 instanceof Vector) {
      this.visitMany(data2.data);
      return this;
    }
    const { type } = data2;
    if (!DataType.isDictionary(type)) {
      const { length } = data2;
      if (length > 2147483647) {
        throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
      }
      if (DataType.isUnion(type)) {
        this.nodes.push(new FieldNode2(length, 0));
      } else {
        const { nullCount } = data2;
        if (!DataType.isNull(type)) {
          addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data2.offset, length, data2.nullBitmap));
        }
        this.nodes.push(new FieldNode2(length, nullCount));
      }
    }
    return super.visit(data2);
  }
  visitNull(_null) {
    return this;
  }
  visitDictionary(data2) {
    return this.visit(data2.clone(data2.type.indices));
  }
  get nodes() {
    return this._nodes;
  }
  get buffers() {
    return this._buffers;
  }
  get byteLength() {
    return this._byteLength;
  }
  get bufferRegions() {
    return this._bufferRegions;
  }
};
function addBuffer(values2) {
  const byteLength = values2.byteLength + 7 & ~7;
  this.buffers.push(values2);
  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));
  this._byteLength += byteLength;
  return this;
}
function assembleUnion(data2) {
  var _a5;
  const { type, length, typeIds, valueOffsets } = data2;
  addBuffer.call(this, typeIds);
  if (type.mode === UnionMode.Sparse) {
    return assembleNestedVector.call(this, data2);
  } else if (type.mode === UnionMode.Dense) {
    if (data2.offset <= 0) {
      addBuffer.call(this, valueOffsets);
      return assembleNestedVector.call(this, data2);
    } else {
      const shiftedOffsets = new Int32Array(length);
      const childOffsets = /* @__PURE__ */ Object.create(null);
      const childLengths = /* @__PURE__ */ Object.create(null);
      for (let typeId, shift, index = -1; ++index < length; ) {
        if ((typeId = typeIds[index]) === void 0) {
          continue;
        }
        if ((shift = childOffsets[typeId]) === void 0) {
          shift = childOffsets[typeId] = valueOffsets[index];
        }
        shiftedOffsets[index] = valueOffsets[index] - shift;
        childLengths[typeId] = ((_a5 = childLengths[typeId]) !== null && _a5 !== void 0 ? _a5 : 0) + 1;
      }
      addBuffer.call(this, shiftedOffsets);
      this.visitMany(data2.children.map((child, childIndex) => {
        const typeId = type.typeIds[childIndex];
        const childOffset = childOffsets[typeId];
        const childLength = childLengths[typeId];
        return child.slice(childOffset, Math.min(length, childLength));
      }));
    }
  }
  return this;
}
function assembleBoolVector(data2) {
  let values2;
  if (data2.nullCount >= data2.length) {
    return addBuffer.call(this, new Uint8Array(0));
  } else if ((values2 = data2.values) instanceof Uint8Array) {
    return addBuffer.call(this, truncateBitmap(data2.offset, data2.length, values2));
  }
  return addBuffer.call(this, packBools(data2.values));
}
function assembleFlatVector(data2) {
  return addBuffer.call(this, data2.values.subarray(0, data2.length * data2.stride));
}
function assembleFlatListVector(data2) {
  const { length, values: values2, valueOffsets } = data2;
  const { [0]: begin, [length]: end } = valueOffsets;
  const byteLength = Math.min(end - begin, values2.byteLength - begin);
  addBuffer.call(this, rebaseValueOffsets(-begin, length + 1, valueOffsets));
  addBuffer.call(this, values2.subarray(begin, begin + byteLength));
  return this;
}
function assembleListVector(data2) {
  const { length, valueOffsets } = data2;
  if (valueOffsets) {
    const { [0]: begin, [length]: end } = valueOffsets;
    addBuffer.call(this, rebaseValueOffsets(-begin, length + 1, valueOffsets));
    return this.visit(data2.children[0].slice(begin, end - begin));
  }
  return this.visit(data2.children[0]);
}
function assembleNestedVector(data2) {
  return this.visitMany(data2.type.children.map((_, i2) => data2.children[i2]).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitDuration = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleListVector;

// node_modules/apache-arrow/ipc/writer.mjs
var RecordBatchWriter = class extends ReadableInterop {
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  static throughDOM(writableStrategy, readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  constructor(options) {
    super();
    this._position = 0;
    this._started = false;
    this._sink = new AsyncByteQueue();
    this._schema = null;
    this._dictionaryBlocks = [];
    this._recordBatchBlocks = [];
    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
    isObject(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
    this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
    this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
  }
  toString(sync = false) {
    return this._sink.toString(sync);
  }
  toUint8Array(sync = false) {
    return this._sink.toUint8Array(sync);
  }
  writeAll(input) {
    if (isPromise(input)) {
      return input.then((x) => this.writeAll(x));
    } else if (isAsyncIterable(input)) {
      return writeAllAsync(this, input);
    }
    return writeAll(this, input);
  }
  get closed() {
    return this._sink.closed;
  }
  [Symbol.asyncIterator]() {
    return this._sink[Symbol.asyncIterator]();
  }
  toDOMStream(options) {
    return this._sink.toDOMStream(options);
  }
  toNodeStream(options) {
    return this._sink.toNodeStream(options);
  }
  close() {
    return this.reset()._sink.close();
  }
  abort(reason) {
    return this.reset()._sink.abort(reason);
  }
  finish() {
    this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
    return this;
  }
  reset(sink = this._sink, schema = null) {
    if (sink === this._sink || sink instanceof AsyncByteQueue) {
      this._sink = sink;
    } else {
      this._sink = new AsyncByteQueue();
      if (sink && isWritableDOMStream(sink)) {
        this.toDOMStream({ type: "bytes" }).pipeTo(sink);
      } else if (sink && isWritableNodeStream(sink)) {
        this.toNodeStream({ objectMode: false }).pipe(sink);
      }
    }
    if (this._started && this._schema) {
      this._writeFooter(this._schema);
    }
    this._started = false;
    this._dictionaryBlocks = [];
    this._recordBatchBlocks = [];
    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
    if (!schema || !compareSchemas(schema, this._schema)) {
      if (schema == null) {
        this._position = 0;
        this._schema = null;
      } else {
        this._started = true;
        this._schema = schema;
        this._writeSchema(schema);
      }
    }
    return this;
  }
  write(payload) {
    let schema = null;
    if (!this._sink) {
      throw new Error(`RecordBatchWriter is closed`);
    } else if (payload == null) {
      return this.finish() && void 0;
    } else if (payload instanceof Table2 && !(schema = payload.schema)) {
      return this.finish() && void 0;
    } else if (payload instanceof RecordBatch && !(schema = payload.schema)) {
      return this.finish() && void 0;
    }
    if (schema && !compareSchemas(schema, this._schema)) {
      if (this._started && this._autoDestroy) {
        return this.close();
      }
      this.reset(this._sink, schema);
    }
    if (payload instanceof RecordBatch) {
      if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {
        this._writeRecordBatch(payload);
      }
    } else if (payload instanceof Table2) {
      this.writeAll(payload.batches);
    } else if (isIterable(payload)) {
      this.writeAll(payload);
    }
  }
  _writeMessage(message, alignment = 8) {
    const a = alignment - 1;
    const buffer = Message2.encode(message);
    const flatbufferSize = buffer.byteLength;
    const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
    const alignedSize = flatbufferSize + prefixSize + a & ~a;
    const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
    if (message.headerType === MessageHeader.RecordBatch) {
      this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
    } else if (message.headerType === MessageHeader.DictionaryBatch) {
      this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
    }
    if (!this._writeLegacyIpcFormat) {
      this._write(Int32Array.of(-1));
    }
    this._write(Int32Array.of(alignedSize - prefixSize));
    if (flatbufferSize > 0) {
      this._write(buffer);
    }
    return this._writePadding(nPaddingBytes);
  }
  _write(chunk) {
    if (this._started) {
      const buffer = toUint8Array(chunk);
      if (buffer && buffer.byteLength > 0) {
        this._sink.write(buffer);
        this._position += buffer.byteLength;
      }
    }
    return this;
  }
  _writeSchema(schema) {
    return this._writeMessage(Message2.from(schema));
  }
  // @ts-ignore
  _writeFooter(schema) {
    return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
  }
  _writeMagic() {
    return this._write(MAGIC);
  }
  _writePadding(nBytes) {
    return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
  }
  _writeRecordBatch(batch) {
    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);
    const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);
    const message = Message2.from(recordBatch, byteLength);
    return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
  }
  _writeDictionaryBatch(dictionary2, id, isDelta = false) {
    this._dictionaryDeltaOffsets.set(id, dictionary2.length + (this._dictionaryDeltaOffsets.get(id) || 0));
    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(new Vector([dictionary2]));
    const recordBatch = new RecordBatch3(dictionary2.length, nodes, bufferRegions);
    const dictionaryBatch = new DictionaryBatch2(recordBatch, id, isDelta);
    const message = Message2.from(dictionaryBatch, byteLength);
    return this._writeMessage(message)._writeBodyBuffers(buffers);
  }
  _writeBodyBuffers(buffers) {
    let buffer;
    let size, padding;
    for (let i2 = -1, n2 = buffers.length; ++i2 < n2; ) {
      if ((buffer = buffers[i2]) && (size = buffer.byteLength) > 0) {
        this._write(buffer);
        if ((padding = (size + 7 & ~7) - size) > 0) {
          this._writePadding(padding);
        }
      }
    }
    return this;
  }
  _writeDictionaries(batch) {
    for (let [id, dictionary2] of batch.dictionaries) {
      let offset2 = this._dictionaryDeltaOffsets.get(id) || 0;
      if (offset2 === 0 || (dictionary2 = dictionary2 === null || dictionary2 === void 0 ? void 0 : dictionary2.slice(offset2)).length > 0) {
        for (const data2 of dictionary2.data) {
          this._writeDictionaryBatch(data2, id, offset2 > 0);
          offset2 += data2.length;
        }
      }
    }
    return this;
  }
};
var RecordBatchStreamWriter = class _RecordBatchStreamWriter extends RecordBatchWriter {
  /** @nocollapse */
  static writeAll(input, options) {
    const writer = new _RecordBatchStreamWriter(options);
    if (isPromise(input)) {
      return input.then((x) => writer.writeAll(x));
    } else if (isAsyncIterable(input)) {
      return writeAllAsync(writer, input);
    }
    return writeAll(writer, input);
  }
};
var RecordBatchFileWriter = class _RecordBatchFileWriter extends RecordBatchWriter {
  /** @nocollapse */
  static writeAll(input) {
    const writer = new _RecordBatchFileWriter();
    if (isPromise(input)) {
      return input.then((x) => writer.writeAll(x));
    } else if (isAsyncIterable(input)) {
      return writeAllAsync(writer, input);
    }
    return writeAll(writer, input);
  }
  constructor() {
    super();
    this._autoDestroy = true;
  }
  // @ts-ignore
  _writeSchema(schema) {
    return this._writeMagic()._writePadding(2);
  }
  _writeFooter(schema) {
    const buffer = Footer_.encode(new Footer_(schema, MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));
    return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
  }
};
function writeAll(writer, input) {
  let chunks = input;
  if (input instanceof Table2) {
    chunks = input.batches;
    writer.reset(void 0, input.schema);
  }
  for (const batch of chunks) {
    writer.write(batch);
  }
  return writer.finish();
}
function writeAllAsync(writer, batches) {
  var _a5, batches_1, batches_1_1;
  var _b2, e_1, _c2, _d2;
  return __awaiter(this, void 0, void 0, function* () {
    try {
      for (_a5 = true, batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), _b2 = batches_1_1.done, !_b2; _a5 = true) {
        _d2 = batches_1_1.value;
        _a5 = false;
        const batch = _d2;
        writer.write(batch);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (!_a5 && !_b2 && (_c2 = batches_1.return))
          yield _c2.call(batches_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return writer.finish();
  });
}

// node_modules/apache-arrow/io/whatwg/iterable.mjs
function toDOMStream(source2, options) {
  if (isAsyncIterable(source2)) {
    return asyncIterableAsReadableDOMStream(source2, options);
  }
  if (isIterable(source2)) {
    return iterableAsReadableDOMStream(source2, options);
  }
  throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
}
function iterableAsReadableDOMStream(source2, options) {
  let it = null;
  const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
  return new ReadableStream(Object.assign(Object.assign({}, options), {
    start(controller) {
      next(controller, it || (it = source2[Symbol.iterator]()));
    },
    pull(controller) {
      it ? next(controller, it) : controller.close();
    },
    cancel() {
      ((it === null || it === void 0 ? void 0 : it.return) && it.return() || true) && (it = null);
    }
  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
  function next(controller, it2) {
    let buf;
    let r = null;
    let size = controller.desiredSize || null;
    while (!(r = it2.next(bm ? size : null)).done) {
      if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
        size != null && bm && (size = size - buf.byteLength + 1);
        r.value = buf;
      }
      controller.enqueue(r.value);
      if (size != null && --size <= 0) {
        return;
      }
    }
    controller.close();
  }
}
function asyncIterableAsReadableDOMStream(source2, options) {
  let it = null;
  const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
  return new ReadableStream(Object.assign(Object.assign({}, options), {
    start(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller, it || (it = source2[Symbol.asyncIterator]()));
      });
    },
    pull(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        it ? yield next(controller, it) : controller.close();
      });
    },
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        ((it === null || it === void 0 ? void 0 : it.return) && (yield it.return()) || true) && (it = null);
      });
    }
  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
  function next(controller, it2) {
    return __awaiter(this, void 0, void 0, function* () {
      let buf;
      let r = null;
      let size = controller.desiredSize || null;
      while (!(r = yield it2.next(bm ? size : null)).done) {
        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
          size != null && bm && (size = size - buf.byteLength + 1);
          r.value = buf;
        }
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// node_modules/apache-arrow/io/whatwg/builder.mjs
function builderThroughDOMStream(options) {
  return new BuilderTransform(options);
}
var BuilderTransform = class {
  constructor(options) {
    this._numChunks = 0;
    this._finished = false;
    this._bufferedSize = 0;
    const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = __rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
    this._controller = null;
    this._builder = makeBuilder(builderOptions);
    this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
    const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);
    const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);
    this["readable"] = new ReadableStream({
      ["cancel"]: () => {
        this._builder.clear();
      },
      ["pull"]: (c) => {
        this._maybeFlush(this._builder, this._controller = c);
      },
      ["start"]: (c) => {
        this._maybeFlush(this._builder, this._controller = c);
      }
    }, {
      "highWaterMark": readableHighWaterMark,
      "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
    });
    this["writable"] = new WritableStream({
      ["abort"]: () => {
        this._builder.clear();
      },
      ["write"]: () => {
        this._maybeFlush(this._builder, this._controller);
      },
      ["close"]: () => {
        this._maybeFlush(this._builder.finish(), this._controller);
      }
    }, {
      "highWaterMark": writableHighWaterMark,
      "size": (value) => this._writeValueAndReturnChunkSize(value)
    });
  }
  _writeValueAndReturnChunkSize(value) {
    const bufferedSize = this._bufferedSize;
    this._bufferedSize = this._getSize(this._builder.append(value));
    return this._bufferedSize - bufferedSize;
  }
  _maybeFlush(builder, controller) {
    if (controller == null) {
      return;
    }
    if (this._bufferedSize >= controller.desiredSize) {
      ++this._numChunks && this._enqueue(controller, builder.toVector());
    }
    if (builder.finished) {
      if (builder.length > 0 || this._numChunks === 0) {
        ++this._numChunks && this._enqueue(controller, builder.toVector());
      }
      if (!this._finished && (this._finished = true)) {
        this._enqueue(controller, null);
      }
    }
  }
  _enqueue(controller, chunk) {
    this._bufferedSize = 0;
    this._controller = null;
    chunk == null ? controller.close() : controller.enqueue(chunk);
  }
};
var chunkLength = (chunk) => {
  var _a5;
  return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a5 !== void 0 ? _a5 : 0;
};
var chunkByteLength = (chunk) => {
  var _a5;
  return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a5 !== void 0 ? _a5 : 0;
};

// node_modules/apache-arrow/io/whatwg/reader.mjs
function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
  const queue = new AsyncByteQueue();
  let reader = null;
  const readable = new ReadableStream({
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        yield queue.close();
      });
    },
    start(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller, reader || (reader = yield open()));
      });
    },
    pull(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        reader ? yield next(controller, reader) : controller.close();
      });
    }
  });
  return { writable: new WritableStream(queue, Object.assign({ "highWaterMark": Math.pow(2, 14) }, writableStrategy)), readable };
  function open() {
    return __awaiter(this, void 0, void 0, function* () {
      return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);
    });
  }
  function next(controller, reader2) {
    return __awaiter(this, void 0, void 0, function* () {
      let size = controller.desiredSize;
      let r = null;
      while (!(r = yield reader2.next()).done) {
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// node_modules/apache-arrow/io/whatwg/writer.mjs
function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
  const writer = new this(writableStrategy);
  const reader = new AsyncByteStream(writer);
  const readable = new ReadableStream({
    // type: 'bytes',
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        yield reader.cancel();
      });
    },
    pull(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller);
      });
    },
    start(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller);
      });
    }
  }, Object.assign({ "highWaterMark": Math.pow(2, 14) }, readableStrategy));
  return { writable: new WritableStream(writer, writableStrategy), readable };
  function next(controller) {
    return __awaiter(this, void 0, void 0, function* () {
      let buf = null;
      let size = controller.desiredSize;
      while (buf = yield reader.read(size || null)) {
        controller.enqueue(buf);
        if (size != null && (size -= buf.byteLength) <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// node_modules/apache-arrow/ipc/serialization.mjs
function tableToIPC(table3, type = "stream") {
  return (type === "stream" ? RecordBatchStreamWriter : RecordBatchFileWriter).writeAll(table3).toUint8Array(true);
}

// node_modules/apache-arrow/Arrow.mjs
var util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), pretty_exports), {
  compareSchemas,
  compareFields,
  compareTypes
});

// node_modules/apache-arrow/Arrow.dom.mjs
adapters_default.toDOMStream = toDOMStream;
Builder["throughDOM"] = builderThroughDOMStream;
RecordBatchReader["throughDOM"] = recordBatchReaderThroughDOMStream;
RecordBatchFileReader["throughDOM"] = recordBatchReaderThroughDOMStream;
RecordBatchStreamReader["throughDOM"] = recordBatchReaderThroughDOMStream;
RecordBatchWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
RecordBatchFileWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
RecordBatchStreamWriter["throughDOM"] = recordBatchWriterThroughDOMStream;

// node_modules/arquero/src/arrow/builder/util.js
function ceil64Bytes(length, bpe = 1) {
  return (length * bpe + 63 & ~63 || 64) / bpe;
}
function array2(Type3, length, bpe = Type3.BYTES_PER_ELEMENT) {
  return new Type3(ceil64Bytes(length, bpe));
}
function arrowData(d) {
  return d instanceof Data2 ? d : new Data2(d.type, 0, d.length, d.nulls, d.buffers, null, d.dict);
}
function arrowVector(data2) {
  return new Vector([arrowData(data2)]);
}
var encoder2 = new TextEncoder();
function encode(data2, idx, str) {
  const bytes = encoder2.encode(str);
  data2.set(bytes, idx);
  return bytes.length;
}
function encodeInto(data2, idx, str) {
  return encoder2.encodeInto(str, data2.subarray(idx)).written;
}
var writeUtf8 = encoder2.encodeInto ? encodeInto : encode;

// node_modules/arquero/src/arrow/builder/array-builder.js
function array_builder_default(type, length) {
  const data2 = array2(type.ArrayType, length);
  return {
    set(value, index) {
      data2[index] = value;
    },
    data: () => ({ type, length, buffers: [null, data2] })
  };
}

// node_modules/arquero/src/arrow/builder/bool-builder.js
function bool_builder_default(type, length) {
  const data2 = array2(type.ArrayType, length / 8);
  return {
    set(value, index) {
      if (value)
        data2[index >> 3] |= 1 << index % 8;
    },
    data: () => ({ type, length, buffers: [null, data2] })
  };
}

// node_modules/arquero/src/arrow/builder/date-day-builder.js
function date_day_builder_default(type, length) {
  const data2 = array2(type.ArrayType, length);
  return {
    set(value, index) {
      data2[index] = value / 864e5 | 0;
    },
    data: () => ({ type, length, buffers: [null, data2] })
  };
}

// node_modules/arquero/src/arrow/builder/date-millis-builder.js
function date_millis_builder_default(type, length) {
  const data2 = array2(type.ArrayType, length << 1);
  return {
    set(value, index) {
      const i2 = index << 1;
      data2[i2] = value % 4294967296 | 0;
      data2[i2 + 1] = value / 4294967296 | 0;
    },
    data: () => ({ type, length, buffers: [null, data2] })
  };
}

// node_modules/arquero/src/arrow/builder/default-builder.js
function default_builder_default(type) {
  const b = makeBuilder({
    type,
    nullValues: [null, void 0]
  });
  return {
    set(value, index) {
      b.set(index, value);
    },
    data: () => b.finish().flush()
  };
}

// node_modules/arquero/src/arrow/builder/utf8-builder.js
function utf8_builder_default(type, length, strlen) {
  const offset2 = array2(Int32Array, length + 1);
  const buf = array2(Uint8Array, 3 * strlen);
  let idx = 0;
  return {
    set(value, index) {
      idx += writeUtf8(buf, idx, value);
      offset2[index + 1] = idx;
    },
    data: () => {
      const dlen = ceil64Bytes(idx);
      const data2 = buf.length > dlen ? buf.subarray(0, dlen) : buf;
      return { type, length, buffers: [offset2, data2] };
    }
  };
}

// node_modules/arquero/src/arrow/builder/dictionary-builder.js
function dictionary_builder_default(type, length) {
  const values2 = [];
  const data2 = array2(type.indices.ArrayType, length);
  const keys = /* @__PURE__ */ Object.create(null);
  let next = -1;
  let strlen = 0;
  return {
    set(value, index) {
      const v = String(value);
      let k = keys[v];
      if (k === void 0) {
        strlen += v.length;
        keys[v] = k = ++next;
        values2.push(v);
      }
      data2[index] = k;
    },
    data: () => ({
      type,
      length,
      buffers: [null, data2],
      dict: dictionary(type.dictionary, values2, strlen)
    })
  };
}
function dictionary(type, values2, strlen) {
  const b = utf8_builder_default(type, values2.length, strlen);
  values2.forEach(b.set);
  return arrowVector(b.data());
}

// node_modules/arquero/src/arrow/builder/valid-builder.js
function valid_builder_default(builder, length) {
  const valid = array2(Uint8Array, length / 8);
  let nulls = 0;
  return {
    set(value, index) {
      if (value == null) {
        ++nulls;
      } else {
        builder.set(value, index);
        valid[index >> 3] |= 1 << index % 8;
      }
    },
    data: () => {
      const d = builder.data();
      if (nulls) {
        d.nulls = nulls;
        d.buffers[2] = valid;
      }
      return d;
    }
  };
}

// node_modules/arquero/src/arrow/builder/index.js
function builder_default(type, nrows, nullable = true) {
  let method;
  switch (type.typeId) {
    case Type.Int:
      method = type.bitWidth < 64 ? array_builder_default : null;
      break;
    case Type.Float:
      method = type.precision > 0 ? array_builder_default : null;
      break;
    case Type.Dictionary:
      method = type.dictionary.typeId === Type.Utf8 && type.indices.typeId === Type.Int && type.indices.bitWidth < 64 ? dictionary_builder_default : null;
      break;
    case Type.Bool:
      method = bool_builder_default;
      break;
    case Type.Date:
      method = type.unit ? date_millis_builder_default : date_day_builder_default;
      break;
  }
  return method == null ? default_builder_default(type) : nullable ? valid_builder_default(method(type, nrows), nrows) : method(type, nrows);
}

// node_modules/arquero/src/arrow/encode/data-from.js
function dataFromArray(array3, type) {
  const length = array3.length;
  const size = ceil64Bytes(length, array3.BYTES_PER_ELEMENT);
  let data2 = array3;
  if (length !== size) {
    data2 = new array3.constructor(size);
    data2.set(array3);
  }
  return arrowData({ type, length, buffers: [null, data2] });
}
function dataFromScan(nrows, scan2, column, type, nullable = true) {
  const b = builder_default(type, nrows, nullable);
  scan2(column, b.set);
  return arrowData(b.data());
}

// node_modules/arquero/src/arrow/builder/resolve-type.js
function resolve_type_default(type) {
  if (type instanceof DataType || type == null) {
    return type;
  }
  switch (type) {
    case Type.Binary:
      return new Binary();
    case Type.Bool:
      return new Bool();
    case Type.DateDay:
      return new DateDay();
    case Type.DateMillisecond:
    case Type.Date:
      return new DateMillisecond();
    case Type.Dictionary:
      return new Dictionary2(new Utf8(), new Int32());
    case Type.Float16:
      return new Float16();
    case Type.Float32:
      return new Float32();
    case Type.Float64:
    case Type.Float:
      return new Float64();
    case Type.Int8:
      return new Int8();
    case Type.Int16:
      return new Int16();
    case Type.Int32:
    case Type.Int:
      return new Int32();
    case Type.Int64:
      return new Int64();
    case Type.IntervalDayTime:
      return new IntervalDayTime();
    case Type.Interval:
    case Type.IntervalYearMonth:
      return new IntervalYearMonth();
    case Type.Null:
      return new Null();
    case Type.TimeMicrosecond:
      return new TimeMicrosecond();
    case Type.TimeMillisecond:
    case Type.Time:
      return new TimeMillisecond();
    case Type.TimeNanosecond:
      return new TimeNanosecond();
    case Type.TimeSecond:
      return new TimeSecond();
    case Type.Uint8:
      return new Uint8();
    case Type.Uint16:
      return new Uint16();
    case Type.Uint32:
      return new Uint32();
    case Type.Uint64:
      return new Uint64();
    case Type.Utf8:
      return new Utf8();
    default:
      error_default(
        `Unsupported type code: ${to_string_default(type)}. Use a data type constructor instead?`
      );
  }
}

// node_modules/arquero/src/util/is-exact-utc-date.js
function is_exact_utc_date_default(d) {
  return d.getUTCHours() === 0 && d.getUTCMinutes() === 0 && d.getUTCSeconds() === 0 && d.getUTCMilliseconds() === 0;
}

// node_modules/arquero/src/arrow/encode/profiler.js
function profile(scan2, column) {
  const p = profiler();
  scan2(column, p.add);
  return p;
}
function profiler() {
  const p = {
    count: 0,
    nulls: 0,
    bools: 0,
    nums: 0,
    ints: 0,
    bigints: 0,
    min: Infinity,
    max: -Infinity,
    digits: 0,
    dates: 0,
    utcdays: 0,
    strings: 0,
    strlen: 0,
    arrays: 0,
    minlen: Infinity,
    maxlen: 0,
    structs: 0,
    add(value) {
      ++p.count;
      if (value == null) {
        ++p.nulls;
        return;
      }
      const type = typeof value;
      if (type === "string") {
        ++p.strings;
      } else if (type === "number") {
        ++p.nums;
        if (value < p.min)
          p.min = value;
        if (value > p.max)
          p.max = value;
        if (Number.isInteger(value))
          ++p.ints;
      } else if (type === "boolean") {
        ++p.bools;
      } else if (type === "object") {
        if (is_date_default(value)) {
          ++p.dates;
          if (is_exact_utc_date_default(value)) {
            ++p.utcdays;
          }
        } else if (isArrayType(value)) {
          ++p.arrays;
          if (value.length < p.minlen)
            p.minlen = value.length;
          if (value.length > p.maxlen)
            p.maxlen = value.length;
          const ap = p.array_prof || (p.array_prof = profiler());
          value.forEach(ap.add);
        } else {
          ++p.structs;
          const sp = p.struct_prof || (p.struct_prof = {});
          for (const key2 in value) {
            const fp = sp[key2] || (sp[key2] = profiler());
            fp.add(value[key2]);
          }
        }
      } else if (type === "bigint") {
        ++p.bigints;
        if (value < p.min)
          p.min = value;
        if (value > p.max)
          p.max = value;
      }
    },
    type() {
      return resolve_type_default(infer(p));
    }
  };
  return p;
}
function infer(p) {
  const valid = p.count - p.nulls;
  if (valid === 0) {
    return Type.Null;
  } else if (p.ints === valid) {
    const v = Math.max(Math.abs(p.min) - 1, p.max);
    return p.min < 0 ? v >= 2 ** 31 ? Type.Float64 : v < 1 << 7 ? Type.Int8 : v < 1 << 15 ? Type.Int16 : Type.Int32 : v >= 2 ** 32 ? Type.Float64 : v < 1 << 8 ? Type.Uint8 : v < 1 << 16 ? Type.Uint16 : Type.Uint32;
  } else if (p.nums === valid) {
    return Type.Float64;
  } else if (p.bigints === valid) {
    const v = -p.min > p.max ? -p.min - 1n : p.max;
    return p.min < 0 ? v < 2 ** 63 ? Type.Int64 : error_default(`BigInt exceeds 64 bits: ${v}`) : p.max < 2 ** 64 ? Type.Uint64 : error_default(`BigInt exceeds 64 bits: ${p.max}`);
  } else if (p.bools === valid) {
    return Type.Bool;
  } else if (p.utcdays === valid) {
    return Type.DateDay;
  } else if (p.dates === valid) {
    return Type.DateMillisecond;
  } else if (p.arrays === valid) {
    const type = Field2.new("value", p.array_prof.type(), true);
    return p.minlen === p.maxlen ? new FixedSizeList(p.minlen, type) : new List(type);
  } else if (p.structs === valid) {
    const sp = p.struct_prof;
    return new Struct(
      Object.keys(sp).map((name2) => Field2.new(name2, sp[name2].type(), true))
    );
  } else if (p.strings > 0) {
    return Type.Dictionary;
  } else {
    error_default("Type inference failure");
  }
}

// node_modules/arquero/src/arrow/encode/data-from-objects.js
function data_from_objects_default(data2, name2, nrows, scan2, type, nullable = true) {
  type = resolve_type_default(type);
  if (!type) {
    const p = profile(scan2, name2);
    nullable = p.nulls > 0;
    type = p.type();
  }
  return dataFromScan(nrows, scan2, name2, type, nullable);
}

// node_modules/arquero/src/arrow/encode/data-from-table.js
function data_from_table_default(table3, name2, nrows, scan2, type, nullable = true) {
  type = resolve_type_default(type);
  const column = table3.column(name2);
  const reified = !(table3.isFiltered() || table3.isOrdered());
  const vec = arrowVector2(column);
  if (vec && reified && typeCompatible(vec.type, type)) {
    return vec;
  }
  const data2 = column.data;
  if (is_typed_array_default(data2)) {
    const dtype = typeFromArray(data2);
    if (reified && dtype && typeCompatible(dtype, type)) {
      return dataFromArray(data2, dtype);
    } else {
      type = type || dtype;
      nullable = false;
    }
  }
  if (!type) {
    const p = profile(scan2, column);
    nullable = p.nulls > 0;
    type = p.type();
  }
  return dataFromScan(nrows, scan2, column, type, nullable);
}
function arrowVector2(value) {
  return value instanceof Vector ? value : value.vector instanceof Vector ? value.vector : null;
}
function typeFromArray(data2) {
  const types2 = {
    Float32Array: Float32,
    Float64Array: Float64,
    Int8Array: Int8,
    Int16Array: Int16,
    Int32Array: Int32,
    Uint8Array: Uint8,
    Uint16Array: Uint16,
    Uint32Array: Uint32,
    BigInt64Array: Int64,
    BigUint64Array: Uint64
  };
  const Type3 = types2[data2.constructor.name];
  return Type3 ? new Type3() : null;
}
function typeCompatible(a, b) {
  return !a || !b ? true : a.compareTo(b);
}

// node_modules/arquero/src/arrow/encode/scan.js
function scanArray(data2, limit, offset2) {
  const n2 = Math.min(data2.length, offset2 + limit);
  return (name2, visit2) => {
    for (let i2 = offset2; i2 < n2; ++i2) {
      visit2(data2[i2][name2], i2);
    }
  };
}
function scanTable(table3, limit, offset2) {
  const scanAll = offset2 === 0 && table3.numRows() <= limit && !table3.isFiltered() && !table3.isOrdered();
  return (column, visit2) => {
    let i2 = -1;
    scanAll && isArrayType(column.data) ? column.data.forEach(visit2) : table3.scan(
      (row) => visit2(column.get(row), ++i2),
      true,
      limit,
      offset2
    );
  };
}

// node_modules/arquero/src/arrow/arrow-table.js
var fail = () => error_default(
  "Apache Arrow not imported, see https://github.com/uwdata/arquero#usage"
);
function table() {
  try {
    return Table2;
  } catch (err) {
    fail();
  }
}

// node_modules/arquero/src/arrow/encode/index.js
function encode_default(data2, options = {}) {
  const { types: types2 = {} } = options;
  const { dataFrom, names: names2, nrows, scan: scan2 } = init(data2, options);
  const cols = {};
  names2.forEach((name2) => {
    const col = dataFrom(data2, name2, nrows, scan2, types2[name2]);
    if (col.length !== nrows) {
      error_default("Column length mismatch");
    }
    cols[name2] = col;
  });
  const T = table();
  return new T(cols);
}
function init(data2, options) {
  const { columns: columns2, limit = Infinity, offset: offset2 = 0 } = options;
  const names2 = is_function_default(columns2) ? columns2(data2) : is_array_default(columns2) ? columns2 : null;
  if (is_array_default(data2)) {
    return {
      dataFrom: data_from_objects_default,
      names: names2 || Object.keys(data2[0]),
      nrows: Math.min(limit, data2.length - offset2),
      scan: scanArray(data2, limit, offset2)
    };
  } else if (isTable(data2)) {
    return {
      dataFrom: data_from_table_default,
      names: names2 || data2.columnNames(),
      nrows: Math.min(limit, data2.numRows() - offset2),
      scan: scanTable(data2, limit, offset2)
    };
  } else {
    error_default("Unsupported input data type");
  }
}
function isTable(data2) {
  return data2 && is_function_default(data2.reify);
}

// node_modules/arquero/src/format/to-arrow.js
var to_arrow_default = encode_default;
function toArrowIPC(table3, options = {}) {
  const { format: format2, ...toArrowOptions } = options;
  const outputFormat = format2 ? format2 : "stream";
  if (!["stream", "file"].includes(outputFormat)) {
    throw Error("Unrecognised output format");
  }
  return tableToIPC(encode_default(table3, toArrowOptions), format2);
}

// node_modules/arquero/src/format/infer.js
function isExactDateUTC(d) {
  return d.getUTCHours() === 0 && d.getUTCMinutes() === 0 && d.getUTCSeconds() === 0 && d.getUTCMilliseconds() === 0;
}
function infer_default(scan2, options = {}) {
  let count2 = 0;
  let nulls = 0;
  let dates = 0;
  let dutcs = 0;
  let nums = 0;
  let digits = 0;
  scan2((value) => {
    ++count2;
    if (value == null) {
      ++nulls;
      return;
    }
    const type = typeof value;
    if (type === "object" && is_date_default(value)) {
      ++dates;
      if (isExactDateUTC(value))
        ++dutcs;
    } else if (type === "number") {
      ++nums;
      if (value === value && (value | 0) !== value) {
        const s = value + "";
        const p = s.indexOf(".");
        if (p >= 0) {
          const e = s.indexOf("e");
          const l = e > 0 ? e : s.length;
          digits = Math.max(digits, l - p - 1);
        }
      }
    }
  });
  return {
    align: (nulls + nums + dates) / count2 > 0.5 ? "r" : "l",
    format: {
      utc: dates === dutcs,
      digits: Math.min(digits, options.maxdigits || 6)
    }
  };
}

// node_modules/arquero/src/format/util.js
function columns(table3, names2) {
  return is_function_default(names2) ? names2(table3) : names2 || table3.columnNames();
}
function formats(table3, names2, options) {
  const formatOpt = options.format || {};
  const alignOpt = options.align || {};
  const format2 = {};
  const align = {};
  names2.forEach((name2) => {
    const auto = infer_default(values(table3, name2), options);
    align[name2] = alignOpt[name2] || auto.align;
    format2[name2] = formatOpt[name2] || auto.format;
  });
  return { align, format: format2 };
}
function values(table3, columnName) {
  const column = table3.column(columnName);
  return (fn) => table3.scan((row) => fn(column.get(row)));
}
function scan(table3, names2, limit = 100, offset2, ctx) {
  const data2 = table3.data();
  const n2 = names2.length;
  table3.scan((row) => {
    ctx.row(row);
    for (let i2 = 0; i2 < n2; ++i2) {
      const name2 = names2[i2];
      ctx.cell(data2[names2[i2]].get(row), name2, i2);
    }
  }, true, limit, offset2);
}

// node_modules/arquero/src/format/to-csv.js
function to_csv_default(table3, options = {}) {
  const names2 = columns(table3, options.columns);
  const format2 = options.format || {};
  const delim = options.delimiter || ",";
  const reFormat = new RegExp(`["${delim}
\r]`);
  const formatValue = (value) => value == null ? "" : is_date_default(value) ? formatUTCDate(value, true) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
  const vals = names2.map(formatValue);
  let text = "";
  scan(table3, names2, options.limit || Infinity, options.offset, {
    row() {
      text += vals.join(delim) + "\n";
    },
    cell(value, name2, index) {
      vals[index] = formatValue(format2[name2] ? format2[name2](value) : value);
    }
  });
  return text + vals.join(delim);
}

// node_modules/arquero/src/format/value.js
function value_default(v, options = {}) {
  if (is_function_default(options)) {
    return options(v) + "";
  }
  const type = typeof v;
  if (type === "object") {
    if (is_date_default(v)) {
      return options.utc ? formatUTCDate(v) : formatDate(v);
    } else {
      const s = JSON.stringify(
        v,
        (k, v2) => is_typed_array_default(v2) ? Array.from(v2) : v2
      );
      const maxlen = options.maxlen || 30;
      return s.length > maxlen ? s.slice(0, 28) + "" + (s[0] === "[" ? "]" : "}") : s;
    }
  } else if (type === "number") {
    const digits = options.digits || 0;
    let a;
    return v !== 0 && ((a = Math.abs(v)) >= 1e18 || a < Math.pow(10, -digits)) ? v.toExponential(digits) : v.toFixed(digits);
  } else {
    return v + "";
  }
}

// node_modules/arquero/src/util/map-object.js
function map_object_default(obj, fn, output4 = {}) {
  for (const key2 in obj) {
    output4[key2] = fn(obj[key2], key2);
  }
  return output4;
}

// node_modules/arquero/src/format/to-html.js
function to_html_default(table3, options = {}) {
  const names2 = columns(table3, options.columns);
  const { align, format: format2 } = formats(table3, names2, options);
  const style = styles(options);
  const nullish = options.null;
  const alignValue = (a) => a === "c" ? "center" : a === "r" ? "right" : "left";
  const escape2 = (s) => s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  const baseFormat = (value, opt2) => escape2(value_default(value, opt2));
  const formatter = nullish ? (value, opt2) => value == null ? nullish(value) : baseFormat(value, opt2) : baseFormat;
  let r = -1;
  let idx = -1;
  const tag = (tag2, name2, shouldAlign) => {
    const a = shouldAlign ? alignValue(align[name2]) : "";
    const s = style[tag2] ? style[tag2](name2, idx, r) || "" : "";
    const css = (a ? `text-align: ${a};` + (s ? " " : "") : "") + s;
    return `<${tag2}${css ? ` style="${css}"` : ""}>`;
  };
  let text = tag("table") + tag("thead") + tag("tr", r) + names2.map((name2) => `${tag("th", name2, 1)}${name2}</th>`).join("") + "</tr></thead>" + tag("tbody");
  scan(table3, names2, options.limit, options.offset, {
    row(row) {
      r = row;
      text += (++idx ? "</tr>" : "") + tag("tr");
    },
    cell(value, name2) {
      text += tag("td", name2, 1) + formatter(value, format2[name2]) + "</td>";
    }
  });
  return text + "</tr></tbody></table>";
}
function styles(options) {
  return map_object_default(
    options.style,
    (value) => is_function_default(value) ? value : () => value
  );
}

// node_modules/arquero/src/util/default-true.js
function default_true_default(value, trueValue = true, falseValue = false) {
  return value === void 0 || value ? trueValue : falseValue;
}

// node_modules/arquero/src/format/to-json.js
var defaultFormatter = (value) => is_date_default(value) ? formatUTCDate(value, true) : value;
function to_json_default(table3, options = {}) {
  const schema = default_true_default(options.schema);
  const format2 = options.format || {};
  const names2 = columns(table3, options.columns);
  let text = "{";
  if (schema) {
    text += '"schema":{"fields":' + JSON.stringify(names2.map((name2) => ({ name: name2 }))) + '},"data":{';
  }
  names2.forEach((name2, i2) => {
    text += (i2 ? "," : "") + JSON.stringify(name2) + ":[";
    const column = table3.column(name2);
    const formatter = format2[name2] || defaultFormatter;
    let r = -1;
    table3.scan((row) => {
      const value = column.get(row);
      text += (++r ? "," : "") + JSON.stringify(formatter(value));
    }, true, options.limit, options.offset);
    text += "]";
  });
  return text + "}" + (schema ? "}" : "");
}

// node_modules/arquero/src/format/to-markdown.js
function to_markdown_default(table3, options = {}) {
  const names2 = columns(table3, options.columns);
  const { align, format: format2 } = formats(table3, names2, options);
  const alignValue = (a) => a === "c" ? ":-:" : a === "r" ? "-:" : ":-";
  const escape2 = (s) => s.replace(/\|/g, "\\|");
  let text = "|" + names2.map(escape2).join("|") + "|\n|" + names2.map((name2) => alignValue(align[name2])).join("|") + "|";
  scan(table3, names2, options.limit, options.offset, {
    row() {
      text += "\n|";
    },
    cell(value, name2) {
      text += escape2(value_default(value, format2[name2])) + "|";
    }
  });
  return text + "\n";
}

// node_modules/arquero/src/util/assign.js
function assign_default(map, pairs) {
  for (const [key2, value] of entries_default(pairs)) {
    map.set(key2, value);
  }
  return map;
}

// node_modules/arquero/src/util/escape-regexp.js
function escape_regexp_default(str) {
  return str.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/arquero/src/helpers/selection.js
function resolve(table3, sel, map = /* @__PURE__ */ new Map()) {
  sel = is_number_default(sel) ? table3.columnName(sel) : sel;
  if (is_string_default(sel)) {
    map.set(sel, sel);
  } else if (is_array_default(sel)) {
    sel.forEach((r) => resolve(table3, r, map));
  } else if (is_function_default(sel)) {
    resolve(table3, sel(table3), map);
  } else if (is_object_default(sel)) {
    assign_default(map, sel);
  } else {
    error_default(`Invalid column selection: ${to_string_default(sel)}`);
  }
  return map;
}
function decorate(value, toObject3) {
  value.toObject = toObject3;
  return value;
}
function toObject(value) {
  return is_array_default(value) ? value.map(toObject) : value && value.toObject ? value.toObject() : value;
}
function all() {
  return decorate(
    (table3) => table3.columnNames(),
    () => ({ all: [] })
  );
}
function not(...selection) {
  selection = selection.flat();
  return decorate(
    (table3) => {
      const drop = resolve(table3, selection);
      return table3.columnNames((name2) => !drop.has(name2));
    },
    () => ({ not: toObject(selection) })
  );
}
function range(start, end) {
  return decorate(
    (table3) => {
      let i2 = is_number_default(start) ? start : table3.columnIndex(start);
      let j = is_number_default(end) ? end : table3.columnIndex(end);
      if (j < i2) {
        const t2 = j;
        j = i2;
        i2 = t2;
      }
      return table3.columnNames().slice(i2, j + 1);
    },
    () => ({ range: [start, end] })
  );
}
function matches(pattern) {
  if (is_string_default(pattern))
    pattern = RegExp(escape_regexp_default(pattern));
  return decorate(
    (table3) => table3.columnNames((name2) => pattern.test(name2)),
    () => ({ matches: [pattern.source, pattern.flags] })
  );
}

// node_modules/arquero/src/util/array-type.js
function array_type_default(column) {
  return is_typed_array_default(column.data) ? column.data.constructor : Array;
}

// node_modules/arquero/src/table/column-table.js
var ColumnTable = class _ColumnTable extends Table {
  /**
   * Create a new ColumnTable from existing input data.
   * @param {object[]|Iterable<object>|object|Map} values The backing table data values.
   *  If array-valued, should be a list of JavaScript objects with
   *  key-value properties for each column value.
   *  If object- or Map-valued, a table with two columns (one for keys,
   *  one for values) will be created.
   * @param {string[]} [names] The named columns to include.
   * @return {ColumnTable} A new ColumnTable instance.
   */
  static from(values2, names2) {
    return new _ColumnTable(columns_from_default(values2, names2), names2);
  }
  /**
   * Create a new table for a set of named columns.
   * @param {object|Map} columns
   *  The set of named column arrays. Keys are column names.
   *  The enumeration order of the keys determines the column indices,
   *  unless the names parameter is specified.
   *  Values must be arrays (or array-like values) of identical length.
   * @param {string[]} [names] Ordered list of column names. If specified,
   *  this array determines the column indices. If not specified, the
   *  key enumeration order of the columns object is used.
   * @return {ColumnTable} the instantiated ColumnTable instance.
   */
  static new(columns2, names2) {
    if (columns2 instanceof _ColumnTable)
      return columns2;
    const data2 = {};
    const keys = [];
    for (const [key2, value] of entries_default(columns2)) {
      data2[key2] = value;
      keys.push(key2);
    }
    return new _ColumnTable(data2, names2 || keys);
  }
  /**
   * Instantiate a new ColumnTable instance.
   * @param {object} columns An object mapping column names to values.
   * @param {string[]} [names] An ordered list of column names.
   * @param {BitSet} [filter] A filtering BitSet.
   * @param {GroupBySpec} [group] A groupby specification.
   * @param {RowComparator} [order] A row comparator function.
   * @param {Params} [params] An object mapping parameter names to values.
   */
  constructor(columns2, names2, filter, group2, order, params) {
    map_object_default(columns2, defaultColumnFactory, columns2);
    names2 = names2 || Object.keys(columns2);
    const nrows = names2.length ? columns2[names2[0]].length : 0;
    super(names2, nrows, columns2, filter, group2, order, params);
  }
  /**
   * Create a new table with the same type as this table.
   * The new table may have different data, filter, grouping, or ordering
   * based on the values of the optional configuration argument. If a
   * setting is not specified, it is inherited from the current table.
   * @param {CreateOptions} [options] Creation options for the new table.
   * @return {ColumnTable} A newly created table.
   */
  create({ data: data2, names: names2, filter, groups, order }) {
    const f = filter !== void 0 ? filter : this.mask();
    return new _ColumnTable(
      data2 || this._data,
      names2 || (!data2 ? this._names : null),
      f,
      groups !== void 0 ? groups : regroup(this._group, filter && f),
      order !== void 0 ? order : this._order,
      this._params
    );
  }
  /**
   * Create a new table with additional columns drawn from one or more input
   * tables. All tables must have the same numer of rows and are reified
   * prior to assignment. In the case of repeated column names, input table
   * columns overwrite existing columns.
   * @param {...ColumnTable} tables The tables to merge with this table.
   * @return {ColumnTable} A new table with merged columns.
   * @example table.assign(table1, table2)
   */
  assign(...tables) {
    const nrows = this.numRows();
    const base = this.reify();
    const cset = column_set_default(base).groupby(base.groups());
    tables.forEach((input) => {
      input = _ColumnTable.new(input);
      if (input.numRows() !== nrows)
        error_default("Assign row counts do not match");
      input = input.reify();
      input.columnNames((name2) => cset.add(name2, input.column(name2)));
    });
    return this.create(cset.new());
  }
  /**
   * Get the backing set of columns for this table.
   * @return {ColumnData} Object of named column instances.
   */
  columns() {
    return this._data;
  }
  /**
   * Get the column instance with the given name.
   * @param {string} name The column name.
   * @return {ColumnType | undefined} The named column, or undefined if it does not exist.
   */
  column(name2) {
    return this._data[name2];
  }
  /**
   * Get the column instance at the given index position.
   * @param {number} index The zero-based column index.
   * @return {ColumnType | undefined} The column, or undefined if it does not exist.
   */
  columnAt(index) {
    return this._data[this._names[index]];
  }
  /**
   * Get an array of values contained in a column. The resulting array
   * respects any table filter or orderby criteria.
   * @param {string} name The column name.
   * @param {ArrayConstructor|import('./table').TypedArrayConstructor} [constructor=Array]
   *  The array constructor for instantiating the output array.
   * @return {import('./table').DataValue[]|import('./table).TypedArray} The array of column values.
   */
  array(name2, constructor = Array) {
    const column = this.column(name2);
    const array3 = new constructor(this.numRows());
    let idx = -1;
    this.scan((row) => array3[++idx] = column.get(row), true);
    return array3;
  }
  /**
   * Get the value for the given column and row.
   * @param {string} name The column name.
   * @param {number} [row=0] The row index, defaults to zero if not specified.
   * @return {import('./table').DataValue} The table value at (column, row).
   */
  get(name2, row = 0) {
    const column = this.column(name2);
    return this.isFiltered() || this.isOrdered() ? column.get(this.indices()[row]) : column.get(row);
  }
  /**
   * Returns an accessor ("getter") function for a column. The returned
   * function takes a row index as its single argument and returns the
   * corresponding column value.
   * @param {string} name The column name.
   * @return {import('./table').ColumnGetter} The column getter function.
   */
  getter(name2) {
    const column = this.column(name2);
    const indices = this.isFiltered() || this.isOrdered() ? this.indices() : null;
    return indices ? (row) => column.get(indices[row]) : column ? (row) => column.get(row) : error_default(`Unrecognized column: ${name2}`);
  }
  /**
   * Returns an object representing a table row.
   * @param {number} [row=0] The row index, defaults to zero if not specified.
   * @return {object} A row object with named properties for each column.
   */
  object(row = 0) {
    return objectBuilder(this)(row);
  }
  /**
   * Returns an array of objects representing table rows.
   * @param {ObjectsOptions} [options] The options for row object generation.
   * @return {object[]} An array of row objects.
   */
  objects(options = {}) {
    const { grouped, limit, offset: offset2 } = options;
    const names2 = resolve(this, options.columns || all());
    const create = rowObjectBuilder(names2);
    const obj = [];
    this.scan(
      (row, data2) => obj.push(create(row, data2)),
      true,
      limit,
      offset2
    );
    if (grouped && this.isGrouped()) {
      const idx = [];
      this.scan((row) => idx.push(row), true, limit, offset2);
      return nest(this, idx, obj, grouped);
    }
    return obj;
  }
  /**
   * Returns an iterator over objects representing table rows.
   * @return {Iterator<object>} An iterator over row objects.
   */
  *[Symbol.iterator]() {
    const create = objectBuilder(this);
    const n2 = this.numRows();
    for (let i2 = 0; i2 < n2; ++i2) {
      yield create(i2);
    }
  }
  /**
   * Create a new fully-materialized instance of this table.
   * All filter and orderby settings are removed from the new table.
   * Instead, the backing data itself is filtered and ordered as needed.
   * @param {number[]} [indices] Ordered row indices to materialize.
   *  If unspecified, all rows passing the table filter are used.
   * @return {ColumnTable} A reified table.
   */
  reify(indices) {
    const nrows = indices ? indices.length : this.numRows();
    const names2 = this._names;
    let data2, groups;
    if (!indices && !this.isOrdered()) {
      if (!this.isFiltered()) {
        return this;
      } else if (nrows === this.totalRows()) {
        data2 = this.data();
      }
    }
    if (!data2) {
      const scan2 = indices ? (f) => indices.forEach(f) : (f) => this.scan(f, true);
      const ncols = names2.length;
      data2 = {};
      for (let i2 = 0; i2 < ncols; ++i2) {
        const name2 = names2[i2];
        const prev = this.column(name2);
        const curr = data2[name2] = new (array_type_default(prev))(nrows);
        let r = -1;
        scan2((row) => curr[++r] = prev.get(row));
      }
      if (this.isGrouped()) {
        groups = reindex(this.groups(), scan2, !!indices, nrows);
      }
    }
    return this.create({ data: data2, names: names2, groups, filter: null, order: null });
  }
  /**
   * Apply a sequence of transformations to this table. The output
   * of each transform is passed as input to the next transform, and
   * the output of the last transform is then returned.
   * @param {...(Transform|Transform[])} transforms Transformation
   *  functions to apply to the table in sequence. Each function should
   *  take a single table as input and return a table as output.
   * @return {ColumnTable} The output of the last transform.
   */
  transform(...transforms) {
    return transforms.flat().reduce((t2, f) => f(t2), this);
  }
  /**
   * Format this table as an Apache Arrow table.
   * @param {ArrowFormatOptions} [options] The formatting options.
   * @return {import('apache-arrow').Table} An Apache Arrow table.
   */
  toArrow(options) {
    return to_arrow_default(this, options);
  }
  /**
   * Format this table as binary data in the Apache Arrow IPC format.
   * @param {ArrowFormatOptions} [options] The formatting options. Set {format: 'stream'} 
   *        or {format:"file"} for specific IPC format
   * @return {Uint8Array} A new Uint8Array of Arrow-encoded binary data.
   */
  toArrowBuffer(options) {
    return toArrowIPC(this, options);
  }
  /**
   * Format this table as a comma-separated values (CSV) string. Other
   * delimiters, such as tabs or pipes ('|'), can be specified using
   * the options argument.
   * @param {CSVFormatOptions} [options] The formatting options.
   * @return {string} A delimited value string.
   */
  toCSV(options) {
    return to_csv_default(this, options);
  }
  /**
   * Format this table as an HTML table string.
   * @param {HTMLFormatOptions} [options] The formatting options.
   * @return {string} An HTML table string.
   */
  toHTML(options) {
    return to_html_default(this, options);
  }
  /**
   * Format this table as a JavaScript Object Notation (JSON) string.
   * @param {JSONFormatOptions} [options] The formatting options.
   * @return {string} A JSON string.
   */
  toJSON(options) {
    return to_json_default(this, options);
  }
  /**
   * Format this table as a GitHub-Flavored Markdown table string.
   * @param {MarkdownFormatOptions} [options] The formatting options.
   * @return {string} A GitHub-Flavored Markdown table string.
   */
  toMarkdown(options) {
    return to_markdown_default(this, options);
  }
};
function objectBuilder(table3) {
  let b = table3._builder;
  if (!b) {
    const create = rowObjectBuilder(table3.columnNames());
    const data2 = table3.data();
    if (table3.isOrdered() || table3.isFiltered()) {
      const indices = table3.indices();
      b = (row) => create(indices[row], data2);
    } else {
      b = (row) => create(row, data2);
    }
    table3._builder = b;
  }
  return b;
}

// node_modules/arquero/src/engine/reduce/reducer.js
var Reducer = class {
  constructor(outputs) {
    this._outputs = outputs;
  }
  size() {
    return this._outputs.length;
  }
  outputs() {
    return this._outputs;
  }
  init() {
    return {};
  }
  add() {
  }
  rem() {
  }
  write() {
  }
};

// node_modules/arquero/src/expression/ast/walk.js
function walk(node, ctx, visitors3, parent) {
  const visit2 = visitors3[node.type] || visitors3["Default"];
  if (visit2 && visit2(node, ctx, parent) === false)
    return;
  const walker = walkers[node.type];
  if (walker)
    walker(node, ctx, visitors3);
}
var unary = (node, ctx, visitors3) => {
  walk(node.argument, ctx, visitors3, node);
};
var binary2 = (node, ctx, visitors3) => {
  walk(node.left, ctx, visitors3, node);
  walk(node.right, ctx, visitors3, node);
};
var ternary = (node, ctx, visitors3) => {
  walk(node.test, ctx, visitors3, node);
  walk(node.consequent, ctx, visitors3, node);
  if (node.alternate)
    walk(node.alternate, ctx, visitors3, node);
};
var func2 = (node, ctx, visitors3) => {
  list2(node.params, ctx, visitors3, node);
  walk(node.body, ctx, visitors3, node);
};
var call2 = (node, ctx, visitors3) => {
  walk(node.callee, ctx, visitors3, node);
  list2(node.arguments, ctx, visitors3, node);
};
var list2 = (nodes, ctx, visitors3, node) => {
  nodes.forEach((item) => walk(item, ctx, visitors3, node));
};
var walkers = {
  TemplateLiteral: (node, ctx, visitors3) => {
    list2(node.expressions, ctx, visitors3, node);
    list2(node.quasis, ctx, visitors3, node);
  },
  MemberExpression: (node, ctx, visitors3) => {
    walk(node.object, ctx, visitors3, node);
    walk(node.property, ctx, visitors3, node);
  },
  CallExpression: call2,
  NewExpression: call2,
  ArrayExpression: (node, ctx, visitors3) => {
    list2(node.elements, ctx, visitors3, node);
  },
  AssignmentExpression: binary2,
  AwaitExpression: unary,
  BinaryExpression: binary2,
  LogicalExpression: binary2,
  UnaryExpression: unary,
  UpdateExpression: unary,
  ConditionalExpression: ternary,
  ObjectExpression: (node, ctx, visitors3) => {
    list2(node.properties, ctx, visitors3, node);
  },
  Property: (node, ctx, visitors3) => {
    walk(node.key, ctx, visitors3, node);
    walk(node.value, ctx, visitors3, node);
  },
  ArrowFunctionExpression: func2,
  FunctionExpression: func2,
  FunctionDeclaration: func2,
  VariableDeclaration: (node, ctx, visitors3) => {
    list2(node.declarations, ctx, visitors3, node);
  },
  VariableDeclarator: (node, ctx, visitors3) => {
    walk(node.id, ctx, visitors3, node);
    walk(node.init, ctx, visitors3, node);
  },
  SpreadElement: (node, ctx, visitors3) => {
    walk(node.argument, ctx, visitors3, node);
  },
  BlockStatement: (node, ctx, visitors3) => {
    list2(node.body, ctx, visitors3, node);
  },
  ExpressionStatement: (node, ctx, visitors3) => {
    walk(node.expression, ctx, visitors3, node);
  },
  IfStatement: ternary,
  ForStatement: (node, ctx, visitors3) => {
    walk(node.init, ctx, visitors3, node);
    walk(node.test, ctx, visitors3, node);
    walk(node.update, ctx, visitors3, node);
    walk(node.body, ctx, visitors3, node);
  },
  WhileStatement: (node, ctx, visitors3) => {
    walk(node.test, ctx, visitors3, node);
    walk(node.body, ctx, visitors3, node);
  },
  DoWhileStatement: (node, ctx, visitors3) => {
    walk(node.body, ctx, visitors3, node);
    walk(node.test, ctx, visitors3, node);
  },
  SwitchStatement: (node, ctx, visitors3) => {
    walk(node.discriminant, ctx, visitors3, node);
    list2(node.cases, ctx, visitors3, node);
  },
  SwitchCase: (node, ctx, visitors3) => {
    if (node.test)
      walk(node.test, ctx, visitors3, node);
    list2(node.consequent, ctx, visitors3, node);
  },
  ReturnStatement: unary,
  Program: (node, ctx, visitors3) => {
    walk(node.body[0], ctx, visitors3, node);
  }
};

// node_modules/arquero/src/expression/ast/clean.js
function strip(node) {
  delete node.start;
  delete node.end;
  delete node.optional;
}
function stripMember(node) {
  strip(node);
  delete node.object;
  delete node.property;
  delete node.computed;
  if (!node.table)
    delete node.table;
}
function clean_default(ast2) {
  walk(ast2, null, {
    Column: stripMember,
    Constant: stripMember,
    Default: strip
  });
  return ast2;
}

// node_modules/arquero/src/expression/ast/util.js
function is(type, node) {
  return node && node.type === type;
}
function isFunctionExpression(node) {
  return is(FunctionExpression, node) || is(ArrowFunctionExpression, node);
}

// node_modules/arquero/src/util/to-function.js
function to_function_default(value) {
  return is_function_default(value) ? value : () => value;
}

// node_modules/arquero/src/expression/parse-escape.js
var ERROR_ESC_AGGRONLY = "Escaped functions are not valid as rollup or pivot values.";
function parse_escape_default(ctx, spec, params) {
  if (ctx.aggronly)
    error_default(ERROR_ESC_AGGRONLY);
  const code = "(row,data)=>fn(" + rowObjectCode(ctx.table.columnNames()) + ",$)";
  return { escape: compile_default.escape(code, to_function_default(spec.expr), params) };
}

// node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set) {
  var pos = 65536;
  for (var i2 = 0; i2 < set.length; i2 += 2) {
    pos += set[i2];
    if (pos > code) {
      return false;
    }
    pos += set[i2 + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name2, prec) {
  return new TokenType(name2, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name2, options) {
  if (options === void 0)
    options = {};
  options.keyword = name2;
  return keywords[name2] = new TokenType(name2, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from2, end) {
  if (end === void 0)
    end = code.length;
  for (var i2 = from2; i2 < end; i2++) {
    var next = code.charCodeAt(i2);
    if (isNewLine(next)) {
      return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref2 = Object.prototype;
var hasOwnProperty2 = ref2.hasOwnProperty;
var toString = ref2.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty2.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt2 in defaultOptions) {
    options[opt2] = opts && hasOwn(opts, opt2) ? opts[opt2] : defaultOptions[opt2];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array3) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array3.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref3 = this.currentThisScope();
  var flags = ref3.flags;
  var inClassFieldInit = ref3.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref3 = this.currentThisScope();
  var flags = ref3.flags;
  var inClassFieldInit = ref3.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i2 = 0; i2 < plugins.length; i2++) {
    cls = plugins[i2](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name2) {
  return this.type === types$1.name && this.value === name2 && !this.containsEsc;
};
pp$9.eatContextual = function(name2) {
  if (!this.isContextual(name2)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name2) {
  if (!this.eatContextual(name2)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule) {
    for (var i2 = 0, list3 = Object.keys(this.undefinedExports); i2 < list3.length; i2 += 1) {
      var name2 = list3[i2];
      this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i2 = 0;
  for (; i2 < this.labels.length; ++i2) {
    var lab = this.labels[i2];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i2 === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init2, false, refDestructuringErrors);
    this.checkLValPattern(init2);
    return this.parseForIn(node, init2);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init2);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list3 = this.labels; i$1 < list3.length; i$1 += 1) {
    var label = list3[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
    var label$1 = this.labels[i2];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node === void 0)
    node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init2) {
  node.init = init2;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init2) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init2.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init2;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key2 = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key2.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key2.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key2.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref3 = this.privateNameStack.pop();
  var declared = ref3.declared;
  var used = ref3.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i2 = 0; i2 < used.length; ++i2) {
    var id = used[i2];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name2 = element.key.name;
  var curr = privateNameMap[name2];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name2) {
  var computed = node.computed;
  var key2 = node.key;
  return !computed && (key2.type === "Identifier" && key2.name === name2 || key2.type === "Literal" && key2.value === name2);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
    } else {
      for (var i2 = 0, list3 = node.specifiers; i2 < list3.length; i2 += 1) {
        var spec = list3[i2];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports, name2, pos) {
  if (!exports) {
    return;
  }
  if (typeof name2 !== "string") {
    name2 = name2.type === "Identifier" ? name2.name : name2.value;
  }
  if (hasOwn(exports, name2)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
  }
  exports[name2] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i2 = 0, list3 = pat.properties; i2 < list3.length; i2 += 1) {
      var prop = list3[i2];
      this.checkPatternExport(exports, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i2 = 0, list3 = decls; i2 < list3.length; i2 += 1) {
    var decl = list3[i2];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
    statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i2 = 0, list3 = node.properties; i2 < list3.length; i2 += 1) {
          var prop = list3[i2];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i2 = 0; i2 < end; i2++) {
    var elt = exprList[i2];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i2 = 0, list3 = expr.properties; i2 < list3.length; i2 += 1) {
        var prop = list3[i2];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
    var context = this.context[i2];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update2, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update2 = type.updateContext) {
    update2.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr) {
      this.context[index] = types.f_expr_gen;
    } else {
      this.context[index] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key2 = prop.key;
  var name2;
  switch (key2.type) {
    case "Identifier":
      name2 = key2.name;
      break;
    case "Literal":
      name2 = String(key2.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name2 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key2.start;
          }
        } else {
          this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name2 = "$" + name2;
  var other = propHash[name2];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key2.start, "Redefinition of property");
    }
  } else {
    other = propHash[name2] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update2 = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update2, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update2) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update2 ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base = element;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "import";
    node.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "new";
    node.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref3) {
  var isTagged = ref3.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref3) {
  if (ref3 === void 0)
    ref3 = {};
  var isTagged = ref3.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  prop.kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i2 = 0, list3 = params; i2 < list3.length; i2 += 1) {
    var param = list3[i2];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i2 = 0, list3 = node.params; i2 < list3.length; i2 += 1) {
    var param = list3[i2];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref3) {
  var start = ref3.start;
  var end = ref3.end;
  var name2 = ref3.name;
  if (this.inGenerator && name2 === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name2 === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
    this.raise(start, "Cannot use " + name2 + " in class static initialization block");
  }
  if (this.keywords.test(name2)) {
    this.raise(start, "Unexpected keyword '" + name2 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name2)) {
    if (!this.inAsync && name2 === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name2, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
    scope.lexical.push(name2);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name2];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name2);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name2) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
    }
    scope$2.functions.push(name2);
  } else {
    for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
      var scope$3 = this.scopeStack[i2];
      if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name2);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) {
    newNode[prop] = node[prop];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i2 = 0, list3 = [9, 10, 11, 12, 13, 14]; i2 < list3.length; i2 += 1) {
  ecmaVersion = list3[i2];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i2;
var list3;
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i2, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i2 >= l) {
    return -1;
  }
  var c = s.charCodeAt(i2);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
    return c;
  }
  var next = s.charCodeAt(i2 + 1);
  return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i2 >= l) {
    return l;
  }
  var c = s.charCodeAt(i2), next;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
    return i2 + 1;
  }
  return i2 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0)
    forceU = false;
  var pos = this.pos;
  for (var i2 = 0, list3 = chs; i2 < list3.length; i2 += 1) {
    var ch = list3[i2];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i2 = 0; i2 < flags.length; i2++) {
    var flag = flags.charAt(i2);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i2 + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i2 = 0, list3 = state.backReferenceNames; i2 < list3.length; i2 += 1) {
    var name2 = list3[i2];
    if (state.groupNames.indexOf(name2) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    ) && state.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name2 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name2, value);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name2].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state))
    ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count2 = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count2++;
  }
  return count2 === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i2 = 0; i2 < length; ++i2) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i2 === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.11.3";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options) {
  return Parser.parse(input, options);
}

// node_modules/arquero/src/expression/constants.js
var constants_default = {
  undefined: "void(0)",
  Infinity: "Number.POSITIVE_INFINITY",
  NaN: "Number.NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2"
};

// node_modules/arquero/src/expression/parse-expression.js
var PARSER_OPT = { ecmaVersion: 11 };
var DEFAULT_PARAM_ID = "$";
var DEFAULT_TUPLE_ID = "d";
var DEFAULT_TUPLE_ID1 = "d1";
var DEFAULT_TUPLE_ID2 = "d2";
var NO = (msg) => (node, ctx) => ctx.error(node, msg + " not allowed");
var ERROR_AGGREGATE = NO("Aggregate function");
var ERROR_WINDOW = NO("Window function");
var ERROR_ARGUMENT = "Invalid argument";
var ERROR_COLUMN = "Invalid column reference";
var ERROR_AGGRONLY = ERROR_COLUMN + " (must be input to an aggregate function)";
var ERROR_FUNCTION = "Invalid function call";
var ERROR_MEMBER = "Invalid member expression";
var ERROR_OP_PARAMETER = "Invalid operator parameter";
var ERROR_PARAM = "Invalid param reference";
var ERROR_VARIABLE = "Invalid variable reference";
var ERROR_VARIABLE_OP = "Variable not accessible in operator call";
var ERROR_DECLARATION = "Unsupported variable declaration";
var ERROR_DESTRUCTURE = "Unsupported destructuring pattern";
var ERROR_CLOSURE = "Table expressions do not support closures";
var ERROR_ESCAPE = "Use aq.escape(fn) to use a function as-is (including closures)";
var ERROR_USE_PARAMS = "use table.params({ name: value }) to define dynamic parameters";
var ERROR_ADD_FUNCTION = "use aq.addFunction(name, fn) to add new op functions";
var ERROR_VARIABLE_NOTE = `
Note: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_USE_PARAMS}.`;
var ERROR_FUNCTION_NOTE = `
Note: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_ADD_FUNCTION}.`;
var ERROR_ROW_OBJECT = `The ${ROW_OBJECT} method is not valid in multi-table expressions.`;
function parseExpression(ctx, spec) {
  const ast2 = parseAST(spec);
  let node = ctx.root = ast2;
  ctx.spec = spec;
  ctx.tuple = null;
  ctx.tuple1 = null;
  ctx.tuple2 = null;
  ctx.$param = null;
  ctx.$op = 0;
  ctx.scope = /* @__PURE__ */ new Set();
  ctx.paramsRef = /* @__PURE__ */ new Map();
  ctx.columnRef = /* @__PURE__ */ new Map();
  if (isFunctionExpression(node)) {
    parseFunction(node, ctx);
    node = node.body;
  } else if (ctx.join) {
    ctx.scope.add(ctx.tuple1 = DEFAULT_TUPLE_ID1);
    ctx.scope.add(ctx.tuple2 = DEFAULT_TUPLE_ID2);
    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);
  } else {
    ctx.scope.add(ctx.tuple = DEFAULT_TUPLE_ID);
    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);
  }
  walk(node, ctx, visitors2);
  return ctx.root;
}
function parseAST(expr) {
  try {
    const code = expr.field ? fieldRef(expr) : is_array_default(expr) ? to_string_default(expr) : expr;
    return parse3(`expr=(${code})`, PARSER_OPT).body[0].expression.right;
  } catch (err) {
    error_default(`Expression parse error: ${expr + ""}`, err);
  }
}
function fieldRef(expr) {
  const col = JSON.stringify(expr + "");
  return !(expr.table || 0) ? `d=>d[${col}]` : `(a,b)=>b[${col}]`;
}
var visitors2 = {
  FunctionDeclaration: NO("Function definitions"),
  ForStatement: NO("For loops"),
  ForOfStatement: NO("For-of loops"),
  ForInStatement: NO("For-in loops"),
  WhileStatement: NO("While loops"),
  DoWhileStatement: NO("Do-while loops"),
  AwaitExpression: NO("Await expressions"),
  ArrowFunctionExpression: NO("Function definitions"),
  AssignmentExpression: NO("Assignments"),
  FunctionExpression: NO("Function definitions"),
  NewExpression: NO('Use of "new"'),
  UpdateExpression: NO("Update expressions"),
  VariableDeclarator(node, ctx) {
    handleDeclaration(node.id, ctx);
  },
  Identifier(node, ctx, parent) {
    if (handleIdentifier(node, ctx, parent) && !ctx.scope.has(node.name)) {
      ctx.error(node, ERROR_VARIABLE, ERROR_VARIABLE_NOTE);
    }
  },
  CallExpression(node, ctx) {
    const name2 = functionName(node.callee);
    const def = getAggregate(name2) || getWindow(name2);
    if (def) {
      if ((ctx.join || ctx.aggregate === false) && hasAggregate(name2)) {
        ERROR_AGGREGATE(node, ctx);
      }
      if ((ctx.join || ctx.window === false) && hasWindow(name2)) {
        ERROR_WINDOW(node, ctx);
      }
      ctx.$op = 1;
      if (ctx.ast) {
        updateFunctionNode(node, name2, ctx);
        node.arguments.forEach((arg) => walk(arg, ctx, opVisitors));
      } else {
        const op = ctx.op(parseOperator(ctx, def, name2, node.arguments));
        Object.assign(node, { type: Op2, name: op.id });
      }
      ctx.$op = 0;
      return false;
    } else if (hasFunction(name2)) {
      updateFunctionNode(node, name2, ctx);
    } else {
      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);
    }
  },
  MemberExpression(node, ctx, parent) {
    const { object, property } = node;
    if (!is(Identifier, object))
      return;
    const { name: name2 } = object;
    if (isMath(node) && is(Identifier, property) && has_default(constants_default, property.name)) {
      updateConstantNode(node, property.name);
      return;
    }
    const index = name2 === ctx.tuple ? 0 : name2 === ctx.tuple1 ? 1 : name2 === ctx.tuple2 ? 2 : -1;
    if (index >= 0) {
      return spliceMember(node, index, ctx, checkColumn, parent);
    } else if (name2 === ctx.$param) {
      return spliceMember(node, index, ctx, checkParam);
    } else if (ctx.paramsRef.has(name2)) {
      updateParameterNode(node, ctx.paramsRef.get(name2));
    } else if (ctx.columnRef.has(name2)) {
      updateColumnNode(object, name2, ctx, node);
    } else if (has_default(ctx.params, name2)) {
      updateParameterNode(object, name2);
    }
  }
};
function spliceMember(node, index, ctx, check, parent) {
  const { property, computed } = node;
  let name2;
  if (!computed) {
    name2 = property.name;
  } else if (is(Literal, property)) {
    name2 = property.value;
  } else
    try {
      walk(property, ctx, visitors2, node);
      name2 = ctx.param(property);
    } catch (e) {
      ctx.error(node, ERROR_MEMBER);
    }
  check(node, name2, index, ctx, parent);
  return false;
}
var opVisitors = {
  ...visitors2,
  VariableDeclarator: NO("Variable declaration in operator call"),
  Identifier(node, ctx, parent) {
    if (handleIdentifier(node, ctx, parent)) {
      ctx.error(node, ERROR_VARIABLE_OP);
    }
  },
  CallExpression(node, ctx) {
    const name2 = functionName(node.callee);
    if (hasFunction(name2)) {
      updateFunctionNode(node, name2, ctx);
    } else {
      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);
    }
  }
};
function parseFunction(node, ctx) {
  if (node.generator)
    NO("Generator functions")(node, ctx);
  if (node.async)
    NO("Async functions")(node, ctx);
  const { params } = node;
  const len = params.length;
  const setc = (index) => (name2, key2) => ctx.columnRef.set(name2, [key2, index]);
  const setp = (name2, key2) => ctx.paramsRef.set(name2, key2);
  if (!len) {
  } else if (ctx.join) {
    parseRef(ctx, params[0], "tuple1", setc(1));
    if (len > 1)
      parseRef(ctx, params[1], "tuple2", setc(2));
    if (len > 2)
      parseRef(ctx, params[2], "$param", setp);
  } else {
    parseRef(ctx, params[0], "tuple", setc(0));
    if (len > 1)
      parseRef(ctx, params[1], "$param", setp);
  }
  ctx.root = node.body;
}
function parseRef(ctx, node, refName, alias) {
  if (is(Identifier, node)) {
    ctx.scope.add(node.name);
    ctx[refName] = node.name;
  } else if (is(ObjectPattern, node)) {
    node.properties.forEach((p) => {
      const key2 = is(Identifier, p.key) ? p.key.name : is(Literal, p.key) ? p.key.value : ctx.error(p, ERROR_ARGUMENT);
      if (!is(Identifier, p.value)) {
        ctx.error(p.value, ERROR_DESTRUCTURE);
      }
      alias(p.value.name, key2);
    });
  }
}
function parseOperator(ctx, def, name2, args) {
  const fields = [];
  const params = [];
  const idxFields = def.param[0] || 0;
  const idxParams = idxFields + (def.param[1] || 0);
  args.forEach((arg, index) => {
    if (index < idxFields) {
      walk(arg, ctx, opVisitors);
      fields.push(ctx.field(arg));
    } else if (index < idxParams) {
      walk(arg, ctx, opVisitors);
      params.push(ctx.param(arg));
    } else {
      ctx.error(arg, ERROR_OP_PARAMETER);
    }
  });
  return { name: name2, fields, params, ...ctx.spec.window || {} };
}
function functionName(node) {
  return is(Identifier, node) ? node.name : !is(MemberExpression, node) ? null : isMath(node) ? rewriteMath(node.property.name) : node.property.name;
}
function isMath(node) {
  return is(Identifier, node.object) && node.object.name === "Math";
}
function rewriteMath(name2) {
  return name2 === "max" ? "greatest" : name2 === "min" ? "least" : name2;
}
function handleIdentifier(node, ctx, parent) {
  const { name: name2 } = node;
  if (is(MemberExpression, parent) && parent.property === node) {
  } else if (is(Property, parent) && parent.key === node) {
  } else if (ctx.paramsRef.has(name2)) {
    updateParameterNode(node, ctx.paramsRef.get(name2));
  } else if (ctx.columnRef.has(name2)) {
    updateColumnNode(node, name2, ctx, parent);
  } else if (has_default(ctx.params, name2)) {
    updateParameterNode(node, name2);
  } else if (has_default(constants_default, name2)) {
    updateConstantNode(node, name2);
  } else {
    return true;
  }
}
function checkColumn(node, name2, index, ctx, parent) {
  const table3 = index === 0 ? ctx.table : index > 0 ? ctx.join[index - 1] : null;
  const col = table3 && table3.column(name2);
  if (table3 && !col) {
    ctx.error(node, ERROR_COLUMN);
  }
  if (ctx.aggronly && !ctx.$op) {
    ctx.error(node, ERROR_AGGRONLY);
  }
  rewrite_default(node, name2, index, col, parent);
}
function updateColumnNode(node, key2, ctx, parent) {
  const [name2, index] = ctx.columnRef.get(key2);
  checkColumn(node, name2, index, ctx, parent);
}
function checkParam(node, name2, index, ctx) {
  if (ctx.params && !has_default(ctx.params, name2)) {
    ctx.error(node, ERROR_PARAM);
  }
  updateParameterNode(node, name2);
}
function updateParameterNode(node, name2) {
  node.type = Parameter;
  node.name = name2;
}
function updateConstantNode(node, name2) {
  node.type = Constant;
  node.name = name2;
  node.raw = constants_default[name2];
}
function updateFunctionNode(node, name2, ctx) {
  if (name2 === ROW_OBJECT) {
    const t2 = ctx.table;
    if (!t2)
      ctx.error(node, ERROR_ROW_OBJECT);
    rowObjectExpression(
      node,
      node.arguments.length ? node.arguments.map((node2) => {
        const col = ctx.param(node2);
        const name3 = is_number_default(col) ? t2.columnName(col) : col;
        if (!t2.column(name3))
          ctx.error(node2, ERROR_COLUMN);
        return name3;
      }) : t2.columnNames()
    );
  } else {
    node.callee = { type: Function2, name: name2 };
  }
}
function handleDeclaration(node, ctx) {
  if (is(Identifier, node)) {
    ctx.scope.add(node.name);
  } else if (is(ArrayPattern, node)) {
    node.elements.forEach((elm) => handleDeclaration(elm, ctx));
  } else if (is(ObjectPattern, node)) {
    node.properties.forEach((prop) => handleDeclaration(prop.value, ctx));
  } else {
    ctx.error(node.id, ERROR_DECLARATION);
  }
}

// node_modules/arquero/src/expression/parse.js
var ANNOTATE = { [Column2]: 1, [Op2]: 1 };
function parse_default(input, opt2 = {}) {
  const generate = opt2.generate || codegen_default;
  const compiler = opt2.compiler || compile_default;
  const params = getParams(opt2);
  const fields = {};
  const opcall = {};
  const names2 = [];
  const exprs = [];
  let fieldId = 0;
  let opId = -1;
  const compileExpr = opt2.join ? compiler.join : opt2.index == 1 ? compiler.expr2 : compiler.expr;
  const ctx = {
    op(op) {
      const key2 = opKey(op);
      return opcall[key2] || (op.id = ++opId, opcall[key2] = op);
    },
    field(node) {
      const code = generate(node);
      return fields[code] || (fields[code] = ++fieldId);
    },
    param(node) {
      return is(Literal, node) ? node.value : compiler.param(generate(node), params);
    },
    value(name2, node) {
      names2.push(name2);
      const e = node.escape || (opt2.ast ? clean_default(node) : compileExpr(generate(node), params));
      exprs.push(e);
      if (ANNOTATE[node.type] && e !== node && is_object_default(e)) {
        e.field = node.name;
      }
    },
    error(node, msg, note2 = "") {
      const i2 = node.start - 6;
      const j = node.end - 6;
      const snippet = String(ctx.spec).slice(i2, j);
      error_default(`${msg}: "${snippet}"${note2}`);
    }
  };
  Object.assign(ctx, opt2, { params });
  for (const [name2, value] of entries_default(input)) {
    ctx.value(
      name2 + "",
      value.escape ? parse_escape_default(ctx, value, params) : parseExpression(ctx, value)
    );
  }
  if (opt2.ast) {
    return { names: names2, exprs };
  }
  const f = [];
  for (const key2 in fields) {
    f[fields[key2]] = compiler.expr(key2, params);
  }
  const ops = Object.values(opcall);
  ops.forEach((op) => op.fields = op.fields.map((id) => f[id]));
  return { names: names2, exprs, ops };
}
function opKey(op) {
  let key2 = `${op.name}(${op.fields.concat(op.params).join(",")})`;
  if (op.frame) {
    const frame = op.frame.map((v) => Number.isFinite(v) ? Math.abs(v) : -1);
    key2 += `[${frame},${!!op.peers}]`;
  }
  return key2;
}
function getParams(opt2) {
  return (opt2.table ? getTableParams(opt2.table) : opt2.join ? {
    ...getTableParams(opt2.join[1]),
    ...getTableParams(opt2.join[0])
  } : {}) || {};
}
function getTableParams(table3) {
  return table3 && is_function_default(table3.params) ? table3.params() : {};
}

// node_modules/arquero/src/query/constants.js
var Expr = "Expr";
var ExprList = "ExprList";
var ExprNumber = "ExprNumber";
var ExprObject = "ExprObject";
var JoinKeys = "JoinKeys";
var JoinValues = "JoinValues";
var Options = "Options";
var OrderbyKeys = "OrderKeys";
var SelectionList = "SelectionList";
var TableRef = "TableRef";
var TableRefList = "TableRefList";
var Descending = "Descending";
var Query = "Query";
var Selection = "Selection";
var Verb = "Verb";
var Window = "Window";

// node_modules/arquero/src/helpers/wrap.js
function wrap_default(expr, properties) {
  return expr && expr.expr ? new Wrapper({ ...expr, ...properties }) : new Wrapper(properties, expr);
}
var Wrapper = class {
  constructor(properties, expr) {
    this.expr = expr;
    Object.assign(this, properties);
  }
  toString() {
    return String(this.expr);
  }
  toObject() {
    return {
      ...this,
      expr: this.toString(),
      ...is_function_default(this.expr) ? { func: true } : {}
    };
  }
};

// node_modules/arquero/src/helpers/desc.js
function desc_default(expr) {
  return wrap_default(expr, { desc: true });
}

// node_modules/arquero/src/helpers/field.js
function field_default(expr, name2, table3 = 0) {
  const props = table3 ? { field: true, table: table3 } : { field: true };
  return wrap_default(
    expr,
    name2 ? { expr: name2, ...props } : props
  );
}

// node_modules/arquero/src/helpers/rolling.js
function rolling_default(expr, frame, includePeers) {
  return wrap_default(expr, {
    window: {
      frame: frame || [-Infinity, 0],
      peers: !!includePeers
    }
  });
}

// node_modules/arquero/src/query/util.js
function func3(expr) {
  const f = (d) => d;
  f.toString = () => expr;
  return f;
}
function getTable(catalog, ref3) {
  ref3 = ref3 && is_function_default(ref3.query) ? ref3.query() : ref3;
  return ref3 && is_function_default(ref3.evaluate) ? ref3.evaluate(null, catalog) : catalog(ref3);
}
function isSelection(value) {
  return is_object_default(value) && (is_array_default(value.all) || is_array_default(value.matches) || is_array_default(value.not) || is_array_default(value.range));
}
function toObject2(value) {
  return value && is_function_default(value.toObject) ? value.toObject() : is_function_default(value) ? { expr: String(value), func: true } : is_array_default(value) ? value.map(toObject2) : is_object_default(value) ? map_object_default(value, (_) => toObject2(_)) : value;
}
function fromObject(value) {
  return is_array_default(value) ? value.map(fromObject) : !is_object_default(value) ? value : is_array_default(value.verbs) ? Query2.from(value) : is_array_default(value.all) ? all() : is_array_default(value.range) ? range(...value.range) : is_array_default(value.match) ? matches(RegExp(...value.match)) : is_array_default(value.not) ? not(value.not.map(toObject2)) : fromExprObject(value);
}
function fromExprObject(value) {
  let output4 = value;
  let expr = value.expr;
  if (expr != null) {
    if (value.field === true) {
      output4 = expr = field_default(expr);
    } else if (value.func === true) {
      output4 = expr = func3(expr);
    }
    if (is_object_default(value.window)) {
      const { frame, peers } = value.window;
      output4 = expr = rolling_default(expr, frame, peers);
    }
    if (value.desc === true) {
      output4 = desc_default(expr);
    }
  }
  return value === output4 ? map_object_default(value, (_) => fromObject(_)) : output4;
}
function joinKeys(keys) {
  return is_array_default(keys) ? keys.map(parseJoinKeys) : keys;
}
function parseJoinKeys(keys) {
  const list3 = [];
  to_array_default(keys).forEach((param) => {
    is_number_default(param) ? list3.push(param) : is_string_default(param) ? list3.push(field_default(param, null)) : is_object_default(param) && param.expr ? list3.push(param) : is_function_default(param) ? list3.push(param) : error_default(`Invalid key value: ${param + ""}`);
  });
  return list3;
}
function joinValues(values2) {
  return is_array_default(values2) ? values2.map(parseJoinValues) : values2;
}
function parseJoinValues(values2, index) {
  return index < 2 ? to_array_default(values2) : values2;
}
function orderbyKeys(keys) {
  const list3 = [];
  keys.forEach((param) => {
    const expr = param.expr != null ? param.expr : param;
    if (is_object_default(expr) && !is_function_default(expr)) {
      for (const key2 in expr) {
        list3.push(expr[key2]);
      }
    } else {
      param = is_number_default(expr) ? expr : is_string_default(expr) ? field_default(param) : is_function_default(expr) ? param : error_default(`Invalid orderby field: ${param + ""}`);
      list3.push(param);
    }
  });
  return list3;
}

// node_modules/arquero/src/query/to-ast.js
var Methods = {
  [Expr]: astExpr,
  [ExprList]: astExprList,
  [ExprNumber]: astExprNumber,
  [ExprObject]: astExprObject,
  [JoinKeys]: astJoinKeys,
  [JoinValues]: astJoinValues,
  [OrderbyKeys]: astExprList,
  [SelectionList]: astSelectionList
};
function to_ast_default(value, type, propTypes) {
  return type === TableRef ? astTableRef(value) : type === TableRefList ? value.map(astTableRef) : ast(toObject2(value), type, propTypes);
}
function ast(value, type, propTypes) {
  return type === Options ? value ? astOptions(value, propTypes) : value : Methods[type](value);
}
function astOptions(value, types2 = {}) {
  const output4 = {};
  for (const key2 in value) {
    const prop = value[key2];
    output4[key2] = types2[key2] ? ast(prop, types2[key2]) : prop;
  }
  return output4;
}
function astParse(expr, opt2) {
  return parse_default({ expr }, { ...opt2, ast: true }).exprs[0];
}
function astColumn(name2) {
  return { type: Column2, name: name2 };
}
function astColumnIndex(index) {
  return { type: Column2, index };
}
function astExprObject(obj, opt2) {
  if (is_string_default(obj)) {
    return astParse(obj, opt2);
  }
  if (obj.expr) {
    let ast2;
    if (obj.field === true) {
      ast2 = astColumn(obj.expr);
    } else if (obj.func === true) {
      ast2 = astExprObject(obj.expr, opt2);
    }
    if (ast2) {
      if (obj.desc) {
        ast2 = { type: Descending, expr: ast2 };
      }
      if (obj.window) {
        ast2 = { type: Window, expr: ast2, ...obj.window };
      }
      return ast2;
    }
  }
  return Object.keys(obj).map((key2) => ({
    ...astExprObject(obj[key2], opt2),
    as: key2
  }));
}
function astSelection(sel) {
  const type = Selection;
  return sel.all ? { type, operator: "all" } : sel.not ? { type, operator: "not", arguments: astExprList(sel.not) } : sel.range ? { type, operator: "range", arguments: astExprList(sel.range) } : sel.matches ? { type, operator: "matches", arguments: sel.matches } : error_default("Invalid input");
}
function astSelectionList(arr) {
  return to_array_default(arr).map(astSelectionItem).flat();
}
function astSelectionItem(val) {
  return isSelection(val) ? astSelection(val) : is_number_default(val) ? astColumnIndex(val) : is_string_default(val) ? astColumn(val) : is_object_default(val) ? Object.keys(val).map((name2) => ({ type: Column2, name: name2, as: val[name2] })) : error_default("Invalid input");
}
function astExpr(val) {
  return isSelection(val) ? astSelection(val) : is_number_default(val) ? astColumnIndex(val) : is_string_default(val) ? astColumn(val) : is_object_default(val) ? astExprObject(val) : error_default("Invalid input");
}
function astExprList(arr) {
  return to_array_default(arr).map(astExpr).flat();
}
function astExprNumber(val) {
  return is_number_default(val) ? val : astExprObject(val);
}
function astJoinKeys(val) {
  return is_array_default(val) ? val.map(astExprList) : astExprObject(val, { join: true });
}
function astJoinValues(val) {
  return is_array_default(val) ? val.map(
    (v, i2) => i2 < 2 ? astExprList(v) : astExprObject(v, { join: true })
  ) : astExprObject(val, { join: true });
}
function astTableRef(value) {
  return value && is_function_default(value.toAST) ? value.toAST() : value;
}

// node_modules/arquero/src/query/verb.js
var Verb2 = class {
  /**
   * Construct a new verb instance.
   * @param {string} verb The verb name.
   * @param {object[]} schema Schema describing verb parameters.
   * @param {any[]} params Array of parameter values.
   */
  constructor(verb, schema = [], params = []) {
    this.verb = verb;
    this.schema = schema;
    schema.forEach((s, index) => {
      const type = s.type;
      const param = params[index];
      const value = type === JoinKeys ? joinKeys(param) : type === JoinValues ? joinValues(param) : type === OrderbyKeys ? orderbyKeys(param) : param;
      this[s.name] = value !== void 0 ? value : s.default;
    });
  }
  /**
   * Create new verb instance from the given serialized object.
   * @param {object} object A serialized verb representation, such as
   *  those generated by Verb.toObject.
   * @returns {Verb} The instantiated verb.
   */
  static from(object) {
    const verb = Verbs[object.verb];
    const params = (verb.schema || []).map(({ name: name2 }) => fromObject(object[name2]));
    return verb(...params);
  }
  /**
   * Evaluate this verb against a given table and catalog.
   * @param {Table} table The Arquero table to process.
   * @param {Function} catalog A table lookup function that accepts a table
   *  name string as input and returns a corresponding Arquero table.
   * @returns {Table} The resulting Arquero table.
   */
  evaluate(table3, catalog) {
    const params = this.schema.map(({ name: name2, type }) => {
      const value = this[name2];
      return type === TableRef ? getTable(catalog, value) : type === TableRefList ? value.map((t2) => getTable(catalog, t2)) : value;
    });
    return table3[this.verb](...params);
  }
  /**
   * Serialize this verb as a JSON-compatible object. The resulting
   * object can be passed to Verb.from to re-instantiate this verb.
   * @returns {object} A JSON-compatible object representing this verb.
   */
  toObject() {
    const obj = { verb: this.verb };
    this.schema.forEach(({ name: name2 }) => {
      obj[name2] = toObject2(this[name2]);
    });
    return obj;
  }
  /**
   * Serialize this verb to a JSON-compatible abstract syntax tree.
   * All table expressions will be parsed and represented as AST instances
   * using a modified form of the Mozilla JavaScript AST format.
   * This method can be used to output parsed and serialized representations
   * to translate Arquero verbs to alternative data processing platforms.
   * @returns {object} A JSON-compatible abstract syntax tree object.
   */
  toAST() {
    const obj = { type: Verb, verb: this.verb };
    this.schema.forEach(({ name: name2, type, props }) => {
      obj[name2] = to_ast_default(this[name2], type, props);
    });
    return obj;
  }
};
function createVerb(name2, schema) {
  return Object.assign(
    (...params) => new Verb2(name2, schema, params),
    { schema }
  );
}
var Verbs = {
  count: createVerb("count", [
    { name: "options", type: Options }
  ]),
  derive: createVerb("derive", [
    { name: "values", type: ExprObject },
    {
      name: "options",
      type: Options,
      props: { before: SelectionList, after: SelectionList }
    }
  ]),
  filter: createVerb("filter", [
    { name: "criteria", type: ExprObject }
  ]),
  groupby: createVerb("groupby", [
    { name: "keys", type: ExprList }
  ]),
  orderby: createVerb("orderby", [
    { name: "keys", type: OrderbyKeys }
  ]),
  relocate: createVerb("relocate", [
    { name: "columns", type: SelectionList },
    {
      name: "options",
      type: Options,
      props: { before: SelectionList, after: SelectionList }
    }
  ]),
  rename: createVerb("rename", [
    { name: "columns", type: SelectionList }
  ]),
  rollup: createVerb("rollup", [
    { name: "values", type: ExprObject }
  ]),
  sample: createVerb("sample", [
    { name: "size", type: ExprNumber },
    { name: "options", type: Options, props: { weight: Expr } }
  ]),
  select: createVerb("select", [
    { name: "columns", type: SelectionList }
  ]),
  ungroup: createVerb("ungroup"),
  unorder: createVerb("unorder"),
  reify: createVerb("reify"),
  dedupe: createVerb("dedupe", [
    { name: "keys", type: ExprList, default: [] }
  ]),
  impute: createVerb("impute", [
    { name: "values", type: ExprObject },
    { name: "options", type: Options, props: { expand: ExprList } }
  ]),
  fold: createVerb("fold", [
    { name: "values", type: ExprList },
    { name: "options", type: Options }
  ]),
  pivot: createVerb("pivot", [
    { name: "keys", type: ExprList },
    { name: "values", type: ExprList },
    { name: "options", type: Options }
  ]),
  spread: createVerb("spread", [
    { name: "values", type: ExprList },
    { name: "options", type: Options }
  ]),
  unroll: createVerb("unroll", [
    { name: "values", type: ExprList },
    { name: "options", type: Options, props: { drop: ExprList } }
  ]),
  lookup: createVerb("lookup", [
    { name: "table", type: TableRef },
    { name: "on", type: JoinKeys },
    { name: "values", type: ExprList }
  ]),
  join: createVerb("join", [
    { name: "table", type: TableRef },
    { name: "on", type: JoinKeys },
    { name: "values", type: JoinValues },
    { name: "options", type: Options }
  ]),
  cross: createVerb("cross", [
    { name: "table", type: TableRef },
    { name: "values", type: JoinValues },
    { name: "options", type: Options }
  ]),
  semijoin: createVerb("semijoin", [
    { name: "table", type: TableRef },
    { name: "on", type: JoinKeys }
  ]),
  antijoin: createVerb("antijoin", [
    { name: "table", type: TableRef },
    { name: "on", type: JoinKeys }
  ]),
  concat: createVerb("concat", [
    { name: "tables", type: TableRefList }
  ]),
  union: createVerb("union", [
    { name: "tables", type: TableRefList }
  ]),
  intersect: createVerb("intersect", [
    { name: "tables", type: TableRefList }
  ]),
  except: createVerb("except", [
    { name: "tables", type: TableRefList }
  ])
};

// node_modules/arquero/src/query/query.js
var Query2 = class _Query extends Transformable {
  /**
   * Construct a new query instance.
   * @param {Verb[]} verbs An array of verb instances.
   * @param {object} [params] Optional query parameters, corresponding
   *  to parameter references in table expressions.
   * @param {string} [table] Optional name of the table to query.
   */
  constructor(verbs, params, table3) {
    super(params);
    this._verbs = verbs || [];
    this._table = table3;
  }
  /**
   * Create a new query instance from the given serialized object.
   * @param {QueryObject} object A serialized query representation, such as
   *  those generated by Query.toObject.
   * @returns {Query} The instantiated query.
   */
  static from({ verbs, table: table3, params }) {
    return new _Query(verbs.map(Verb2.from), params, table3);
  }
  /**
   * Provide an informative object string tag.
   */
  get [Symbol.toStringTag]() {
    if (!this._verbs)
      return "Object";
    const ns = this._verbs.length;
    return `Query: ${ns} verbs` + (this._table ? ` on '${this._table}'` : "");
  }
  /**
   * Return the number of verbs in this query.
   */
  get length() {
    return this._verbs.length;
  }
  /**
   * Return the name of the table this query applies to.
   * @return {string} The name of the source table, or undefined.
   */
  get tableName() {
    return this._table;
  }
  /**
   * Get or set table expression parameter values.
   * If called with no arguments, returns the current parameter values
   * as an object. Otherwise, adds the provided parameters to this
   * query's parameter set and returns the table. Any prior parameters
   * with names matching the input parameters are overridden.
   * @param {object} values The parameter values.
   * @return {Query|object} The current parameter values (if called
   *  with no arguments) or this query.
   */
  params(values2) {
    if (arguments.length) {
      this._params = { ...this._params, ...values2 };
      return this;
    } else {
      return this._params;
    }
  }
  /**
   * Evaluate this query against a given table and catalog.
   * @param {Table} table The Arquero table to process.
   * @param {Function} catalog A table lookup function that accepts a table
   *  name string as input and returns a corresponding Arquero table.
   * @returns {Table} The resulting Arquero table.
   */
  evaluate(table3, catalog) {
    table3 = table3 || catalog(this._table);
    for (const verb of this._verbs) {
      table3 = verb.evaluate(table3.params(this._params), catalog);
    }
    return table3;
  }
  /**
   * Serialize this query as a JSON-compatible object. The resulting
   * object can be passed to Query.from to re-instantiate this query.
   * @returns {object} A JSON-compatible object representing this query.
   */
  toObject() {
    return serialize(this, "toObject");
  }
  /**
   * Serialize this query as a JSON-compatible object. The resulting
   * object can be passed to Query.from to re-instantiate this query.
   * This method simply returns the result of toObject, but is provided
   * as a separate method to allow later customization of JSON export.
   * @returns {object} A JSON-compatible object representing this query.
   */
  toJSON() {
    return this.toObject();
  }
  /**
   * Serialize this query to a JSON-compatible abstract syntax tree.
   * All table expressions will be parsed and represented as AST instances
   * using a modified form of the Mozilla JavaScript AST format.
   * This method can be used to output parsed and serialized representations
   * to translate Arquero queries to alternative data processing platforms.
   * @returns {object} A JSON-compatible abstract syntax tree object.
   */
  toAST() {
    return serialize(this, "toAST", { type: Query });
  }
};
function serialize(query2, method, props) {
  return {
    ...props,
    verbs: query2._verbs.map((verb) => verb[method]()),
    ...query2._params ? { params: query2._params } : null,
    ...query2._table ? { table: query2._table } : null
  };
}
function append(qb, verb) {
  return new Query2(
    qb._verbs.concat(verb),
    qb._params,
    qb._table
  );
}
for (const name2 in Verbs) {
  const verb = Verbs[name2];
  Query2.prototype["__" + name2] = function(qb, ...args) {
    return append(qb, verb(...args));
  };
}

// node_modules/arquero/package.json
var package_default = {
  name: "arquero",
  version: "5.4.0",
  description: "Query processing and transformation of array-backed data tables.",
  keywords: [
    "data",
    "query",
    "database",
    "table",
    "dataframe",
    "transform",
    "arrays"
  ],
  license: "BSD-3-Clause",
  author: "Jeffrey Heer (http://idl.cs.washington.edu)",
  main: "dist/arquero.node.js",
  module: "src/index-node.js",
  unpkg: "dist/arquero.min.js",
  jsdelivr: "dist/arquero.min.js",
  types: "dist/types/index.d.ts",
  browser: {
    "./dist/arquero.node.js": "./dist/arquero.min.js",
    "./src/index-node.js": "./src/index.js"
  },
  repository: {
    type: "git",
    url: "https://github.com/uwdata/arquero.git"
  },
  scripts: {
    prebuild: "rimraf dist && mkdir dist",
    build: "rollup -c rollup.config.mjs",
    postbuild: "tsc",
    preperf: "npm run build",
    perf: "TZ=America/Los_Angeles tape 'perf/**/*-perf.js'",
    lint: "eslint src test --ext .js",
    test: "TZ=America/Los_Angeles tape 'test/**/*-test.js' --require esm",
    prepublishOnly: "npm test && npm run lint && npm run build"
  },
  dependencies: {
    acorn: "^8.11.2",
    "apache-arrow": "^14.0.2",
    "node-fetch": "^2.6.7"
  },
  devDependencies: {
    "@rollup/plugin-json": "^6.1.0",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "@rollup/plugin-terser": "^0.4.4",
    eslint: "^8.56.0",
    esm: "^3.2.25",
    rimraf: "^5.0.5",
    rollup: "^4.9.1",
    "rollup-plugin-bundle-size": "^1.0.3",
    tape: "^5.7.2",
    typescript: "^5.3.3"
  },
  esm: {
    force: true,
    mainFields: ["module", "main"]
  }
};

// node_modules/arquero/src/util/unroll.js
function unroll_default(args, code, ...lists) {
  const v = ["_", "$"];
  const a = v.slice(0, lists.length);
  a.push(
    '"use strict"; const ' + lists.map((l, j) => l.map((_, i2) => `${v[j]}${i2} = ${v[j]}[${i2}]`).join(", ")).join(", ") + `; return (${args}) => ${code};`
  );
  return Function(...a)(...lists);
}

// node_modules/arquero/src/verbs/dedupe.js
function dedupe_default(table3, keys = []) {
  return table3.groupby(keys.length ? keys : table3.columnNames()).filter("row_number() === 1").ungroup().reify();
}

// node_modules/arquero/src/engine/select.js
function select_default(table3, columns2) {
  const cols = column_set_default();
  columns2.forEach((value, curr) => {
    const next = is_string_default(value) ? value : curr;
    if (next) {
      const col = table3.column(curr) || error_default(`Unrecognized column: ${curr}`);
      cols.add(next, col);
    }
  });
  return table3.create(cols);
}

// node_modules/arquero/src/verbs/relocate.js
function relocate_default(table3, columns2, { before, after } = {}) {
  const bef = before != null;
  const aft = after != null;
  if (!(bef || aft)) {
    error_default("relocate requires a before or after option.");
  }
  if (bef && aft) {
    error_default("relocate accepts only one of the before or after options.");
  }
  columns2 = resolve(table3, columns2);
  const anchors = [...resolve(table3, bef ? before : after).keys()];
  const anchor = bef ? anchors[0] : anchors.pop();
  const select = /* @__PURE__ */ new Map();
  table3.columnNames().forEach((name2) => {
    const assign = !columns2.has(name2);
    if (name2 === anchor) {
      if (aft && assign)
        select.set(name2, name2);
      for (const [key2, value] of columns2) {
        select.set(key2, value);
      }
      if (aft)
        return;
    }
    if (assign)
      select.set(name2, name2);
  });
  return select_default(table3, select);
}

// node_modules/arquero/src/util/concat.js
function concat_default(list3, fn = (x) => x, delim = "") {
  const n2 = list3.length;
  if (!n2)
    return "";
  let s = fn(list3[0], 0);
  for (let i2 = 1; i2 < n2; ++i2) {
    s += delim + fn(list3[i2], i2);
  }
  return s;
}

// node_modules/arquero/src/util/ascending.js
function ascending_default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/arquero/src/util/min.js
function min_default(values2, start = 0, stop2 = values2.length) {
  let min = stop2 ? values2[start++] : null_default;
  for (let i2 = start; i2 < stop2; ++i2) {
    if (min > values2[i2]) {
      min = values2[i2];
    }
  }
  return min;
}

// node_modules/arquero/src/util/max.js
function max_default(values2, start = 0, stop2 = values2.length) {
  let max = stop2 ? values2[start++] : null_default;
  for (let i2 = start; i2 < stop2; ++i2) {
    if (max < values2[i2]) {
      max = values2[i2];
    }
  }
  return max;
}

// node_modules/arquero/src/util/to-numeric.js
function to_numeric_default(value) {
  return is_bigint_default(value) ? value : +value;
}

// node_modules/arquero/src/util/quantile.js
function quantile(values2, p) {
  const n2 = values2.length;
  if (!n2)
    return null_default;
  if ((p = +p) <= 0 || n2 < 2)
    return to_numeric_default(values2[0]);
  if (p >= 1)
    return to_numeric_default(values2[n2 - 1]);
  const i2 = (n2 - 1) * p;
  const i0 = Math.floor(i2);
  const v0 = to_numeric_default(values2[i0]);
  return is_bigint_default(v0) ? v0 : v0 + (to_numeric_default(values2[i0 + 1]) - v0) * (i2 - i0);
}

// node_modules/arquero/src/util/value-list.js
var ValueList = class {
  constructor(values2) {
    this._values = values2 || [];
    this._sorted = null;
    this._start = 0;
  }
  values(copy) {
    if (this._start) {
      this._values = this._values.slice(this._start);
      this._start = 0;
    }
    return copy ? this._values.slice() : this._values;
  }
  add(value) {
    this._values.push(value);
    this._sorted = null;
  }
  rem() {
    this._start += 1;
    this._sorted = null;
  }
  min() {
    return this._sorted && this._sorted.length ? this._sorted[0] : min_default(this._values, this._start);
  }
  max() {
    return this._sorted && this._sorted.length ? this._sorted[this._sorted.length - 1] : max_default(this._values, this._start);
  }
  quantile(p) {
    if (!this._sorted) {
      this._sorted = this.values(true);
      this._sorted.sort(ascending_default);
    }
    return quantile(this._sorted, p);
  }
};

// node_modules/arquero/src/engine/reduce/field-reducer.js
var update = (ops, args, fn) => unroll_default(
  args,
  "{" + concat_default(ops, (_, i2) => `_${i2}.${fn}(${args});`) + "}",
  ops
);
function field_reducer_default(oplist, stream) {
  const { ops, output: output4 } = expand(oplist, stream);
  const fields = oplist[0].fields;
  const n2 = fields.length;
  const cls = n2 === 0 ? FieldReducer : n2 === 1 ? Field1Reducer : n2 === 2 ? Field2Reducer : error_default("Unsupported field count: " + n2);
  return new cls(fields, ops, output4, stream);
}
function expand(oplist, stream) {
  const has = {};
  const ops = [];
  function add(name2, params = []) {
    const key2 = name2 + ":" + params;
    if (has[key2])
      return has[key2];
    const def = getAggregate(name2);
    const op = def.create(...params);
    if (stream < 0 && def.stream) {
      def.stream.forEach((name3) => add(name3, []));
    }
    if (def.req) {
      def.req.forEach((name3) => add(name3, []));
    }
    has[key2] = op;
    ops.push(op);
    return op;
  }
  const output4 = oplist.map((item) => {
    const op = add(item.name, item.params);
    op.output = item.id;
    return op;
  });
  return { ops, output: output4 };
}
var FieldReducer = class extends Reducer {
  constructor(fields, ops, outputs, stream) {
    super(outputs);
    this._op = ops;
    this._fields = fields;
    this._stream = !!stream;
  }
  init() {
    const state = { count: 0, valid: 0, stream: this._stream };
    this._op.forEach((op) => op.init(state));
    if (state.values) {
      state.list = new ValueList();
    }
    return state;
  }
  write(state, values2, index) {
    const op = this._outputs;
    const n2 = op.length;
    for (let i2 = 0; i2 < n2; ++i2) {
      values2[op[i2].output][index] = op[i2].value(state);
    }
    return 1;
  }
  _add() {
  }
  _rem() {
  }
  add(state) {
    ++state.count;
  }
  rem(state) {
    --state.count;
  }
};
var Field1Reducer = class extends FieldReducer {
  constructor(fields, ops, outputs, stream) {
    super(fields, ops, outputs, stream);
    const args = ["state", "v1", "v2"];
    this._add = update(ops, args, "add");
    this._rem = update(ops, args, "rem");
  }
  add(state, row, data2) {
    const value = this._fields[0](row, data2);
    ++state.count;
    if (is_valid_default(value)) {
      ++state.valid;
      if (state.list)
        state.list.add(value);
      this._add(state, value);
    }
  }
  rem(state, row, data2) {
    const value = this._fields[0](row, data2);
    --state.count;
    if (is_valid_default(value)) {
      --state.valid;
      if (state.list)
        state.list.rem();
      this._rem(state, value);
    }
  }
};
var Field2Reducer = class extends FieldReducer {
  constructor(fields, ops, outputs, stream) {
    super(fields, ops, outputs, stream);
    const args = ["state", "v1", "v2"];
    this._add = update(ops, args, "add");
    this._rem = update(ops, args, "rem");
  }
  add(state, row, data2) {
    const value1 = this._fields[0](row, data2);
    const value2 = this._fields[1](row, data2);
    ++state.count;
    if (is_valid_default(value1) && is_valid_default(value2)) {
      ++state.valid;
      if (state.list)
        state.list.add([value1, value2]);
      this._add(state, value1, value2);
    }
  }
  rem(state, row, data2) {
    const value1 = this._fields[0](row, data2);
    const value2 = this._fields[1](row, data2);
    --state.count;
    if (is_valid_default(value1) && is_valid_default(value2)) {
      --state.valid;
      if (state.list)
        state.list.rem();
      this._rem(state, value1, value2);
    }
  }
};

// node_modules/arquero/src/engine/reduce/util.js
function aggregateGet(table3, ops, get2) {
  if (ops.length) {
    const data2 = table3.data();
    const { keys } = table3.groups() || {};
    const result = aggregate(table3, ops);
    const op = keys ? (name2, row) => result[name2][keys[row]] : (name2) => result[name2][0];
    get2 = get2.map((f) => (row) => f(row, data2, op));
  }
  return get2;
}
function aggregate(table3, ops, result) {
  if (!ops.length)
    return result;
  const aggrs = reducers(ops);
  const groups = table3.groups();
  const size = groups ? groups.size : 1;
  result = result || repeat_default(ops.length, () => Array(size));
  if (size > 1) {
    aggrs.forEach((aggr) => {
      const cells = reduceGroups(table3, aggr, groups);
      for (let i2 = 0; i2 < size; ++i2) {
        aggr.write(cells[i2], result, i2);
      }
    });
  } else {
    aggrs.forEach((aggr) => {
      const cell = reduceFlat(table3, aggr);
      aggr.write(cell, result, 0);
    });
  }
  return result;
}
function reducers(ops, stream) {
  const aggrs = [];
  const fields = {};
  for (const op of ops) {
    const key2 = op.fields.map((f) => f + "").join(",");
    (fields[key2] || (fields[key2] = [])).push(op);
  }
  for (const key2 in fields) {
    aggrs.push(field_reducer_default(fields[key2], stream));
  }
  return aggrs;
}
function reduceFlat(table3, reducer) {
  const cell = reducer.init();
  const n2 = table3.totalRows();
  const data2 = table3.data();
  const bits = table3.mask();
  if (table3.isOrdered()) {
    const idx = table3.indices();
    for (let i2 = 0; i2 < n2; ++i2) {
      reducer.add(cell, idx[i2], data2);
    }
  } else if (bits) {
    for (let i2 = bits.next(0); i2 >= 0; i2 = bits.next(i2 + 1)) {
      reducer.add(cell, i2, data2);
    }
  } else {
    for (let i2 = 0; i2 < n2; ++i2) {
      reducer.add(cell, i2, data2);
    }
  }
  return cell;
}
function reduceGroups(table3, reducer, groups) {
  const { keys, size } = groups;
  const cells = repeat_default(size, () => reducer.init());
  const data2 = table3.data();
  if (table3.isOrdered()) {
    const idx = table3.indices();
    const m = idx.length;
    for (let i2 = 0; i2 < m; ++i2) {
      const row = idx[i2];
      reducer.add(cells[keys[row]], row, data2);
    }
  } else if (table3.isFiltered()) {
    const bits = table3.mask();
    for (let i2 = bits.next(0); i2 >= 0; i2 = bits.next(i2 + 1)) {
      reducer.add(cells[keys[i2]], i2, data2);
    }
  } else {
    const n2 = table3.totalRows();
    for (let i2 = 0; i2 < n2; ++i2) {
      reducer.add(cells[keys[i2]], i2, data2);
    }
  }
  return cells;
}
function groupOutput(cols, groups) {
  const { get: get2, names: names2, rows, size } = groups;
  const m = names2.length;
  for (let j = 0; j < m; ++j) {
    const col = cols.add(names2[j], Array(size));
    const val = get2[j];
    for (let i2 = 0; i2 < size; ++i2) {
      col[i2] = val(rows[i2]);
    }
  }
}

// node_modules/arquero/src/util/bisector.js
function bisector_default(compare) {
  return {
    left(a, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        const mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    },
    right(a, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        const mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
  };
}

// node_modules/arquero/src/engine/window/window-state.js
var bisect = bisector_default(ascending_default);
function window_state_default(data2, frame, adjust, ops, aggrs) {
  let rows, peer, cells, result, key2;
  const isPeer = (index) => peer[index - 1] === peer[index];
  const numOps = ops.length;
  const numAgg = aggrs.length;
  const evaluate = ops.length ? unroll_default(
    ["w", "r", "k"],
    "{" + concat_default(ops, (_, i2) => `r[_${i2}.id][k]=_${i2}.value(w,_${i2}.get);`) + "}",
    ops
  ) : () => {
  };
  const w = {
    i0: 0,
    i1: 0,
    index: 0,
    size: 0,
    peer: isPeer,
    init(partition, peers, results, group2) {
      w.index = w.i0 = w.i1 = 0;
      w.size = peers.length;
      rows = partition;
      peer = peers;
      result = results;
      key2 = group2;
      cells = aggrs ? aggrs.map((aggr) => aggr.init()) : null;
      for (let i2 = 0; i2 < numOps; ++i2) {
        ops[i2].init();
      }
      return w;
    },
    value(index, get2) {
      return get2(rows[index], data2);
    },
    step(idx) {
      const [f0, f1] = frame;
      const n2 = w.size;
      const p0 = w.i0;
      const p1 = w.i1;
      w.i0 = f0 != null ? Math.max(0, idx - Math.abs(f0)) : 0;
      w.i1 = f1 != null ? Math.min(n2, idx + Math.abs(f1) + 1) : n2;
      w.index = idx;
      if (adjust) {
        if (w.i0 > 0 && isPeer(w.i0)) {
          w.i0 = bisect.left(peer, peer[w.i0]);
        }
        if (w.i1 < n2 && isPeer(w.i1)) {
          w.i1 = bisect.right(peer, peer[w.i1 - 1]);
        }
      }
      for (let i2 = 0; i2 < numAgg; ++i2) {
        const aggr = aggrs[i2];
        const cell = cells[i2];
        for (let j = p0; j < w.i0; ++j) {
          aggr.rem(cell, rows[j], data2);
        }
        for (let j = p1; j < w.i1; ++j) {
          aggr.add(cell, rows[j], data2);
        }
        aggr.write(cell, result, key2);
      }
      evaluate(w, result, key2);
      return result;
    }
  };
  return w;
}

// node_modules/arquero/src/engine/window/window.js
var frameValue = (op) => (op.frame || [null, null]).map((v) => Number.isFinite(v) ? Math.abs(v) : null);
var peersValue = (op) => !!op.peers;
function windowOp(spec) {
  const { id, name: name2, fields = [], params = [] } = spec;
  const op = getWindow(name2).create(...params);
  if (fields.length)
    op.get = fields[0];
  op.id = id;
  return op;
}
function window2(table3, cols, exprs, result = {}, ops) {
  const data2 = table3.data();
  const states = windowStates(ops, data2);
  const nstate = states.length;
  const write = unroll_default(
    ["r", "d", "op"],
    "{" + concat_default(cols, (_, i2) => `_${i2}[r] = $${i2}(r, d, op);`) + "}",
    cols,
    exprs
  );
  table3.partitions().forEach((rows, key2) => {
    const size = rows.length;
    const peers = windowPeers(table3, rows);
    for (let i2 = 0; i2 < nstate; ++i2) {
      states[i2].init(rows, peers, result, key2);
    }
    const op = (id) => result[id][key2];
    for (let index = 0; index < size; ++index) {
      for (let i2 = 0; i2 < nstate; ++i2) {
        states[i2].step(index);
      }
      write(rows[index], data2, op);
    }
  });
}
function windowStates(ops, data2) {
  const map = {};
  ops.forEach((op) => {
    const frame = frameValue(op);
    const peers = peersValue(op);
    const key2 = `${frame},${peers}`;
    const { aggOps, winOps } = map[key2] || (map[key2] = {
      frame,
      peers,
      aggOps: [],
      winOps: []
    });
    hasAggregate(op.name) ? aggOps.push(op) : winOps.push(windowOp(op));
  });
  return Object.values(map).map((_) => window_state_default(
    data2,
    _.frame,
    _.peers,
    _.winOps,
    reducers(_.aggOps, _.frame[0] != null ? -1 : 1)
  ));
}
function windowPeers(table3, rows) {
  if (table3.isOrdered()) {
    const compare = table3.comparator();
    const data2 = table3.data();
    const nrows = rows.length;
    const peers = new Uint32Array(nrows);
    for (let i2 = 1, index = 0; i2 < nrows; ++i2) {
      peers[i2] = compare(rows[i2 - 1], rows[i2], data2) ? ++index : index;
    }
    return peers;
  } else {
    return rows;
  }
}

// node_modules/arquero/src/engine/derive.js
function isWindowed(op) {
  return hasWindow(op.name) || op.frame && (Number.isFinite(op.frame[0]) || Number.isFinite(op.frame[1]));
}
function derive_default(table3, { names: names2, exprs, ops }, options = {}) {
  const total = table3.totalRows();
  const cols = column_set_default(options.drop ? null : table3);
  const data2 = names2.map((name2) => cols.add(name2, Array(total)));
  const [aggOps, winOps] = segmentOps(ops);
  const size = table3.isGrouped() ? table3.groups().size : 1;
  const result = aggregate(
    table3,
    aggOps,
    repeat_default(ops.length, () => Array(size))
  );
  winOps.length ? window2(table3, data2, exprs, result, winOps) : output(table3, data2, exprs, result);
  return table3.create(cols);
}
function segmentOps(ops) {
  const aggOps = [];
  const winOps = [];
  const n2 = ops.length;
  for (let i2 = 0; i2 < n2; ++i2) {
    const op = ops[i2];
    op.id = i2;
    (isWindowed(op) ? winOps : aggOps).push(op);
  }
  return [aggOps, winOps];
}
function output(table3, cols, exprs, result) {
  const bits = table3.mask();
  const data2 = table3.data();
  const { keys } = table3.groups() || {};
  const op = keys ? (id, row) => result[id][keys[row]] : (id) => result[id][0];
  const m = cols.length;
  for (let j = 0; j < m; ++j) {
    const get2 = exprs[j];
    const col = cols[j];
    if (bits) {
      for (let i2 = bits.next(0); i2 >= 0; i2 = bits.next(i2 + 1)) {
        col[i2] = get2(i2, data2, op);
      }
    } else {
      const n2 = table3.totalRows();
      for (let i2 = 0; i2 < n2; ++i2) {
        col[i2] = get2(i2, data2, op);
      }
    }
  }
}

// node_modules/arquero/src/verbs/derive.js
function derive_default2(table3, values2, options = {}) {
  const dt = derive_default(table3, parse_default(values2, { table: table3 }), options);
  return options.drop || options.before == null && options.after == null ? dt : relocate_default(
    dt,
    Object.keys(values2).filter((name2) => !table3.column(name2)),
    options
  );
}

// node_modules/arquero/src/verbs/except.js
function except_default(table3, others) {
  if (others.length === 0)
    return table3;
  const names2 = table3.columnNames();
  return others.reduce((a, b) => a.antijoin(b.select(names2)), table3).dedupe();
}

// node_modules/arquero/src/table/bit-set.js
var ONE = 2147483648;
var ALL = 4294967295;
var BitSet = class {
  /**
   * Instantiate a new BitSet instance.
   * @param {number} size The number of bits.
   */
  constructor(size) {
    this._size = size;
    this._bits = new Uint32Array(Math.ceil(size / 32));
  }
  /**
   * The number of bits.
   * @return {number}
   */
  get length() {
    return this._size;
  }
  /**
   * The number of bits set to one.
   * https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan
   * @return {number}
   */
  count() {
    const n2 = this._bits.length;
    let count2 = 0;
    for (let i2 = 0; i2 < n2; ++i2) {
      for (let b = this._bits[i2]; b; ++count2) {
        b &= b - 1;
      }
    }
    return count2;
  }
  /**
   * Get the bit at a given index.
   * @param {number} i The bit index.
   */
  get(i2) {
    return this._bits[i2 >> 5] & ONE >>> i2;
  }
  /**
   * Set the bit at a given index to one.
   * @param {number} i The bit index.
   */
  set(i2) {
    this._bits[i2 >> 5] |= ONE >>> i2;
  }
  /**
   * Clear the bit at a given index to zero.
   * @param {number} i The bit index.
   */
  clear(i2) {
    this._bits[i2 >> 5] &= ~(ONE >>> i2);
  }
  /**
   * Scan the bits, invoking a callback function with the index of
   * each non-zero bit.
   * @param {(i: number) => void} fn A callback function.
   */
  scan(fn) {
    for (let i2 = this.next(0); i2 >= 0; i2 = this.next(i2 + 1)) {
      fn(i2);
    }
  }
  /**
   * Get the next non-zero bit starting from a given index.
   * @param {number} i The bit index.
   */
  next(i2) {
    const bits = this._bits;
    const n2 = bits.length;
    let index = i2 >> 5;
    let curr = bits[index] & ALL >>> i2;
    for (; index < n2; curr = bits[++index]) {
      if (curr !== 0) {
        return (index << 5) + Math.clz32(curr);
      }
    }
    return -1;
  }
  /**
   * Return the index of the nth non-zero bit.
   * @param {number} n The number of non-zero bits to advance.
   * @return {number} The index of the nth non-zero bit.
   */
  nth(n2) {
    let i2 = this.next(0);
    while (n2-- && i2 >= 0)
      i2 = this.next(i2 + 1);
    return i2;
  }
  /**
   * Negate all bits in this bitset.
   * Modifies this BitSet in place.
   * @return {this}
   */
  not() {
    const bits = this._bits;
    const n2 = bits.length;
    for (let i2 = 0; i2 < n2; ++i2) {
      bits[i2] = ~bits[i2];
    }
    const tail = this._size % 32;
    if (tail) {
      bits[n2 - 1] &= ONE >> tail - 1;
    }
    return this;
  }
  /**
   * Compute the logical AND of this BitSet and another.
   * @param {BitSet} bitset The BitSet to combine with.
   * @return {BitSet} This BitSet updated with the logical AND.
   */
  and(bitset) {
    if (bitset) {
      const a = this._bits;
      const b = bitset._bits;
      const n2 = a.length;
      for (let i2 = 0; i2 < n2; ++i2) {
        a[i2] &= b[i2];
      }
    }
    return this;
  }
  /**
   * Compute the logical OR of this BitSet and another.
   * @param {BitSet} bitset The BitSet to combine with.
   * @return {BitSet} This BitSet updated with the logical OR.
   */
  or(bitset) {
    if (bitset) {
      const a = this._bits;
      const b = bitset._bits;
      const n2 = a.length;
      for (let i2 = 0; i2 < n2; ++i2) {
        a[i2] |= b[i2];
      }
    }
    return this;
  }
};

// node_modules/arquero/src/engine/filter.js
function filter_default(table3, predicate) {
  const n2 = table3.totalRows();
  const bits = table3.mask();
  const data2 = table3.data();
  const filter = new BitSet(n2);
  if (bits) {
    for (let i2 = bits.next(0); i2 >= 0; i2 = bits.next(i2 + 1)) {
      if (predicate(i2, data2))
        filter.set(i2);
    }
  } else {
    for (let i2 = 0; i2 < n2; ++i2) {
      if (predicate(i2, data2))
        filter.set(i2);
    }
  }
  return table3.create({ filter });
}

// node_modules/arquero/src/verbs/filter.js
function filter_default2(table3, criteria) {
  const test2 = parse_default({ p: criteria }, { table: table3 });
  let predicate = test2.exprs[0];
  if (test2.ops.length) {
    const { data: data2 } = derive_default(table3, test2, { drop: true }).column("p");
    predicate = (row) => data2[row];
  }
  return filter_default(table3, predicate);
}

// node_modules/arquero/src/engine/unroll.js
function unroll_default2(table3, { names: names2 = [], exprs = [], ops = [] }, options = {}) {
  if (!names2.length)
    return table3;
  const limit = options.limit > 0 ? +options.limit : Infinity;
  const index = options.index ? options.index === true ? "index" : options.index + "" : null;
  const drop = new Set(options.drop);
  const get2 = aggregateGet(table3, ops, exprs);
  const cols = column_set_default();
  const nset = new Set(names2);
  const priors = [];
  const copies = [];
  const unroll = [];
  table3.columnNames().forEach((name2) => {
    if (!drop.has(name2)) {
      const col = cols.add(name2, []);
      if (!nset.has(name2)) {
        priors.push(table3.column(name2));
        copies.push(col);
      }
    }
  });
  names2.forEach((name2) => {
    if (!drop.has(name2)) {
      if (!cols.has(name2))
        cols.add(name2, []);
      unroll.push(cols.data[name2]);
    }
  });
  const icol = index ? cols.add(index, []) : null;
  let start = 0;
  const m = priors.length;
  const n2 = unroll.length;
  const copy = (row, maxlen) => {
    for (let i2 = 0; i2 < m; ++i2) {
      copies[i2].length = start + maxlen;
      copies[i2].fill(priors[i2].get(row), start, start + maxlen);
    }
  };
  const indices = icol ? (row, maxlen) => {
    for (let i2 = 0; i2 < maxlen; ++i2) {
      icol[row + i2] = i2;
    }
  } : () => {
  };
  if (n2 === 1) {
    const fn = get2[0];
    const col = unroll[0];
    table3.scan((row, data2) => {
      const array3 = to_array_default(fn(row, data2));
      const maxlen = Math.min(array3.length, limit);
      copy(row, maxlen);
      for (let j = 0; j < maxlen; ++j) {
        col[start + j] = array3[j];
      }
      indices(start, maxlen);
      start += maxlen;
    });
  } else {
    table3.scan((row, data2) => {
      let maxlen = 0;
      const arrays = get2.map((fn) => {
        const value = to_array_default(fn(row, data2));
        maxlen = Math.min(Math.max(maxlen, value.length), limit);
        return value;
      });
      copy(row, maxlen);
      for (let i2 = 0; i2 < n2; ++i2) {
        const col = unroll[i2];
        const arr = arrays[i2];
        for (let j = 0; j < maxlen; ++j) {
          col[start + j] = arr[j];
        }
      }
      indices(start, maxlen);
      start += maxlen;
    });
  }
  return table3.create(cols.new());
}

// node_modules/arquero/src/engine/fold.js
function fold_default(table3, { names: names2 = [], exprs = [], ops = [] }, options = {}) {
  if (names2.length === 0)
    return table3;
  const [k = "key", v = "value"] = options.as || [];
  const vals = aggregateGet(table3, ops, exprs);
  return unroll_default2(
    table3,
    {
      names: [k, v],
      exprs: [() => names2, (row, data2) => vals.map((fn) => fn(row, data2))]
    },
    { ...options, drop: names2 }
  );
}

// node_modules/arquero/src/verbs/util/parse.js
function parse_default2(name2, table3, params, options = { window: false }) {
  const exprs = /* @__PURE__ */ new Map();
  const marshal = (param) => {
    param = is_number_default(param) ? table3.columnName(param) : param;
    is_string_default(param) ? exprs.set(param, field_default(param)) : is_function_default(param) ? resolve(table3, param).forEach(marshal) : is_object_default(param) ? assign_default(exprs, param) : error_default(`Invalid ${name2} value: ${param + ""}`);
  };
  to_array_default(params).forEach(marshal);
  if (options.preparse) {
    options.preparse(exprs);
  }
  return parse_default(exprs, { table: table3, ...options });
}

// node_modules/arquero/src/verbs/fold.js
function fold_default2(table3, values2, options) {
  return fold_default(table3, parse_default2("fold", table3, values2), options);
}

// node_modules/arquero/src/engine/impute.js
function impute_default(table3, values2, keys, arrays) {
  const write = keys && keys.length;
  return impute(
    write ? expand2(table3, keys, arrays) : table3,
    values2,
    write
  );
}
function impute(table3, { names: names2, exprs, ops }, write) {
  const gets = aggregateGet(table3, ops, exprs);
  const cols = write ? null : column_set_default(table3);
  const rows = table3.totalRows();
  names2.forEach((name2, i2) => {
    const col = table3.column(name2);
    const out = write ? col.data : cols.add(name2, Array(rows));
    const get2 = gets[i2];
    table3.scan((idx) => {
      const v = col.get(idx);
      out[idx] = !is_valid_default(v) ? get2(idx) : v;
    });
  });
  return write ? table3 : table3.create(cols);
}
function expand2(table3, keys, values2) {
  const groups = table3.groups();
  const data2 = table3.data();
  const keyNames = (groups ? groups.names : []).concat(keys);
  const keyGet = (groups ? groups.get : []).concat(keys.map((key2) => table3.getter(key2)));
  const hash = /* @__PURE__ */ new Set();
  const keyTable = key_function_default(keyGet);
  table3.scan((idx, data3) => hash.add(keyTable(idx, data3)));
  const names2 = table3.columnNames();
  const cols = column_set_default();
  const out = names2.map((name2) => cols.add(name2, []));
  names2.forEach((name2, i2) => {
    const old = data2[name2];
    const col = out[i2];
    table3.scan((row) => col.push(old.get(row)));
  });
  const keyEnum = key_function_default(keyGet.map((k, i2) => (a) => a[i2]));
  const set = unroll_default(
    "v",
    "{" + out.map((_, i2) => `_${i2}.push(v[$${i2}]);`).join("") + "}",
    out,
    names2.map((name2) => keyNames.indexOf(name2))
  );
  if (groups) {
    let row = groups.keys.length;
    const prod = values2.reduce((p, a) => p * a.length, groups.size);
    const keys2 = new Uint32Array(prod + (row - hash.size));
    keys2.set(groups.keys);
    enumerate(groups, values2, (vec, idx) => {
      if (!hash.has(keyEnum(vec))) {
        set(vec);
        keys2[row++] = idx[0];
      }
    });
    cols.groupby({ ...groups, keys: keys2 });
  } else {
    enumerate(groups, values2, (vec) => {
      if (!hash.has(keyEnum(vec)))
        set(vec);
    });
  }
  return table3.create(cols.new());
}
function enumerate(groups, values2, callback) {
  const offset2 = groups ? groups.get.length : 0;
  const pad = groups ? 1 : 0;
  const len = pad + values2.length;
  const lens = new Int32Array(len);
  const idxs = new Int32Array(len);
  const set = [];
  if (groups) {
    const { get: get2, rows, size } = groups;
    lens[0] = size;
    set.push((vec2, idx) => {
      const row = rows[idx];
      for (let i2 = 0; i2 < offset2; ++i2) {
        vec2[i2] = get2[i2](row);
      }
    });
  }
  values2.forEach((a, i2) => {
    const j = i2 + offset2;
    lens[i2 + pad] = a.length;
    set.push((vec2, idx) => vec2[j] = a[idx]);
  });
  const vec = Array(offset2 + values2.length);
  for (let i2 = 0; i2 < len; ++i2) {
    set[i2](vec, 0);
  }
  callback(vec, idxs);
  for (let i2 = len - 1; i2 >= 0; ) {
    const idx = ++idxs[i2];
    if (idx < lens[i2]) {
      set[i2](vec, idx);
      callback(vec, idxs);
      i2 = len - 1;
    } else {
      idxs[i2] = 0;
      set[i2](vec, 0);
      --i2;
    }
  }
}

// node_modules/arquero/src/engine/rollup.js
function rollup_default(table3, { names: names2, exprs, ops }) {
  const cols = column_set_default();
  const groups = table3.groups();
  if (groups)
    groupOutput(cols, groups);
  output2(names2, exprs, groups, aggregate(table3, ops), cols);
  return table3.create(cols.new());
}
function output2(names2, exprs, groups, result = [], cols) {
  if (!exprs.length)
    return;
  const size = groups ? groups.size : 1;
  const op = (id, row) => result[id][row];
  const n2 = names2.length;
  for (let i2 = 0; i2 < n2; ++i2) {
    const get2 = exprs[i2];
    if (get2.field != null) {
      cols.add(names2[i2], result[get2.field]);
    } else if (size > 1) {
      const col = cols.add(names2[i2], Array(size));
      for (let j = 0; j < size; ++j) {
        col[j] = get2(j, null, op);
      }
    } else {
      cols.add(names2[i2], [get2(0, null, op)]);
    }
  }
}

// node_modules/arquero/src/verbs/impute.js
function impute_default2(table3, values2, options = {}) {
  values2 = parse_default(values2, { table: table3 });
  values2.names.forEach(
    (name2) => table3.column(name2) ? 0 : error_default(`Invalid impute column ${to_string_default(name2)}`)
  );
  if (options.expand) {
    const opt2 = { preparse, aggronly: true };
    const params = parse_default2("impute", table3, options.expand, opt2);
    const result = rollup_default(table3.ungroup(), params);
    return impute_default(
      table3,
      values2,
      params.names,
      params.names.map((name2) => result.get(name2, 0))
    );
  } else {
    return impute_default(table3, values2);
  }
}
function preparse(map) {
  map.forEach(
    (value, key2) => value.field ? map.set(key2, array_agg_distinct(value + "")) : 0
  );
}

// node_modules/arquero/src/verbs/intersect.js
function intersect_default(table3, others) {
  const names2 = table3.columnNames();
  return others.length ? others.reduce((a, b) => a.semijoin(b.select(names2)), table3).dedupe() : table3.reify([]);
}

// node_modules/arquero/src/engine/join/lookup.js
function rowLookup(table3, hash) {
  const lut = /* @__PURE__ */ new Map();
  table3.scan((row, data2) => {
    const key2 = hash(row, data2);
    if (key2 != null && key2 === key2) {
      lut.set(key2, row);
    }
  });
  return lut;
}
function indexLookup(idx, data2, hash) {
  const lut = /* @__PURE__ */ new Map();
  const n2 = idx.length;
  for (let i2 = 0; i2 < n2; ++i2) {
    const row = idx[i2];
    const key2 = hash(row, data2);
    if (key2 != null && key2 === key2) {
      lut.has(key2) ? lut.get(key2).push(i2) : lut.set(key2, [i2]);
    }
  }
  return lut;
}

// node_modules/arquero/src/engine/join.js
function emitter(columns2, getters) {
  const args = ["i", "a", "j", "b"];
  return unroll_default(
    args,
    "{" + concat_default(columns2, (_, i2) => `_${i2}.push($${i2}(${args}));`) + "}",
    columns2,
    getters
  );
}
function join_default(tableL, tableR, predicate, { names: names2, exprs }, options = {}) {
  const dataL = tableL.data();
  const idxL = tableL.indices(false);
  const nL = idxL.length;
  const hitL = new Int32Array(nL);
  const dataR = tableR.data();
  const idxR = tableR.indices(false);
  const nR = idxR.length;
  const hitR = new Int32Array(nR);
  const ncols = names2.length;
  const cols = column_set_default();
  const columns2 = Array(ncols);
  const getters = Array(ncols);
  for (let i2 = 0; i2 < names2.length; ++i2) {
    columns2[i2] = cols.add(names2[i2], []);
    getters[i2] = exprs[i2];
  }
  const emit = emitter(columns2, getters);
  const join = is_array_default(predicate) ? hashJoin : loopJoin;
  join(emit, predicate, dataL, dataR, idxL, idxR, hitL, hitR, nL, nR);
  if (options.left) {
    for (let i2 = 0; i2 < nL; ++i2) {
      if (!hitL[i2]) {
        emit(idxL[i2], dataL, -1, dataR);
      }
    }
  }
  if (options.right) {
    for (let j = 0; j < nR; ++j) {
      if (!hitR[j]) {
        emit(-1, dataL, idxR[j], dataR);
      }
    }
  }
  return tableL.create(cols.new());
}
function loopJoin(emit, predicate, dataL, dataR, idxL, idxR, hitL, hitR, nL, nR) {
  for (let i2 = 0; i2 < nL; ++i2) {
    const rowL = idxL[i2];
    for (let j = 0; j < nR; ++j) {
      const rowR = idxR[j];
      if (predicate(rowL, dataL, rowR, dataR)) {
        emit(rowL, dataL, rowR, dataR);
        hitL[i2] = 1;
        hitR[j] = 1;
      }
    }
  }
}
function hashJoin(emit, [keyL, keyR], dataL, dataR, idxL, idxR, hitL, hitR, nL, nR) {
  let dataScan, keyScan, hitScan, idxScan;
  let dataHash, keyHash, hitHash, idxHash;
  let emitScan = emit;
  if (nL >= nR) {
    dataScan = dataL;
    keyScan = keyL;
    hitScan = hitL;
    idxScan = idxL;
    dataHash = dataR;
    keyHash = keyR;
    hitHash = hitR;
    idxHash = idxR;
  } else {
    dataScan = dataR;
    keyScan = keyR;
    hitScan = hitR;
    idxScan = idxR;
    dataHash = dataL;
    keyHash = keyL;
    hitHash = hitL;
    idxHash = idxL;
    emitScan = (i2, a, j, b) => emit(j, b, i2, a);
  }
  const lut = indexLookup(idxHash, dataHash, keyHash);
  const m = idxScan.length;
  for (let j = 0; j < m; ++j) {
    const rowScan = idxScan[j];
    const list3 = lut.get(keyScan(rowScan, dataScan));
    if (list3) {
      const n2 = list3.length;
      for (let k = 0; k < n2; ++k) {
        const i2 = list3[k];
        emitScan(rowScan, dataScan, idxHash[i2], dataHash);
        hitHash[i2] = 1;
      }
      hitScan[j] = 1;
    }
  }
}

// node_modules/arquero/src/verbs/util/parse-key.js
function parse_key_default(name2, table3, params) {
  const exprs = /* @__PURE__ */ new Map();
  to_array_default(params).forEach((param, i2) => {
    param = is_number_default(param) ? table3.columnName(param) : param;
    is_string_default(param) ? exprs.set(i2, field_default(param)) : is_function_default(param) || is_object_default(param) && param.expr ? exprs.set(i2, param) : error_default(`Invalid ${name2} key value: ${param + ""}`);
  });
  const fn = parse_default(exprs, { table: table3, aggregate: false, window: false });
  return key_function_default(fn.exprs, true);
}

// node_modules/arquero/src/util/intersect.js
function intersect(a, b) {
  const set = new Set(b);
  return a.filter((x) => set.has(x));
}

// node_modules/arquero/src/verbs/util/join-keys.js
function inferKeys(tableL, tableR, on) {
  if (!on) {
    const isect = intersect(tableL.columnNames(), tableR.columnNames());
    if (!isect.length)
      error_default("Natural join requires shared column names.");
    on = [isect, isect];
  } else if (is_string_default(on)) {
    on = [on, on];
  } else if (is_array_default(on) && on.length === 1) {
    on = [on[0], on[0]];
  }
  return on;
}
function keyPredicate(tableL, tableR, onL, onR) {
  if (onL.length !== onR.length) {
    error_default("Mismatched number of join keys");
  }
  return [
    parse_key_default("join", tableL, onL),
    parse_key_default("join", tableR, onR)
  ];
}

// node_modules/arquero/src/verbs/join.js
var OPT_L = { aggregate: false, window: false };
var OPT_R = { ...OPT_L, index: 1 };
function join_default2(tableL, tableR, on, values2, options = {}) {
  on = inferKeys(tableL, tableR, on);
  const optParse = { join: [tableL, tableR] };
  let predicate;
  if (is_array_default(on)) {
    const [onL, onR] = on.map(to_array_default);
    predicate = keyPredicate(tableL, tableR, onL, onR);
    if (!values2) {
      values2 = inferValues(tableL, onL, onR, options);
    }
  } else {
    predicate = parse_default({ on }, optParse).exprs[0];
    if (!values2) {
      values2 = [all(), all()];
    }
  }
  return join_default(
    tableL,
    tableR,
    predicate,
    parseValues(tableL, tableR, values2, optParse, options && options.suffix),
    options
  );
}
function inferValues(tableL, onL, onR, options) {
  const isect = [];
  onL.forEach((s, i2) => is_string_default(s) && s === onR[i2] ? isect.push(s) : 0);
  const vR = not(isect);
  if (options.left && options.right) {
    const shared = new Set(isect);
    return [
      tableL.columnNames().map((s) => {
        const c = `[${to_string_default(s)}]`;
        return shared.has(s) ? { [s]: `(a, b) => a${c} == null ? b${c} : a${c}` } : s;
      }),
      vR
    ];
  }
  return options.right ? [vR, all()] : [all(), vR];
}
function parseValues(tableL, tableR, values2, optParse, suffix = []) {
  if (is_array_default(values2)) {
    let vL, vR, vJ, n2 = values2.length;
    vL = vR = vJ = { names: [], exprs: [] };
    if (n2--) {
      vL = parse_default2("join", tableL, values2[0], optParse);
    }
    if (n2--) {
      vR = parse_default2("join", tableR, values2[1], OPT_R);
    }
    if (n2--) {
      vJ = parse_default(values2[2], optParse);
    }
    const rename = /* @__PURE__ */ new Set();
    const namesL = new Set(vL.names);
    vR.names.forEach((name2) => {
      if (namesL.has(name2)) {
        rename.add(name2);
      }
    });
    if (rename.size) {
      suffix[0] !== "" && rekey(vL.names, rename, suffix[0] || "_1");
      suffix[1] !== "" && rekey(vR.names, rename, suffix[1] || "_2");
    }
    return {
      names: vL.names.concat(vR.names, vJ.names),
      exprs: vL.exprs.concat(vR.exprs, vJ.exprs)
    };
  } else {
    return parse_default(values2, optParse);
  }
}
function rekey(names2, rename, suffix) {
  names2.forEach((name2, i2) => rename.has(name2) ? names2[i2] = name2 + suffix : 0);
}

// node_modules/arquero/src/engine/join-filter.js
function join_filter_default(tableL, tableR, predicate, options = {}) {
  const filter = new BitSet(tableL.totalRows());
  const join = is_array_default(predicate) ? hashSemiJoin : loopSemiJoin;
  join(filter, tableL, tableR, predicate);
  if (options.anti) {
    filter.not().and(tableL.mask());
  }
  return tableL.create({ filter });
}
function hashSemiJoin(filter, tableL, tableR, [keyL, keyR]) {
  const lut = rowLookup(tableR, keyR);
  tableL.scan((rowL, data2) => {
    const rowR = lut.get(keyL(rowL, data2));
    if (rowR >= 0)
      filter.set(rowL);
  });
}
function loopSemiJoin(filter, tableL, tableR, predicate) {
  const nL = tableL.numRows();
  const nR = tableR.numRows();
  const dataL = tableL.data();
  const dataR = tableR.data();
  if (tableL.isFiltered() || tableR.isFiltered()) {
    const idxL = tableL.indices(false);
    const idxR = tableR.indices(false);
    for (let i2 = 0; i2 < nL; ++i2) {
      const rowL = idxL[i2];
      for (let j = 0; j < nR; ++j) {
        if (predicate(rowL, dataL, idxR[j], dataR)) {
          filter.set(rowL);
          break;
        }
      }
    }
  } else {
    for (let i2 = 0; i2 < nL; ++i2) {
      for (let j = 0; j < nR; ++j) {
        if (predicate(i2, dataL, j, dataR)) {
          filter.set(i2);
          break;
        }
      }
    }
  }
}

// node_modules/arquero/src/verbs/join-filter.js
function join_filter_default2(tableL, tableR, on, options) {
  on = inferKeys(tableL, tableR, on);
  const predicate = is_array_default(on) ? keyPredicate(tableL, tableR, ...on.map(to_array_default)) : parse_default({ on }, { join: [tableL, tableR] }).exprs[0];
  return join_filter_default(tableL, tableR, predicate, options);
}

// node_modules/arquero/src/engine/lookup.js
function lookup_default(tableL, tableR, [keyL, keyR], { names: names2, exprs, ops }) {
  const cols = column_set_default(tableL);
  const total = tableL.totalRows();
  names2.forEach((name2) => cols.add(name2, Array(total).fill(null_default)));
  const lut = rowLookup(tableR, keyR);
  const set = unroll_default(
    ["lr", "rr", "data"],
    "{" + concat_default(names2, (_, i2) => `_[${i2}][lr] = $[${i2}](rr, data);`) + "}",
    names2.map((name2) => cols.data[name2]),
    aggregateGet(tableR, ops, exprs)
  );
  const dataR = tableR.data();
  tableL.scan((lrow, data2) => {
    const rrow = lut.get(keyL(lrow, data2));
    if (rrow >= 0)
      set(lrow, rrow, dataR);
  });
  return tableL.create(cols);
}

// node_modules/arquero/src/verbs/lookup.js
function lookup_default2(tableL, tableR, on, values2) {
  on = inferKeys(tableL, tableR, on);
  return lookup_default(
    tableL,
    tableR,
    [parse_key_default("lookup", tableL, on[0]), parse_key_default("lookup", tableR, on[1])],
    parse_default2("lookup", tableR, values2)
  );
}

// node_modules/arquero/src/engine/pivot.js
var opt = (value, defaultValue) => value != null ? value : defaultValue;
function pivot_default(table3, on, values2, options = {}) {
  const { keys, keyColumn } = pivotKeys(table3, on, options);
  const vsep = opt(options.valueSeparator, "_");
  const namefn = values2.names.length > 1 ? (i2, name2) => name2 + vsep + keys[i2] : (i2) => keys[i2];
  const results = keys.map(
    (k) => aggregate(table3, values2.ops.map((op) => {
      if (op.name === "count") {
        const fn = (r) => k === keyColumn[r] ? 1 : NaN;
        fn.toString = () => k + ":1";
        return { ...op, name: "sum", fields: [fn] };
      }
      const fields = op.fields.map((f) => {
        const fn = (r, d) => k === keyColumn[r] ? f(r, d) : NaN;
        fn.toString = () => k + ":" + f;
        return fn;
      });
      return { ...op, fields };
    }))
  );
  return table3.create(output3(values2, namefn, table3.groups(), results));
}
function pivotKeys(table3, on, options) {
  const limit = options.limit > 0 ? +options.limit : Infinity;
  const sort = opt(options.sort, true);
  const ksep = opt(options.keySeparator, "_");
  const get2 = aggregateGet(table3, on.ops, on.exprs);
  const key2 = get2.length === 1 ? get2[0] : (row, data2) => get2.map((fn) => fn(row, data2)).join(ksep);
  const kcol = Array(table3.totalRows());
  table3.scan((row, data2) => kcol[row] = key2(row, data2));
  const uniq = aggregate(
    table3.ungroup(),
    [{
      id: 0,
      name: "array_agg_distinct",
      fields: [(row) => kcol[row]],
      params: []
    }]
  )[0][0];
  const keys = sort ? uniq.sort() : uniq;
  return {
    keys: Number.isFinite(limit) ? keys.slice(0, limit) : keys,
    keyColumn: kcol
  };
}
function output3({ names: names2, exprs }, namefn, groups, results) {
  const size = groups ? groups.size : 1;
  const cols = column_set_default();
  const m = results.length;
  const n2 = names2.length;
  let result;
  const op = (id, row) => result[id][row];
  if (groups)
    groupOutput(cols, groups);
  for (let i2 = 0; i2 < n2; ++i2) {
    const get2 = exprs[i2];
    if (get2.field != null) {
      for (let j = 0; j < m; ++j) {
        cols.add(namefn(j, names2[i2]), results[j][get2.field]);
      }
    } else if (size > 1) {
      for (let j = 0; j < m; ++j) {
        result = results[j];
        const col = cols.add(namefn(j, names2[i2]), Array(size));
        for (let k = 0; k < size; ++k) {
          col[k] = get2(k, null, op);
        }
      }
    } else {
      for (let j = 0; j < m; ++j) {
        result = results[j];
        cols.add(namefn(j, names2[i2]), [get2(0, null, op)]);
      }
    }
  }
  return cols.new();
}

// node_modules/arquero/src/verbs/pivot.js
function pivot_default2(table3, on, values2, options) {
  return pivot_default(
    table3,
    parse_default2("fold", table3, on),
    parse_default2("fold", table3, values2, { preparse: preparse2, aggronly: true }),
    options
  );
}
function preparse2(map) {
  map.forEach(
    (value, key2) => value.field ? map.set(key2, any(value + "")) : 0
  );
}

// node_modules/arquero/src/verbs/rename.js
function rename_default(table3, columns2) {
  const map = /* @__PURE__ */ new Map();
  table3.columnNames((x) => (map.set(x, x), 0));
  return select_default(table3, resolve(table3, columns2, map));
}

// node_modules/arquero/src/verbs/rollup.js
function rollup_default2(table3, values2) {
  return rollup_default(table3, parse_default(values2, { table: table3, aggronly: true, window: false }));
}

// node_modules/arquero/src/util/sample.js
function sample_default(buffer, replace, index, weight) {
  return (replace ? weight ? sampleRW : sampleRU : weight ? sampleNW : sampleNU)(buffer.length, buffer, index, weight);
}
function sampleRU(size, buffer, index) {
  const n2 = index.length;
  for (let i2 = 0; i2 < size; ++i2) {
    buffer[i2] = index[n2 * random() | 0];
  }
  return buffer;
}
function sampleRW(size, buffer, index, weight) {
  const n2 = index.length;
  const w = new Float64Array(n2);
  let sum2 = 0;
  for (let i2 = 0; i2 < n2; ++i2) {
    w[i2] = sum2 += weight(index[i2]);
  }
  const bisect2 = bisector_default(ascending_default).right;
  for (let i2 = 0; i2 < size; ++i2) {
    buffer[i2] = index[bisect2(w, sum2 * random())];
  }
  return buffer;
}
function sampleNU(size, buffer, index) {
  const n2 = index.length;
  if (size >= n2)
    return index;
  for (let i2 = 0; i2 < size; ++i2) {
    buffer[i2] = index[i2];
  }
  for (let i2 = size; i2 < n2; ++i2) {
    const j = i2 * random();
    if (j < size) {
      buffer[j | 0] = index[i2];
    }
  }
  return buffer;
}
function sampleNW(size, buffer, index, weight) {
  const n2 = index.length;
  if (size >= n2)
    return index;
  const w = new Float32Array(n2);
  const k = new Uint32Array(n2);
  for (let i2 = 0; i2 < n2; ++i2) {
    k[i2] = i2;
    w[i2] = -Math.log(random()) / weight(index[i2]);
  }
  k.sort((a, b) => w[a] - w[b]);
  for (let i2 = 0; i2 < size; ++i2) {
    buffer[i2] = index[k[i2]];
  }
  return buffer;
}

// node_modules/arquero/src/util/shuffle.js
function shuffle_default(array3, lo = 0, hi = array3.length) {
  let n2 = hi - (lo = +lo);
  while (n2) {
    const i2 = random() * n2-- | 0;
    const v = array3[n2 + lo];
    array3[n2 + lo] = array3[i2 + lo];
    array3[i2 + lo] = v;
  }
  return array3;
}

// node_modules/arquero/src/engine/sample.js
function sample_default2(table3, size, weight, options = {}) {
  const { replace, shuffle } = options;
  const parts = table3.partitions(false);
  let total = 0;
  size = parts.map((idx, group2) => {
    let s = size(group2);
    total += s = replace ? s : Math.min(idx.length, s);
    return s;
  });
  const samples = new Uint32Array(total);
  let curr = 0;
  parts.forEach((idx, group2) => {
    const sz = size[group2];
    const buf = samples.subarray(curr, curr += sz);
    if (!replace && sz === idx.length) {
      buf.set(idx);
    } else {
      sample_default(buf, replace, idx, weight);
    }
  });
  if (shuffle !== false && (parts.length > 1 || !replace)) {
    shuffle_default(samples);
  }
  return table3.reify(samples);
}

// node_modules/arquero/src/verbs/sample.js
function sample_default3(table3, size, options = {}) {
  return sample_default2(
    table3,
    parseSize(table3, size),
    parseWeight(table3, options.weight),
    options
  );
}
var get = (col) => (row) => col.get(row) || 0;
function parseSize(table3, size) {
  return is_number_default(size) ? () => size : get(rollup_default(table3, parse_default({ size }, { table: table3, window: false })).column("size"));
}
function parseWeight(table3, w) {
  if (w == null)
    return null;
  w = is_number_default(w) ? table3.columnName(w) : w;
  return get(
    is_string_default(w) ? table3.column(w) : derive_default(table3, parse_default({ w }, { table: table3 }), { drop: true }).column("w")
  );
}

// node_modules/arquero/src/verbs/select.js
function select_default2(table3, columns2) {
  return select_default(table3, resolve(table3, columns2));
}

// node_modules/arquero/src/engine/spread.js
function spread_default(table3, { names: names2, exprs, ops = [] }, options = {}) {
  if (names2.length === 0)
    return table3;
  const as = names2.length === 1 && options.as || [];
  const drop = options.drop == null ? true : !!options.drop;
  const limit = options.limit == null ? as.length || Infinity : Math.max(1, +options.limit || 1);
  const get2 = aggregateGet(table3, ops, exprs);
  const cols = column_set_default();
  const map = names2.reduce((map2, name2, i2) => map2.set(name2, i2), /* @__PURE__ */ new Map());
  const add = (index, name2) => {
    const columns2 = spread(table3, get2[index], limit);
    const n2 = columns2.length;
    for (let i2 = 0; i2 < n2; ++i2) {
      cols.add(as[i2] || `${name2}_${i2 + 1}`, columns2[i2]);
    }
  };
  table3.columnNames().forEach((name2) => {
    if (map.has(name2)) {
      if (!drop)
        cols.add(name2, table3.column(name2));
      add(map.get(name2), name2);
      map.delete(name2);
    } else {
      cols.add(name2, table3.column(name2));
    }
  });
  map.forEach(add);
  return table3.create(cols);
}
function spread(table3, get2, limit) {
  const nrows = table3.totalRows();
  const columns2 = [];
  table3.scan((row, data2) => {
    const values2 = to_array_default(get2(row, data2));
    const n2 = Math.min(values2.length, limit);
    while (columns2.length < n2) {
      columns2.push(Array(nrows).fill(null_default));
    }
    for (let i2 = 0; i2 < n2; ++i2) {
      columns2[i2][row] = values2[i2];
    }
  });
  return columns2;
}

// node_modules/arquero/src/verbs/spread.js
function spread_default2(table3, values2, options) {
  return spread_default(table3, parse_default2("spread", table3, values2), options);
}

// node_modules/arquero/src/verbs/union.js
function union_default(table3, others) {
  return table3.concat(others).dedupe();
}

// node_modules/arquero/src/verbs/unroll.js
function unroll_default3(table3, values2, options) {
  return unroll_default2(
    table3,
    parse_default2("unroll", table3, values2),
    options && options.drop ? { ...options, drop: parse_default2("unroll", table3, options.drop).names } : options
  );
}

// node_modules/arquero/src/engine/groupby.js
function groupby_default(table3, exprs) {
  return table3.create({
    groups: createGroups(table3, exprs)
  });
}
function createGroups(table3, { names: names2 = [], exprs = [], ops = [] }) {
  const n2 = names2.length;
  if (n2 === 0)
    return null;
  if (n2 === 1 && !table3.isFiltered() && exprs[0].field) {
    const col = table3.column(exprs[0].field);
    if (col.groups)
      return col.groups(names2);
  }
  let get2 = aggregateGet(table3, ops, exprs);
  const getKey = key_function_default(get2);
  const nrows = table3.totalRows();
  const keys = new Uint32Array(nrows);
  const index = {};
  const rows = [];
  const data2 = table3.data();
  const bits = table3.mask();
  if (bits) {
    for (let i2 = bits.next(0); i2 >= 0; i2 = bits.next(i2 + 1)) {
      const key2 = getKey(i2, data2) + "";
      const val = index[key2];
      keys[i2] = val != null ? val : index[key2] = rows.push(i2) - 1;
    }
  } else {
    for (let i2 = 0; i2 < nrows; ++i2) {
      const key2 = getKey(i2, data2) + "";
      const val = index[key2];
      keys[i2] = val != null ? val : index[key2] = rows.push(i2) - 1;
    }
  }
  if (!ops.length) {
    get2 = get2.map((f) => (row) => f(row, data2));
  }
  return { keys, get: get2, names: names2, rows, size: rows.length };
}

// node_modules/arquero/src/verbs/groupby.js
function groupby_default2(table3, values2) {
  return groupby_default(table3, parse_default2("groupby", table3, values2));
}

// node_modules/arquero/src/engine/orderby.js
function orderby_default(table3, comparator) {
  return table3.create({ order: comparator });
}

// node_modules/arquero/src/expression/compare.js
var _compare = (u, v, lt, gt) => `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}
    : (u > v || v == null) && u != null ? ${gt}
    : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}
    : v !== v && u === u ? ${gt} : `;
function compare_default(table3, fields) {
  const names2 = [];
  const exprs = [];
  const fn = [];
  let keys = null, opA = "0", opB = "0";
  if (table3.isGrouped()) {
    keys = table3.groups().keys;
    opA = "ka";
    opB = "kb";
  }
  const { ops } = parse_default(fields, {
    table: table3,
    value: (name2, node) => {
      names2.push(name2);
      if (node.escape) {
        const f = (i2) => `fn[${fn.length}](${i2}, data)`;
        exprs.push([f("a"), f("b")]);
        fn.push(node.escape);
      } else {
        exprs.push([
          codegen_default(node, { index: "a", op: opA }),
          codegen_default(node, { index: "b", op: opB })
        ]);
      }
    },
    window: false
  });
  const result = aggregate(table3, ops);
  const op = (id, row) => result[id][row];
  const n2 = names2.length;
  let code = "return (a, b) => {" + (op && table3.isGrouped() ? "const ka = keys[a], kb = keys[b];" : "") + "let u, v; return ";
  for (let i2 = 0; i2 < n2; ++i2) {
    const o = fields.get(names2[i2]).desc ? -1 : 1;
    const [u, v] = exprs[i2];
    code += _compare(u, v, -o, o);
  }
  code += "0;};";
  return Function("op", "keys", "fn", "data", code)(op, keys, fn, table3.data());
}

// node_modules/arquero/src/verbs/orderby.js
function orderby_default2(table3, values2) {
  return orderby_default(table3, parseValues2(table3, values2));
}
function parseValues2(table3, params) {
  let index = -1;
  const exprs = /* @__PURE__ */ new Map();
  const add = (val) => exprs.set(++index + "", val);
  params.forEach((param) => {
    const expr = param.expr != null ? param.expr : param;
    if (is_object_default(expr) && !is_function_default(expr)) {
      for (const key2 in expr)
        add(expr[key2]);
    } else {
      add(
        is_number_default(expr) ? field_default(param, table3.columnName(expr)) : is_string_default(expr) ? field_default(param) : is_function_default(expr) ? param : error_default(`Invalid orderby field: ${param + ""}`)
      );
    }
  });
  return compare_default(table3, exprs);
}

// node_modules/arquero/src/engine/concat.js
function concat_default2(table3, others) {
  const trows = table3.numRows();
  const nrows = trows + others.reduce((n2, t2) => n2 + t2.numRows(), 0);
  if (trows === nrows)
    return table3;
  const tables = [table3, ...others];
  const cols = column_set_default();
  table3.columnNames().forEach((name2) => {
    const arr = Array(nrows);
    let row = 0;
    tables.forEach((table4) => {
      const col = table4.column(name2) || { get: () => null_default };
      table4.scan((trow) => arr[row++] = col.get(trow));
    });
    cols.add(name2, arr);
  });
  return table3.create(cols.new());
}

// node_modules/arquero/src/engine/reduce.js
function reduce_default(table3, reducer) {
  const cols = column_set_default();
  const groups = table3.groups();
  const { get: get2, names: names2 = [], rows, size = 1 } = groups || {};
  const counts = new Uint32Array(size + 1);
  names2.forEach((name2) => cols.add(name2, null));
  const cells = groups ? reduceGroups(table3, reducer, groups) : [reduceFlat(table3, reducer)];
  reducer.outputs().map((name2) => cols.add(name2, []));
  const n2 = counts.length - 1;
  let len = 0;
  for (let i2 = 0; i2 < n2; ++i2) {
    len += counts[i2 + 1] = reducer.write(cells[i2], cols.data, counts[i2]);
  }
  if (groups) {
    const data2 = table3.data();
    names2.forEach((name2, index) => {
      const column = cols.data[name2] = Array(len);
      const getter = get2[index];
      for (let i2 = 0, j = 0; i2 < size; ++i2) {
        column.fill(getter(rows[i2], data2), j, j += counts[i2 + 1]);
      }
    });
  }
  return table3.create(cols.new());
}

// node_modules/arquero/src/engine/ungroup.js
function ungroup_default(table3) {
  return table3.isGrouped() ? table3.create({ groups: null }) : table3;
}

// node_modules/arquero/src/engine/unorder.js
function unorder_default(table3) {
  return table3.isOrdered() ? table3.create({ order: null }) : table3;
}

// node_modules/arquero/src/verbs/index.js
var verbs_default = {
  __antijoin: (table3, other, on) => join_filter_default2(table3, other, on, { anti: true }),
  __count: (table3, options = {}) => rollup_default2(table3, { [options.as || "count"]: count() }),
  __cross: (table3, other, values2, options) => join_default2(table3, other, () => true, values2, {
    ...options,
    left: true,
    right: true
  }),
  __concat: concat_default2,
  __dedupe: dedupe_default,
  __derive: derive_default2,
  __except: except_default,
  __filter: filter_default2,
  __fold: fold_default2,
  __impute: impute_default2,
  __intersect: intersect_default,
  __join: join_default2,
  __lookup: lookup_default2,
  __pivot: pivot_default2,
  __relocate: relocate_default,
  __rename: rename_default,
  __rollup: rollup_default2,
  __sample: sample_default3,
  __select: select_default2,
  __semijoin: join_filter_default2,
  __spread: spread_default2,
  __union: union_default,
  __unroll: unroll_default3,
  __groupby: groupby_default2,
  __orderby: orderby_default2,
  __ungroup: ungroup_default,
  __unorder: unorder_default,
  __reduce: reduce_default
};

// node_modules/arquero/src/table/index.js
Object.assign(ColumnTable.prototype, verbs_default);
function table2(columns2, names2) {
  return ColumnTable.new(columns2, names2);
}
function from(values2, names2) {
  return ColumnTable.from(values2, names2);
}

// node_modules/arquero/src/helpers/escape.js
function escape_default(value) {
  return wrap_default(value, {
    escape: true,
    toString() {
      error_default("Escaped values can not be serialized.");
    }
  });
}

// node_modules/arquero/src/register.js
var proto = ColumnTable.prototype;

// node_modules/arquero/src/index.js
var version2 = package_default.version;

// node_modules/vega-statistics/build/vega-statistics.module.js
function* numbers(values2, valueof) {
  if (valueof == null) {
    for (let value of values2) {
      if (value != null && value !== "" && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values2) {
      value = valueof(value, ++index, values2);
      if (value != null && value !== "" && (value = +value) >= value) {
        yield value;
      }
    }
  }
}
function quantiles(array3, p, f) {
  const values2 = Float64Array.from(numbers(array3, f));
  values2.sort(ascending);
  return p.map((_) => quantileSorted(values2, _));
}
function quartiles(array3, f) {
  return quantiles(array3, [0.25, 0.5, 0.75], f);
}
function estimateBandwidth(array3, f) {
  const n2 = array3.length, d = deviation(array3, f), q = quartiles(array3, f), h = (q[2] - q[0]) / 1.34, v = Math.min(d, h) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n2, -0.2);
}
var random2 = Math.random;
var SQRT2PI = Math.sqrt(2 * Math.PI);
var SQRT2 = Math.SQRT2;
var nextSample = NaN;
function sampleNormal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  let x = 0, y = 0, rds, c;
  if (nextSample === nextSample) {
    x = nextSample;
    nextSample = NaN;
  } else {
    do {
      x = random2() * 2 - 1;
      y = random2() * 2 - 1;
      rds = x * x + y * y;
    } while (rds === 0 || rds > 1);
    c = Math.sqrt(-2 * Math.log(rds) / rds);
    x *= c;
    nextSample = y * c;
  }
  return mean + x * stdev;
}
function densityNormal(value, mean, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value - (mean || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
}
function cumulativeNormal(value, mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value - mean) / stdev, Z = Math.abs(z);
  let cd;
  if (Z > 37) {
    cd = 0;
  } else {
    const exp = Math.exp(-Z * Z / 2);
    let sum2;
    if (Z < 7.07106781186547) {
      sum2 = 0.0352624965998911 * Z + 0.700383064443688;
      sum2 = sum2 * Z + 6.37396220353165;
      sum2 = sum2 * Z + 33.912866078383;
      sum2 = sum2 * Z + 112.079291497871;
      sum2 = sum2 * Z + 221.213596169931;
      sum2 = sum2 * Z + 220.206867912376;
      cd = exp * sum2;
      sum2 = 0.0883883476483184 * Z + 1.75566716318264;
      sum2 = sum2 * Z + 16.064177579207;
      sum2 = sum2 * Z + 86.7807322029461;
      sum2 = sum2 * Z + 296.564248779674;
      sum2 = sum2 * Z + 637.333633378831;
      sum2 = sum2 * Z + 793.826512519948;
      sum2 = sum2 * Z + 440.413735824752;
      cd = cd / sum2;
    } else {
      sum2 = Z + 0.65;
      sum2 = Z + 4 / sum2;
      sum2 = Z + 3 / sum2;
      sum2 = Z + 2 / sum2;
      sum2 = Z + 1 / sum2;
      cd = exp / sum2 / 2.506628274631;
    }
  }
  return z > 0 ? 1 - cd : cd;
}
function quantileNormal(p, mean, stdev) {
  if (p < 0 || p > 1)
    return NaN;
  return (mean || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
}
function erfinv(x) {
  let w = -Math.log((1 - x) * (1 + x)), p;
  if (w < 6.25) {
    w -= 3.125;
    p = -364441206401782e-35;
    p = -16850591381820166e-35 + p * w;
    p = 128584807152564e-32 + p * w;
    p = 11157877678025181e-33 + p * w;
    p = -1333171662854621e-31 + p * w;
    p = 20972767875968562e-33 + p * w;
    p = 6637638134358324e-30 + p * w;
    p = -4054566272975207e-29 + p * w;
    p = -8151934197605472e-29 + p * w;
    p = 26335093153082323e-28 + p * w;
    p = -12975133253453532e-27 + p * w;
    p = -5415412054294628e-26 + p * w;
    p = 10512122733215323e-25 + p * w;
    p = -4112633980346984e-24 + p * w;
    p = -29070369957882005e-24 + p * w;
    p = 42347877827932404e-23 + p * w;
    p = -13654692000834679e-22 + p * w;
    p = -13882523362786469e-21 + p * w;
    p = 18673420803405714e-20 + p * w;
    p = -740702534166267e-18 + p * w;
    p = -0.006033670871430149 + p * w;
    p = 0.24015818242558962 + p * w;
    p = 1.6536545626831027 + p * w;
  } else if (w < 16) {
    w = Math.sqrt(w) - 3.25;
    p = 22137376921775787e-25;
    p = 9075656193888539e-23 + p * w;
    p = -27517406297064545e-23 + p * w;
    p = 18239629214389228e-24 + p * w;
    p = 15027403968909828e-22 + p * w;
    p = -4013867526981546e-21 + p * w;
    p = 29234449089955446e-22 + p * w;
    p = 12475304481671779e-21 + p * w;
    p = -47318229009055734e-21 + p * w;
    p = 6828485145957318e-20 + p * w;
    p = 24031110387097894e-21 + p * w;
    p = -3550375203628475e-19 + p * w;
    p = 9532893797373805e-19 + p * w;
    p = -0.0016882755560235047 + p * w;
    p = 0.002491442096107851 + p * w;
    p = -0.003751208507569241 + p * w;
    p = 0.005370914553590064 + p * w;
    p = 1.0052589676941592 + p * w;
    p = 3.0838856104922208 + p * w;
  } else if (Number.isFinite(w)) {
    w = Math.sqrt(w) - 5;
    p = -27109920616438573e-27;
    p = -2555641816996525e-25 + p * w;
    p = 15076572693500548e-25 + p * w;
    p = -3789465440126737e-24 + p * w;
    p = 761570120807834e-23 + p * w;
    p = -1496002662714924e-23 + p * w;
    p = 2914795345090108e-23 + p * w;
    p = -6771199775845234e-23 + p * w;
    p = 22900482228026655e-23 + p * w;
    p = -99298272942317e-20 + p * w;
    p = 4526062597223154e-21 + p * w;
    p = -1968177810553167e-20 + p * w;
    p = 7599527703001776e-20 + p * w;
    p = -21503011930044477e-20 + p * w;
    p = -13871931833623122e-20 + p * w;
    p = 1.0103004648645344 + p * w;
    p = 4.849906401408584 + p * w;
  } else {
    p = Infinity;
  }
  return p * x;
}
function gaussian(mean, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },
    sample: () => sampleNormal(mu, sigma),
    pdf: (value) => densityNormal(value, mu, sigma),
    cdf: (value) => cumulativeNormal(value, mu, sigma),
    icdf: (p) => quantileNormal(p, mu, sigma)
  };
  return dist.mean(mean).stdev(stdev);
}
function kde(support, bandwidth) {
  const kernel = gaussian();
  let n2 = 0;
  const dist = {
    data(_) {
      if (arguments.length) {
        support = _;
        n2 = _ ? _.length : 0;
        return dist.bandwidth(bandwidth);
      } else {
        return support;
      }
    },
    bandwidth(_) {
      if (!arguments.length)
        return bandwidth;
      bandwidth = _;
      if (!bandwidth && support)
        bandwidth = estimateBandwidth(support);
      return dist;
    },
    sample() {
      return support[~~(random2() * n2)] + bandwidth * kernel.sample();
    },
    pdf(x) {
      let y = 0, i2 = 0;
      for (; i2 < n2; ++i2) {
        y += kernel.pdf((x - support[i2]) / bandwidth);
      }
      return y / bandwidth / n2;
    },
    cdf(x) {
      let y = 0, i2 = 0;
      for (; i2 < n2; ++i2) {
        y += kernel.cdf((x - support[i2]) / bandwidth);
      }
      return y / n2;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return dist.data(support);
}
var MIN_RADIANS = 0.5 * Math.PI / 180;
function sampleCurve(f, extent2, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);
  const point = (x) => [x, f(x)], minX = extent2[0], maxX = extent2[1], span = maxX - minX, stop2 = span / maxSteps, prev = [point(minX)], next = [];
  if (minSteps === maxSteps) {
    for (let i2 = 1; i2 < maxSteps; ++i2) {
      prev.push(point(minX + i2 / minSteps * span));
    }
    prev.push(point(maxX));
    return prev;
  } else {
    next.push(point(maxX));
    for (let i2 = minSteps; --i2 > 0; ) {
      next.push(point(minX + i2 / minSteps * span));
    }
  }
  let p0 = prev[0];
  let p1 = next[next.length - 1];
  const sx = 1 / span;
  const sy = scaleY(p0[1], next);
  while (p1) {
    const pm = point((p0[0] + p1[0]) / 2);
    const dx = pm[0] - p0[0] >= stop2;
    if (dx && angleDelta(p0, pm, p1, sx, sy) > MIN_RADIANS) {
      next.push(pm);
    } else {
      p0 = p1;
      prev.push(p1);
      next.pop();
    }
    p1 = next[next.length - 1];
  }
  return prev;
}
function scaleY(init2, points) {
  let ymin = init2;
  let ymax = init2;
  const n2 = points.length;
  for (let i2 = 0; i2 < n2; ++i2) {
    const y = points[i2][1];
    if (y < ymin)
      ymin = y;
    if (y > ymax)
      ymax = y;
  }
  return 1 / (ymax - ymin);
}
function angleDelta(p, q, r, sx, sy) {
  const a0 = Math.atan2(sy * (r[1] - p[1]), sx * (r[0] - p[0])), a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}

// node_modules/erie-web/src/data/audio-graph-data-transform.js
var fromTidy = from;
var escape = escape_default;
var aqTable = table2;
function transformData(data2, transforms, dimensions) {
  let table3 = fromTidy(data2);
  let tableInfo = {};
  if ((transforms == null ? void 0 : transforms.constructor.name) === "Array" && transforms.length > 0) {
    for (const transform of transforms) {
      if (transform.bin) {
        let old_field_name = transform.bin;
        let new_field_name = transform.as || old_field_name + "__bin";
        if (table3.column(new_field_name)) {
          continue;
        }
        let new_field_name2 = transform.end || old_field_name + "__bin_end";
        if (!dimensions.includes(new_field_name))
          dimensions.push(new_field_name);
        if (!dimensions.includes(new_field_name2))
          dimensions.push(new_field_name2);
        let { start, end, nBuckets, equiBin } = createBin(table3.column(old_field_name).data, transform);
        let binned = aqTable({ [new_field_name]: start, [new_field_name2]: end });
        table3 = table3.assign(binned);
        table3 = table3.filter(escape((d) => d[new_field_name] !== void 0 && d[new_field_name2] !== void 0));
        if (!tableInfo.bin)
          tableInfo.bin = {};
        tableInfo.bin[old_field_name] = { nBuckets, equiBin };
      } else if (transform.aggregate) {
        let aggregates = transform.aggregate;
        let groupby = transform.groupby || [];
        if (groupby === Auto) {
          groupby = dimensions.filter((d) => table3.columnNames().includes(d));
        }
        table3 = doAggregate(table3, aggregates, groupby);
        if (!tableInfo.aggregate)
          tableInfo.aggregate = {};
        for (const agg2 of aggregates) {
          let field = agg2.field, method = agg2.op;
          if (method === "count") {
            tableInfo.aggregate["__count"] = { method, groupby };
          } else {
            tableInfo.aggregate[field] = { method, groupby };
          }
        }
      } else if (transform.calculate) {
        let groupby = transform.groupby || {};
        if (groupby === Auto) {
          groupby = dimensions;
        }
        table3 = doCalculate(table3, transform, groupby);
      } else if (transform.fold) {
        table3 = foldTable(table3, transform.fold, transform.by, transform.exclude, transform.as);
      } else if (transform.density) {
        table3 = getKernelDensity(
          table3,
          transform.density,
          transform.groupby,
          transform.cumulative,
          transform.counts,
          transform.bandwidth,
          transform.extent,
          transform.minsteps,
          transform.maxsteps,
          transform.steps,
          transform.as
        );
      } else if (transform.filter) {
        table3 = filterTable(table3, transform.filter);
      }
    }
  }
  let output4 = table3.objects();
  output4.tableInfo = tableInfo;
  return output4;
}
function createBin(col, transform) {
  let is_nice = transform.nice;
  if (is_nice === void 0)
    is_nice = true;
  let maxbins = transform.maxbins || 10;
  let step = transform.step;
  let exact = transform.exact;
  let binFunction = bin(), buckets, binAssigner, equiBin;
  if (is_nice && maxbins && !step) {
    binFunction = binFunction.thresholds(maxbins);
    buckets = binFunction(col);
    equiBin = true;
  } else if (step) {
    maxbins = Math.ceil(extent(col) / step);
    binFunction = binFunction.thresholds(maxbins);
    buckets = binFunction(col);
    equiBin = true;
  } else if (exact) {
    binFunction = binFunction.thresholds(exact);
    buckets = binFunction(col);
    equiBin = false;
  }
  binAssigner = (d) => {
    var _a5;
    let ib = (_a5 = buckets.map((b) => b.includes(d) ? { x0: b.x0, x1: b.x1 } : void 0).filter((b) => b != void 0)) == null ? void 0 : _a5[0];
    return { start: ib == null ? void 0 : ib.x0, end: ib == null ? void 0 : ib.x1 };
  };
  let binned = col.map(binAssigner);
  let start = binned.map((d) => d.start), end = binned.map((d) => d.end);
  return { start, end, nBukcets: buckets.length, equiBin };
}
function doAggregate(table3, aggregates, groupby) {
  let rollups = getRollUps(aggregates);
  return table3.groupby(groupby).rollup(rollups);
}
function getRollUps(aggregates) {
  let rollups = {};
  for (const agg2 of aggregates) {
    let name_as = agg2.as, field = agg2.field, method = agg2.op;
    if (method === "mean" || method === "average") {
      rollups[name_as] = `d => op.mean(d['${field}'])`;
    } else if (method === "valid") {
      rollups[name_as] = `d => op.valid(d['${field}'])`;
    } else if (method === "invalid") {
      rollups[name_as] = `d => op.invalid(d['${field}'])`;
    } else if (method === "max") {
      rollups[name_as] = `d => op.max(d['${field}'])`;
    } else if (method === "min") {
      rollups[name_as] = `d => op.min(d['${field}'])`;
    } else if (method === "distinct") {
      rollups[name_as] = `d => op.distinct(d['${field}'])`;
    } else if (method === "sum") {
      rollups[name_as] = `d => op.sum(d['${field}'])`;
    } else if (method === "product") {
      rollups[name_as] = `d => op.product(d['${field}'])`;
    } else if (method === "mode") {
      rollups[name_as] = `d => op.mode(d['${field}'])`;
    } else if (method === "median") {
      rollups[name_as] = `d => op.median(d['${field}'])`;
    } else if (method === "quantile") {
      let p = agg2.p || 0.5;
      rollups[name_as] = `d => op.quantile(d['${field}'], ${p})`;
    } else if (method === "stdev") {
      rollups[name_as] = `d => op.stdev(d['${field}'])`;
    } else if (method === "stdevp") {
      rollups[name_as] = `d => op.stdevp(d['${field}'])`;
    } else if (method === "variance") {
      rollups[name_as] = `d => op.variance(d['${field}'])`;
    } else if (method === "variancep") {
      rollups[name_as] = `d => op.variancep(d['${field}'])`;
    } else if (method === "count") {
      rollups[name_as] = `d => op.count()`;
    } else if (method === "corr") {
      rollups[name_as] = `d => op.corr(d['${field[0]}'], d['${field[1]}'])`;
    } else if (method === "covariance") {
      rollups[name_as] = `d => op.covariance(d['${field[0]}'], d['${field[1]}'])`;
    } else if (method === "covariancep") {
      rollups[name_as] = `d => op.covariancep(d['${field[0]}'], d['${field[1]}'])`;
    }
  }
  return rollups;
}
function doCalculate(table3, cal, groupby) {
  let eq = cal.calculate, name_as = cal.as;
  eq = eq.replace(/datum\./gi, "d.");
  return table3.groupby(groupby).derive({
    [name_as]: eq
  });
}
function foldTable(table3, fold_fields, by, exclude, new_names) {
  let f = table3.fold(fold_fields);
  if (exclude) {
    f = f.select(by, "key", "value");
  }
  if (new_names) {
    let key2 = new_names[0] || "key";
    let value = new_names[1] || "value";
    f = f.rename({ key: key2, value });
  }
  return f;
}
function orderArray(data2, orders) {
  let outcome, sortFunctions = [];
  for (const ord of orders) {
    let key2 = ord.key, order = ord.order;
    if (ord.order) {
      let sortFn = makeIndexSortFn(key2, order);
      sortFunctions.push(sortFn);
    } else if (ord.sort === "ascending" || ord.sort === true || ord.sort === "asc") {
      let sortFn = makeAscSortFn(key2);
      sortFunctions.push(sortFn);
    } else if (ord.sort === "descending" || ord.sort === "desc") {
      let sortFn = makeDescSortFn(key2);
      sortFunctions.push(sortFn);
    }
  }
  sortFunctions.reverse();
  if (sortFunctions.length > 0) {
    outcome = data2.toSorted((a, b) => {
      for (const fn of sortFunctions) {
        if (fn(a, b) > 0)
          return 1;
        else if (fn(a, b) < 0)
          return -1;
      }
      return 1;
    });
  }
  return outcome || data2;
}
function makeIndexSortFn(key2, order) {
  return (a, b) => {
    let det = order.indexOf(a[key2]) - order.indexOf(b[key2]);
    if (det != 0)
      return det;
    return 0;
  };
}
function makeAscSortFn(key2) {
  return (a, b) => {
    return asc(a[key2], b[key2]);
  };
}
function makeDescSortFn(key2) {
  return (a, b) => {
    return desc(a[key2], b[key2]);
  };
}
function getKernelDensity(table3, field, groupby, cumulative, counts, _bandwidth, _extent, _minsteps, _maxsteps, steps, _as) {
  let method = cumulative ? "cdf" : "pdf";
  _as = _as || ["value", "density"];
  let bandwidth = _bandwidth;
  let values2 = [];
  let domain = _extent;
  let minsteps = steps || _minsteps || 25;
  let maxsteps = steps || _maxsteps || 200;
  if (groupby || (groupby == null ? void 0 : groupby.length) > 0) {
    let { groups, names: names2 } = aqPartition(table3, groupby);
    groups.forEach((group2, i2) => {
      let g = group2.array(field);
      const density = kde(g, bandwidth)[method];
      const scale2 = counts ? g.length : 1;
      const local = domain || extent(g);
      let curve = sampleCurve(density, local, minsteps, maxsteps);
      curve.forEach((v) => {
        const t2 = {
          [_as[0]]: v[0],
          [_as[1]]: v[1] * scale2
        };
        if (groupby) {
          for (let j = 0; j < groupby.length; ++j) {
            t2[groupby[j]] = names2[i2][j];
          }
        }
        values2.push(t2);
      });
    });
    return fromTidy(values2).groupby(groupby);
  } else {
    let g = table3.array(field);
    const density = kde(g, bandwidth)[method];
    const scale2 = counts ? g.length : 1;
    const local = domain || extent(g);
    let curve = sampleCurve(density, local, minsteps, maxsteps);
    curve.forEach((v) => {
      const t2 = {
        [_as[0]]: v[0],
        [_as[1]]: v[1] * scale2
      };
      if (groupby) {
        for (let j = 0; j < groupby.length; ++j) {
          t2[groupby[j]] = names[i][j];
        }
      }
      values2.push(t2);
    });
    return fromTidy(values2);
  }
}
function aqPartition(table3, groupby) {
  let grouped_table = table3.groupby(groupby);
  let group_defs = grouped_table.groups();
  let n_parts = group_defs.size;
  let part_start = group_defs.rows;
  let part_end = part_start.slice(1, n_parts);
  part_end.push(table3.numRows());
  let partitions = grouped_table.partitions();
  let tab_re = grouped_table.objects();
  let groups = [], names2 = [];
  partitions.forEach((p) => {
    let g = fromTidy(tab_re.filter((d, i2) => p.includes(i2)));
    groups.push(g);
    names2.push(groupby.map((gb) => g.get(gb)));
  });
  return { groups, names: names2 };
}
function filterTable(table3, filter) {
  return table3.ungroup().filter(`d => ${filter.replace(/datum\./gi, "d.")}`).reify();
}

// node_modules/erie-web/src/compile/audio-graph-queue-compile.js
async function compileSingleLayerAuidoGraph(audio_spec, _data, config, tickDef, common_scales) {
  var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j2, _k2, _l2, _m2, _n, _o2, _p2, _q2, _r2;
  let layer_spec = {
    name: audio_spec.name,
    encoding: audio_spec.encoding,
    tone: audio_spec.tone || { type: Def_tone }
  };
  let audioFilters = ((_a5 = audio_spec.tone) == null ? void 0 : _a5.filter) || null;
  if (audioFilters)
    audioFilters = [...audioFilters];
  if (!_data || !layer_spec.encoding) {
    console.warn("No proper layer spec provided.");
    return void 0;
  }
  let forced_dimensions = Object.keys(layer_spec.encoding).map((d) => {
    let enc = layer_spec.encoding[d];
    if ([NOM2, ORD2, TMP2].includes(enc.type)) {
      return enc.field;
    } else if (d === REPEAT_chn2) {
      return enc.field;
    } else if (!enc.aggregate) {
      return enc.field;
    }
  }).filter((d) => d).flat();
  let data2;
  if (audio_spec.common_transform) {
    data2 = transformData(_data, [...audio_spec.common_transform || [], ...audio_spec.transform || []], forced_dimensions);
  } else {
    data2 = transformData(_data, audio_spec.transform || [], forced_dimensions);
  }
  let dataInfo = deepcopy2(data2.tableInfo);
  let encoding = layer_spec.encoding;
  let tone_spec = layer_spec.tone;
  if (tone_spec.type === "default") {
    tone_spec = {
      type: "default",
      continued: tone_spec.continued
    };
  }
  let channels = Object.keys(encoding).filter((c) => ![TIME_chn2, TIME2_chn2, TIMBRE_chn2].includes(c));
  let hasTime2 = encoding[TIME_chn2] && encoding[TIME2_chn2];
  let is_repeated = encoding[REPEAT_chn2] !== void 0;
  let has_repeat_speech = is_repeated && encoding[REPEAT_chn2].speech;
  if (has_repeat_speech === void 0)
    has_repeat_speech = true;
  let repeat_field = is_repeated ? encoding[REPEAT_chn2].field : void 0;
  if (repeat_field && jType(repeat_field) !== "Array")
    repeat_field = [repeat_field];
  let repeat_direction = (_b2 = encoding[REPEAT_chn2]) == null ? void 0 : _b2.by;
  if (is_repeated) {
    if (repeat_direction === void 0)
      repeat_direction = SEQUENCE;
    if (jType(repeat_direction) !== "Array")
      repeat_direction = [repeat_direction];
    if (repeat_field.length !== repeat_direction.length) {
      if (repeat_direction.length == 1) {
        repeat_direction = repeat_field.map(() => repeat_direction[0]);
      } else {
        console.error("The repeat direction is not matched with the repeat field(s)");
      }
    }
  }
  let data_order = [];
  if (TIME_chn2 in encoding && ((_c2 = encoding[TIME_chn2].scale) == null ? void 0 : _c2.order)) {
    data_order.push({
      key: encoding[TIME_chn2].field,
      order: [(_d2 = encoding[TIME_chn2].scale) == null ? void 0 : _d2.order]
    });
  } else if (TIME_chn2 in encoding && ((_e2 = encoding[TIME_chn2].scale) == null ? void 0 : _e2.sort)) {
    data_order.push({
      key: encoding[TIME_chn2].field,
      sort: (_f2 = encoding[TIME_chn2].scale) == null ? void 0 : _f2.sort
    });
  } else if (TIME_chn2 in encoding) {
    data_order.push({
      key: encoding[TIME_chn2].field,
      order: unique(data2.map((d) => d[encoding[TIME_chn2].field])).toSorted(asc)
    });
  }
  if (is_repeated && ((_g2 = encoding[REPEAT_chn2].scale) == null ? void 0 : _g2.order)) {
    data_order.push({
      key: repeat_field,
      order: (_h2 = encoding[REPEAT_chn2].scale) == null ? void 0 : _h2.order
    });
  } else if (is_repeated && ((_i = encoding[REPEAT_chn2].scale) == null ? void 0 : _i.sort)) {
    data_order.push({
      key: repeat_field,
      sort: (_j2 = encoding[REPEAT_chn2].scale) == null ? void 0 : _j2.sort
    });
  } else if (is_repeated) {
    repeat_field.toReversed().forEach((key2) => {
      let order = unique(data2.map((d) => d[key2])).toSorted(asc);
      data_order.push({
        key: key2,
        order
      });
    });
  }
  data2 = orderArray(data2, data_order);
  delete data2.tableInfo;
  let audio_graph = [], repeated_graph = [], repeated_graph_map = {}, repeat_values, repeat_level = 0;
  if (is_repeated) {
    repeat_level = repeat_field.length;
    repeat_values = unique(data2.map((d) => repeat_field.map((k) => d[k]).join("_$_"))).map((d) => d.split("_$_"));
    repeat_values.forEach((d) => {
      let g = [];
      g.name = listString(d, ", ", true);
      g.membership = [];
      repeat_field.forEach((f, i2) => {
        g.membership.push({ key: f, value: d[i2] });
      });
      d.membership = g.membership;
      repeated_graph.push(g);
      repeated_graph_map[d.join("&")] = repeated_graph.length - 1;
    });
  }
  let scales = {};
  for (const channel in encoding) {
    let enc = encoding[channel];
    scales[channel] = common_scales[enc.scale.id];
  }
  let relative_stream = encoding[TIME_chn2].scale.timing === REL_TIMING || ((_l2 = (_k2 = scales.time) == null ? void 0 : _k2.properties) == null ? void 0 : _l2.timing) === REL_TIMING;
  let ramp = {};
  for (const channel in encoding) {
    ramp[channel] = encoding[channel].ramp;
  }
  let hasTick = encoding[TIME_chn2].tick !== void 0, tick;
  if (hasTick) {
    let tickItem = encoding[TIME_chn2].tick;
    if (tickItem.name && tickDef[tickItem.name]) {
      tick = tickDef[tickItem.name];
    } else {
      tick = tickItem;
    }
    tick = deepcopy2(tick);
    if (common_scales.__beat) {
      tick.interval = tick.interval ? common_scales.__beat.converter(tick.interval) : Def_Tick_Interval_Beat;
      tick.band = tick.band ? common_scales.__beat.converter(tick.band) : Def_Tick_Duration_Beat;
    } else {
      if (!tick.interval)
        tick.interval = Def_Tick_Interval;
      if (!tick.band)
        tick.band = Def_Tick_Duration;
    }
  }
  if (common_scales) {
    let scaleDescOrder = (config == null ? void 0 : config.scaleDescriptionOrder) || ScaleDescriptionOrder;
    let __config = deepcopy2(config);
    __config.isRepeated = is_repeated;
    __config.repeatField = repeat_field;
    for (const chn of scaleDescOrder) {
      if (scales[chn]) {
        __config.aggregated = encoding[chn].aggregate ? true : false;
        __config.binned = encoding[chn].binned;
        scales[chn].description = makeScaleDescription(scales[chn], encoding[chn], dataInfo, tick, tone_spec, __config, common_scales.__beat);
      }
    }
  }
  for (const i2 in data2) {
    if (i2 === "tableInfo")
      continue;
    let datum = data2[i2];
    let repeat_index = is_repeated && repeated_graph_map[repeat_field.map((k) => datum[k]).join("&")];
    let glyph = scales.time(
      datum[encoding[TIME_chn2].field] !== void 0 ? datum[encoding[TIME_chn2].field] : parseInt(i2),
      hasTime2 ? datum[encoding[TIME2_chn2].field] !== void 0 ? datum[encoding[TIME2_chn2].field] : parseInt(i2) + 1 : void 0
    );
    if (tone_spec.continued && !hasTime2) {
      delete glyph.end;
      glyph.duration = 0;
    }
    if (glyph.start === void 0)
      continue;
    glyph.timbre = scales.timbre ? scales.timbre(datum[encoding[TIMBRE_chn2].field]) : tone_spec.type;
    let speechBefore, speechAfter;
    for (const channel of channels) {
      if (scales[channel]) {
        glyph[channel] = scales[channel](datum[encoding[channel].field]);
      }
      if (TapChannels.includes(channel)) {
        glyph.duration = glyph[channel].totalLength;
      }
    }
    if (glyph[SPEECH_BEFORE_chn2]) {
      speechBefore = {
        speech: glyph[SPEECH_BEFORE_chn2],
        start: glyph.start,
        end: glyph.end,
        language: ((_m2 = encoding[SPEECH_BEFORE_chn2]) == null ? void 0 : _m2.language) ? (_n = encoding[SPEECH_BEFORE_chn2]) == null ? void 0 : _n.language : (_o2 = document == null ? void 0 : document.documentElement) == null ? void 0 : _o2.lang
      };
    }
    if (glyph[SPEECH_AFTER_chn2]) {
      speechAfter = {
        speech: glyph[SPEECH_AFTER_chn2],
        start: glyph.start,
        end: glyph.end,
        language: ((_p2 = encoding[SPEECH_BEFORE_chn2]) == null ? void 0 : _p2.language) ? (_q2 = encoding[SPEECH_BEFORE_chn2]) == null ? void 0 : _q2.language : (_r2 = document == null ? void 0 : document.documentElement) == null ? void 0 : _r2.lang
      };
    }
    if (speechBefore) {
      if (is_repeated)
        repeated_graph[repeat_index].push(speechBefore);
      else
        audio_graph.push(speechBefore);
    }
    glyph.__datum = datum;
    if (is_repeated)
      repeated_graph[repeat_index].push(glyph);
    else
      audio_graph.push(glyph);
    if (speechAfter) {
      if (is_repeated)
        repeated_graph[repeat_index].push(speechAfter);
      else
        audio_graph.push(speechAfter);
    }
  }
  let is_continued = tone_spec.continued === void 0 ? false : tone_spec.continued;
  let instrument_type = tone_spec.type || "default";
  let stream;
  if (is_repeated) {
    let repeat_streams = makeRepeatStreamTree(0, repeat_values, repeat_direction);
    repeated_graph.forEach((g, i2) => {
      let r_stream = new UnitStream(instrument_type, g, scales, { is_continued, relative: relative_stream });
      Object.keys(config || {}).forEach((key2) => {
        r_stream.setConfig(key2, config == null ? void 0 : config[key2]);
      });
      if (g.name)
        r_stream.setName(g.name);
      if (has_repeat_speech)
        r_stream.setConfig("playRepeatSequenceName", true);
      if (i2 > 0) {
        r_stream.setConfig("skipScaleSpeech", true);
        r_stream.setConfig("skipStartSpeech", true);
      }
      if (i2 < repeated_graph.length - 1) {
        r_stream.setConfig("skipFinishSpeech", true);
      }
      if (hasTick) {
        r_stream.setConfig("tick", tick);
      }
      r_stream.setRamp(ramp);
      let rs_accessor = repeat_streams;
      for (let i3 = 0; i3 < repeat_level; i3++) {
        rs_accessor = rs_accessor.nodes;
        let member = g.membership[i3];
        for (let j = 0; j < rs_accessor.length; j++) {
          if (rs_accessor[j].parent_value == member.value) {
            rs_accessor = rs_accessor[j];
            break;
          }
        }
      }
      rs_accessor.node.push(r_stream);
    });
    let processed_repeat_stremas = postprocessRepeatStreams(repeat_streams);
    processed_repeat_stremas.forEach((s, i2) => {
      if (!s) {
        console.warn("empty repeat stream", s);
      }
      if (has_repeat_speech && s.setConfig)
        s.setConfig("playRepeatSequenceName", true);
      if (i2 > 0) {
        s.setConfig("skipScaleSpeech", true);
        s.setConfig("skipStartSpeech", true);
      } else {
        s.setConfig(PlayAt, BeforeAll);
      }
      if (i2 < processed_repeat_stremas.length - 1) {
        s.setConfig("skipFinishSpeech", true);
      }
      if (hasTick) {
        s.setConfig("tick", tick);
      }
      if (jType(s) === OverlayStream.name) {
        Object.assign(s.config, s.overlays[0].config);
        s.overlays.forEach((o, i3) => {
          if (o.setConfig) {
            o.setConfig("playRepeatSequenceName", false);
            if (i3 == 0) {
              o.setConfig("skipScaleSpeech", false);
              o.setConfig("skipStartSpeech", false);
            } else {
              o.setConfig("skipScaleSpeech", true);
              o.setConfig("skipStartSpeech", true);
            }
            o.setConfig("skipFinishSpeech", true);
          }
        });
        if (s.setConfig) {
          s.setConfig("skipScaleSpeech", true);
          s.setConfig("skipTitle", true);
          s.setConfig("skipStartSpeech", true);
          s.setConfig("playRepeatSequenceName", true);
        }
        s.setName(listString(s.overlays.map((d) => d.name), ", ", true));
      }
      if (audioFilters)
        s.setFilters(audioFilters);
    });
    stream = processed_repeat_stremas;
  } else {
    stream = new UnitStream(instrument_type, audio_graph, scales, { is_continued, relative: relative_stream });
    Object.keys(config || {}).forEach((key2) => {
      stream.setConfig(key2, config == null ? void 0 : config[key2]);
    });
    if (hasTick) {
      stream.setConfig("tick", tick);
    }
    if (layer_spec.name)
      stream.setName(layer_spec.name);
    if (audioFilters)
      stream.setFilters(audioFilters);
    stream.setRamp(ramp);
    if (audio_spec.description)
      stream.setDescription(audio_spec.description);
  }
  return { stream, scales };
}

// node_modules/erie-web/src/data/audio-graph-data-import.js
async function getDataWrap(dataDef, loaded_datasets, datasets) {
  let data2;
  if (dataDef.values) {
    return deepcopy2(dataDef.values);
  } else if (dataDef.name) {
    if (!loaded_datasets[dataDef.name]) {
      loaded_datasets[dataDef.name] = await getData(datasets[dataDef.name]);
    }
    data2 = deepcopy2(loaded_datasets[dataDef.name]);
  } else {
    data2 = await getData(dataDef.name);
  }
  return data2;
}
async function getData(data_spec) {
  if (data_spec == null ? void 0 : data_spec.values) {
    return data_spec.values;
  } else if (data_spec == null ? void 0 : data_spec.csv) {
    return csvParse(data_spec == null ? void 0 : data_spec.csv);
  } else if (data_spec == null ? void 0 : data_spec.tsv) {
    return tsvParse(data_spec.tsv);
  } else if (data_spec == null ? void 0 : data_spec.url) {
    let read = await (await fetch(data_spec.url)).text();
    if (isJSON(read)) {
      return JSON.parse(read);
    } else if (isCSV(read)) {
      return csvParse(read);
    } else if (isTSV(read)) {
      return tsvParse(read);
    }
  } else {
    console.error("wrong data format provided");
    return [];
  }
}

// node_modules/erie-web/src/data/audio-graph-apply-transform.js
function applyTransforms(data2, spec) {
  let forced_dimensions = Object.keys(spec.encoding).map((d) => {
    let enc = spec.encoding[d];
    if ([NOM2, ORD2, TMP2].includes(enc.type)) {
      return enc.field;
    } else if (d === REPEAT_chn2) {
      return enc.field;
    } else if (!enc.aggregate) {
      return enc.field;
    }
  }).filter((d) => d);
  data2 = transformData(data2, [...spec.common_transform || [], ...spec.transform || []], unique(forced_dimensions));
  return data2;
}

// node_modules/erie-web/src/scale/audio-graph-palletes.js
var QuantPreferredRange2 = {
  [TIME_chn2]: [0, 5],
  [PITCH_chn2]: [200, 1e3],
  [LOUDNESS_chn2]: [0, 1],
  [PAN_chn2]: [-1, 1],
  [DUR_chn2]: [0, 1.5],
  [POST_REVERB_chn2]: [0, 2],
  [TAPCNT_chn2]: [0, 20],
  [TAPSPD_chn2]: [0, 5]
};
var NomPalletes = {
  [PITCH_chn2]: [
    "C3",
    "C4",
    "C5",
    "C6",
    "G3",
    "G4",
    "G5",
    "G6",
    "D3",
    "D4",
    "D5",
    "D6",
    "A3",
    "A4",
    "A5",
    "A6",
    "E3",
    "E4",
    "E5",
    "E6",
    "B3",
    "B4",
    "B5",
    "B6",
    "F3",
    "F4",
    "F5",
    "F6"
  ].map(noteToFreq2),
  [LOUDNESS_chn2]: [
    1,
    0.8,
    0.6,
    0.4,
    0.2,
    0.9,
    0.7,
    0.5,
    0.1
  ],
  [DUR_chn2]: [1, 0.5, 1.5, 2, 1.3, 0.8, 0.3],
  [POST_REVERB_chn2]: [1, 0.5, 1.5, 2, 1.3, 0.8, 0.3],
  [TAPCNT_chn2]: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20],
  [TAPSPD_chn2]: [1, 2, 3, 4],
  [TIMBRE_chn2]: ["piano", "pianoElec", "violin", "metal", "guitar", "hithat", "snare", "highKick", "lowKick", "clap"]
};
function repeatPallete(pallete, len) {
  let pLen = pallete == null ? void 0 : pallete.length;
  if (pLen >= len) {
    return pallete.slice(0, len);
  } else {
    let repeats = Math.floor(pLen / len);
    let remains = len - repeats * pLen;
    let output4 = [];
    for (let i2 = 0; i2 < repeats; i2++) {
      output4.push(...pallete);
    }
    output4.push(...pallete.slice(0, remains));
    return output4;
  }
}

// node_modules/erie-web/src/scale/audio-graph-scale-nom.js
function makeNominalScaleFunction(channel, encoding, values2, info) {
  var _a5, _b2, _c2, _d2, _e2;
  let { polarity, maxDistinct, times, zero, domainMax, domainMin, nice } = info;
  let extraChannelType = (_a5 = FilterExtraChannelTypes[channel]) == null ? void 0 : _a5.type;
  const CHN_CAP_MAX = ((_b2 = ChannelCaps[channel]) == null ? void 0 : _b2.max) || ((_c2 = ChannelCaps[extraChannelType]) == null ? void 0 : _c2.max), CHN_CAP_MIN = ((_d2 = ChannelCaps[channel]) == null ? void 0 : _d2.min) || ((_e2 = ChannelCaps[extraChannelType]) == null ? void 0 : _e2.min);
  let scaleDef = encoding == null ? void 0 : encoding.scale;
  let scaleProperties = {
    channel
  };
  let domain = deepcopy2((scaleDef == null ? void 0 : scaleDef.domain) || null);
  if (!domain) {
    domain = unique(values2);
  }
  scaleProperties.domain = domain;
  let range2 = deepcopy2((scaleDef == null ? void 0 : scaleDef.range) || null);
  let rangeProvided = (scaleDef == null ? void 0 : scaleDef.range) !== void 0;
  if (times && !rangeProvided) {
    range2 = domain.map((d) => d * times);
    scale.properties.times = times;
  }
  if (!rangeProvided && channel !== REPEAT_chn2) {
    range2 = repeatPallete(NomPalletes[channel] || NomPalletes[extraChannelType], domain.length);
  } else if (channel === REPEAT_chn2) {
    range2 = domain.map((d, i2) => i2);
  } else {
    scaleProperties.rangeProvided = rangeProvided;
  }
  if ((channel === PITCH_chn2 || extraChannelType === PITCH_chn2) && !range2.every((d) => jType(d) === "Number")) {
    range2 = range2.map(noteToFreq2);
  }
  range2 = range2.map((d, i2) => {
    if (channel === TIMBRE_chn2 || extraChannelType === TIMBRE_chn2) {
      return d;
    } else {
      if (d < CHN_CAP_MIN) {
        console.warn(`The range value of ${d} is less than the possible ${channel} value ${CHN_CAP_MIN}. The scale is capped to the minimum possible value.`);
        return CHN_CAP_MIN;
      } else if (d > CHN_CAP_MAX) {
        console.warn(`The range value of ${d} is greater than the possible ${channel} value ${CHN_CAP_MAX}. The scale is capped to the maximum possible value.`);
        return CHN_CAP_MAX;
      } else {
        return d;
      }
    }
  });
  scaleProperties.range = range2;
  let scaleFunction = ordinal().domain(domain).range(range2);
  scaleFunction.properties = scaleProperties;
  return scaleFunction;
}

// node_modules/erie-web/src/scale/audio-graph-scale-ord.js
function makeOrdinalScaleFunction(channel, encoding, values2, info) {
  var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i;
  let { polarity, maxDistinct, times, zero, domainMax, domainMin, nice } = info;
  let extraChannelType = (_a5 = FilterExtraChannelTypes[channel]) == null ? void 0 : _a5.type;
  const CHN_MAX = ((_b2 = ChannelThresholds[channel]) == null ? void 0 : _b2.max) || ((_c2 = ChannelThresholds[extraChannelType]) == null ? void 0 : _c2.max), CHN_MIN = ((_d2 = ChannelThresholds[channel]) == null ? void 0 : _d2.min) || ((_e2 = ChannelThresholds[extraChannelType]) == null ? void 0 : _e2.min);
  const CHN_CAP_MAX = ((_f2 = ChannelCaps[channel]) == null ? void 0 : _f2.max) || ((_g2 = ChannelCaps[extraChannelType]) == null ? void 0 : _g2.max), CHN_CAP_MIN = ((_h2 = ChannelCaps[channel]) == null ? void 0 : _h2.min) || ((_i = ChannelCaps[extraChannelType]) == null ? void 0 : _i.min);
  let scaleDef = encoding == null ? void 0 : encoding.scale;
  let scaleProperties = {
    channel,
    polarity
  };
  let sort = encoding.sort;
  let sortFunction;
  if (sort === "descending" || sort === "desc") {
    sortFunction = descending;
    scaleProperties.sort = "descending";
  } else {
    sortFunction = ascending;
    scaleProperties.sort = "ascending";
  }
  let domain = deepcopy2((scaleDef == null ? void 0 : scaleDef.domain) || null);
  if (!domain) {
    domain = unique(values2).toSorted(sortFunction);
  }
  scaleProperties.domain = domain;
  let range2 = deepcopy2((scaleDef == null ? void 0 : scaleDef.range) || null);
  let rangeProvided = (scaleDef == null ? void 0 : scaleDef.range) !== void 0;
  if (times && !rangeProvided) {
    range2 = domain.map((d) => d * times);
    rangeProvided = true;
    scaleProperties.times = times;
  }
  let rangeMin = scaleDef == null ? void 0 : scaleDef.rangeMin, rangeMax = scaleDef == null ? void 0 : scaleDef.rangeMax;
  if (channel === TIMBRE_chn2 || extraChannelType === TIMBRE_chn2) {
    range2 = repeatPallete(NomPalletes[TIMBRE_chn2], domain.length);
    rangeProvided = true;
  }
  let scaleOutRange;
  if (!rangeProvided && maxDistinct) {
    scaleOutRange = [rangeMin !== void 0 ? rangeMin : CHN_MIN, rangeMax !== void 0 ? rangeMax : CHN_MAX];
  } else if (!rangeProvided && !maxDistinct) {
    let p = QuantPreferredRange[channel];
    scaleOutRange = [firstDefined(rangeMin, p[0], CHN_MIN), firstDefined(rangeMax, p[1], CHN_MAX)];
  }
  if (scaleOutRange && !rangeProvided) {
    range2 = divideOrdScale(scaleOutRange, domain.length);
  }
  if ((channel === PITCH_chn2 || extraChannelType === PITCH_chn2) && !range2.every((d) => jType(d) === "Number")) {
    range2 = range2.map(noteToFreq);
  }
  range2 = range2.map((d, i2) => {
    if (channel === TIMBRE_chn2 || extraChannelType === TIMBRE_chn2) {
      return d;
    } else {
      if (d < CHN_CAP_MIN) {
        console.warn(`The range value of ${d} is less than the possible ${channel} value ${CHN_CAP_MIN}. The scale is capped to the minimum possible value.`);
        return CHN_CAP_MIN;
      } else if (d > CHN_CAP_MAX) {
        console.warn(`The range value of ${d} is greater than the possible ${channel} value ${CHN_CAP_MAX}. The scale is capped to the maximum possible value.`);
        return CHN_CAP_MAX;
      } else {
        return d;
      }
    }
  });
  if (!rangeProvided) {
    if (domain[0] < domain[1] && polarity === NEG2) {
      range2 = range2.reverse();
    } else if (domain[0] > domain[1] && polarity === POS) {
      range2 = range2.reverse();
    }
  }
  scaleProperties.range = range2;
  let scaleFunction = ordinal().domain(domain).range(range2);
  scaleFunction.properties = scaleProperties;
  return scaleFunction;
}
function divideOrdScale(biRange, len) {
  if (len < 1)
    return [];
  else if (len == 1)
    return (biRange[0] + biRange[1]) / 2;
  let rLen = len;
  let max = biRange[1];
  let min = biRange[0];
  if (min != 0)
    rLen = len - 1;
  let gap = (max - min) / rLen;
  let o = [];
  for (let j = min; j <= max; j += gap) {
    o.push(j);
  }
  return o.slice(len == rLen ? 1 : 0, rLen + 1);
}

// node_modules/erie-web/src/scale/audio-graph-scale-quant.js
function makeQuantitativeScaleFunction(channel, encoding, values2, info) {
  var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j2;
  let { polarity, maxDistinct, times, zero, domainMax, domainMin, nice } = info;
  let extraChannelType = (_a5 = FilterExtraChannelTypes[channel]) == null ? void 0 : _a5.type;
  const CHN_MAX = ((_b2 = ChannelThresholds[channel]) == null ? void 0 : _b2.max) || ((_c2 = ChannelThresholds[extraChannelType]) == null ? void 0 : _c2.max), CHN_MIN = ((_d2 = ChannelThresholds[channel]) == null ? void 0 : _d2.min) || ((_e2 = ChannelThresholds[extraChannelType]) == null ? void 0 : _e2.min);
  const CHN_CAP_MAX = ((_f2 = ChannelCaps[channel]) == null ? void 0 : _f2.max) || ((_g2 = ChannelCaps[extraChannelType]) == null ? void 0 : _g2.max), CHN_CAP_MIN = ((_h2 = ChannelCaps[channel]) == null ? void 0 : _h2.min) || ((_i = ChannelCaps[extraChannelType]) == null ? void 0 : _i.min);
  let scaleDef = encoding == null ? void 0 : encoding.scale;
  let scaleProperties = {
    channel,
    polarity
  };
  if (channel === TIMBRE_chn2 || extraChannelType === TIMBRE_chn2) {
    console.error("Timber channel can't be quantitatively scaled.");
    return;
  }
  let domain = deepcopy2((scaleDef == null ? void 0 : scaleDef.domain) || null), domainSpecified = false;
  if ((encoding == null ? void 0 : encoding.domainMin) !== void 0 || (encoding == null ? void 0 : encoding.domainMax) !== void 0 || (encoding == null ? void 0 : encoding.domainMid) !== void 0) {
    domain = [
      (encoding == null ? void 0 : encoding.domainMin) !== void 0 ? encoding == null ? void 0 : encoding.domainMin : domainMin,
      (encoding == null ? void 0 : encoding.domainMax) !== void 0 ? encoding == null ? void 0 : encoding.domainMax : domainMax
    ];
    if (channel === "pan" && (scaleDef == null ? void 0 : scaleDef.domainMid) !== void 0) {
      domain.splice(1, 0, scaleDef == null ? void 0 : scaleDef.domainMid);
      domainSpecified = [(encoding == null ? void 0 : encoding.domainMin) !== void 0, (encoding == null ? void 0 : encoding.domainMid) !== void 0, (encoding == null ? void 0 : encoding.domainMax) !== void 0];
    } else {
      domainSpecified = [(encoding == null ? void 0 : encoding.domainMin) !== void 0, (encoding == null ? void 0 : encoding.domainMax) !== void 0];
    }
  } else if (!domain) {
    domain = [domainMin, domainMax];
    if (zero)
      domain = [0, domainMax];
    domainSpecified = false;
  } else {
    domainSpecified = true;
  }
  scaleProperties.domain = domain;
  scaleProperties.domainSpecified = domainSpecified;
  let range2 = deepcopy2((scaleDef == null ? void 0 : scaleDef.range) || null);
  let rangeProvided = (scaleDef == null ? void 0 : scaleDef.range) !== void 0;
  if (times && !rangeProvided) {
    range2 = domain.map((d) => d * times);
    rangeProvided = true;
  }
  let rangeMin = scaleDef == null ? void 0 : scaleDef.rangeMin, rangeMax = scaleDef == null ? void 0 : scaleDef.rangeMax;
  if (!rangeProvided && maxDistinct) {
    range2 = [rangeMin !== void 0 ? rangeMin : CHN_MIN, rangeMax !== void 0 ? rangeMax : CHN_MAX];
  } else if (!rangeProvided && !maxDistinct) {
    let p = QuantPreferredRange2[channel] || QuantPreferredRange2[extraChannelType];
    range2 = [firstDefined(rangeMin, p[0], CHN_MIN), firstDefined(rangeMax, p[1], CHN_MAX)];
  }
  if ((channel === PAN_chn2 || extraChannelType === PAN_chn2) && !rangeProvided && domain.length == 3) {
    range2.splice(1, 0, 0);
  }
  if ((channel === PITCH_chn2 || extraChannelType === PITCH_chn2) && !range2.every((d) => jType(d) === "Number")) {
    range2 = range2.map(noteToFreq2);
  }
  range2 = range2.map((d) => {
    if (d < CHN_CAP_MIN) {
      console.warn(`The range value of ${d} is less than the possible ${channel} value ${CHN_CAP_MIN}. The scale is capped to the minimum possible value.`);
      return CHN_CAP_MIN;
    } else if (d > CHN_CAP_MAX) {
      console.warn(`The range value of ${d} is greater than the possible ${channel} value ${CHN_CAP_MAX}. The scale is capped to the maximum possible value.`);
      return CHN_CAP_MAX;
    } else {
      return d;
    }
  });
  if (domain[0] < domain[1] && polarity === NEG2) {
    range2 = range2.reverse();
  } else if (domain[0] > domain[1] && polarity === POS3) {
    range2 = range2.reverse();
  }
  scaleProperties.range = range2;
  if (!((_j2 = encoding == null ? void 0 : encoding.scale) == null ? void 0 : _j2.domain) && domain.length == 2 && rangeProvided && domain.length < range2.length) {
    console.warn(`The domain is not provided while the range is provided. Erie fixed domain to match with the range. This fix is linear, so if you are using other scale types, make sure to provide the specific domain cuts.`);
    domain = range2.map((d, i2) => {
      if (i2 == 0)
        return domainMin;
      else if (i2 == range2.length - 1)
        return domainMax;
      else {
        return domainMin + (domainMax - domainMin) * (i2 / (range2.length - 1));
      }
    });
  }
  let scaleFunction;
  let scaleTransformType = scaleDef == null ? void 0 : scaleDef.type;
  if (scaleTransformType === LOG) {
    if ((scaleDef == null ? void 0 : scaleDef.base) == 0) {
      console.warn(`The log base can't be 0. It is converted to 10.`);
    }
    let base = (scaleDef == null ? void 0 : scaleDef.base) || 10;
    scaleFunction = log().base(base);
  } else if (scaleTransformType === SYMLOG) {
    let constant = (scaleDef == null ? void 0 : scaleDef.constant) || 1;
    scaleFunction = symlog().constant(constant);
  } else if (scaleTransformType === SQRT) {
    scaleFunction = sqrt();
  } else if (scaleTransformType === POW) {
    let exp = (scaleDef == null ? void 0 : scaleDef.exponent) !== void 0 ? scaleDef.exponent : 2;
    scaleFunction = pow().exponent(exp);
  } else {
    scaleFunction = linear();
  }
  scaleProperties.scaleType = scaleTransformType || "linear";
  scaleFunction = scaleFunction.domain(domain);
  if (nice)
    scaleFunction = scaleFunction.nice();
  scaleFunction = scaleFunction.range(range2);
  scaleFunction.properties = scaleProperties;
  window["scale_" + channel] = scaleFunction;
  return scaleFunction;
}

// node_modules/erie-web/src/scale/audio-graph-scale-speech.js
function makeSpeechChannelScale(channel, encoding, values2, info) {
  let scale2, scaleProperties = {
    channel
  };
  if (encoding.format) {
    let formatFun = format(encoding.format);
    if (formatFun) {
      scale2 = (d) => formatFun(d);
    } else {
      scale2 = (d) => nullToNull(d);
    }
  } else {
    scale2 = (d) => nullToNull(d);
  }
  scale2.properties = scaleProperties;
  return scale2;
}
function nullToNull(d) {
  if (d === null || d === void 0)
    return "null";
  else
    return d;
}

// node_modules/erie-web/src/scale/audio-graph-scale-static.js
function makeStaticScaleFunction(channel, encoding, values2, info) {
  var _a5;
  let value = encoding.value;
  let condition = deepcopy2(encoding.condition || []);
  let scaleProperties = {
    channel
  };
  if (condition) {
    let conditions = [];
    if (condition.constructor.name === "Object") {
      conditions.push(condition);
    } else {
      conditions.push(...condition);
    }
    conditions = conditions.filter((cond) => cond.test !== void 0);
    let finalConditions = [];
    scaleProperties.conditions = [];
    for (const cond of conditions) {
      let fCond;
      if (cond.test !== void 0) {
        let test2 = cond.test;
        fCond = {};
        if ((test2 == null ? void 0 : test2.constructor.name) === "Array") {
          fCond.test = (d) => {
            return test2.includes(d);
          };
        } else if (((_a5 = test2 == null ? void 0 : test2.not) == null ? void 0 : _a5.constructor.name) === "Array") {
          fCond.test = (d) => {
            return !test2.not.includes(d);
          };
        } else {
          fCond.test = makeParamFilter(test2);
        }
      }
      if (fCond !== void 0) {
        fCond.value = cond.value;
        finalConditions.push(fCond);
      }
      scaleProperties.conditions.push([test, cond.value]);
    }
    let scale2 = (d) => {
      let output4;
      for (const fCond of finalConditions) {
        output4 = fCond.test(d) ? fCond.value : output4;
      }
      if (output4 === void 0)
        output4 = value;
      return output4;
    };
    scale2.properties = scaleProperties;
    return scale2;
  } else {
    let scale2 = (d) => {
      return value;
    };
    scale2.properties = scaleProperties;
    return scale2;
  }
}

// node_modules/erie-web/src/scale/audio-graph-scale-temp.js
function makeTemporalScaleFunction(channel, encoding, _values, info) {
  var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i;
  let { polarity, maxDistinct, times, zero, domainMax, domainMin, nice } = info;
  let extraChannelType = (_a5 = FilterExtraChannelTypes[channel]) == null ? void 0 : _a5.type;
  const CHN_MAX = ((_b2 = ChannelThresholds[channel]) == null ? void 0 : _b2.max) || ((_c2 = ChannelThresholds[extraChannelType]) == null ? void 0 : _c2.max), CHN_MIN = ((_d2 = ChannelThresholds[channel]) == null ? void 0 : _d2.min) || ((_e2 = ChannelThresholds[extraChannelType]) == null ? void 0 : _e2.min);
  const CHN_CAP_MAX = ((_f2 = ChannelCaps[channel]) == null ? void 0 : _f2.max) || ((_g2 = ChannelCaps[extraChannelType]) == null ? void 0 : _g2.max), CHN_CAP_MIN = ((_h2 = ChannelCaps[channel]) == null ? void 0 : _h2.min) || ((_i = ChannelCaps[extraChannelType]) == null ? void 0 : _i.min);
  let scaleDef = encoding == null ? void 0 : encoding.scale;
  let scaleProperties = {
    channel,
    polarity
  };
  if (channel === TIMBRE_chn2 || extraChannelType === TIMBRE_chn2) {
    console.error("Timber channel can't be scaled for a temporal encoding.");
    return;
  }
  if (encoding == null ? void 0 : encoding.timeUnit) {
    let ordScale = makeOrdinalScaleFunction(channel, {
      domain: timeUnitDomain(scaleDef == null ? void 0 : scaleDef.domain, encoding == null ? void 0 : encoding.timeUnit, encoding == null ? void 0 : encoding.dayName),
      range: scaleDef.range,
      polarity,
      maxDistinct,
      nice
    }, _values, info);
    let timeUnitFunction = makeTimeUnitFunction(encoding == null ? void 0 : encoding.timeUnit, encoding == null ? void 0 : encoding.dayName);
    Object.assign(scaleProperties, ordScale.properties);
    scaleProperties.timeUnit = encoding == null ? void 0 : encoding.timeUnit;
    scaleProperties.dayName = deepcopy2(encoding == null ? void 0 : encoding.dayName);
    let scaleFunction2 = (d) => {
      return ordScale(timeUnitFunction(d));
    };
    scaleFunction2.properties = scaleProperties;
    return scaleFunction2;
  }
  let timeLevelFunction = makeTimeLevelFunction(encoding == null ? void 0 : encoding.timeLevel);
  scaleProperties.timeLevel = encoding == null ? void 0 : encoding.timeLevel;
  let domain, domainSpecified;
  if (scaleDef == null ? void 0 : scaleDef.domain) {
    domain = deepcopy2(scaleDef == null ? void 0 : scaleDef.domain).map((d) => {
      return timeLevelFunction(d);
    });
  }
  if ((encoding == null ? void 0 : encoding.domainMin) !== void 0 || (encoding == null ? void 0 : encoding.domainMax) !== void 0 || (encoding == null ? void 0 : encoding.domainMid) !== void 0) {
    domain = [
      timeLevelFunction((encoding == null ? void 0 : encoding.domainMin) !== void 0 ? encoding == null ? void 0 : encoding.domainMin : domainMin),
      timeLevelFunction((encoding == null ? void 0 : encoding.domainMax) !== void 0 ? encoding == null ? void 0 : encoding.domainMax : domainMax)
    ];
    if ((channel === PAN_chn2 || extraChannelType === PAN_chn2) && (scaleDef == null ? void 0 : scaleDef.domainMid) !== void 0) {
      domain.splice(1, 0, timeLevelFunction(scaleDef == null ? void 0 : scaleDef.domainMid));
      domainSpecified = [(encoding == null ? void 0 : encoding.domainMin) !== void 0, (encoding == null ? void 0 : encoding.domainMid) !== void 0, (encoding == null ? void 0 : encoding.domainMax) !== void 0];
    } else {
      domainSpecified = [(encoding == null ? void 0 : encoding.domainMin) !== void 0, (encoding == null ? void 0 : encoding.domainMax) !== void 0];
    }
  } else if (!domain) {
    domain = [timeLevelFunction(domainMin), timeLevelFunction(domainMax)];
    domainSpecified = false;
  } else {
    domainSpecified = true;
  }
  scaleProperties.domain = encoding == null ? void 0 : encoding.domain;
  scaleProperties.domainSpecified = domainSpecified;
  let range2 = deepcopy2((scaleDef == null ? void 0 : scaleDef.range) || null);
  let rangeProvided = (scaleDef == null ? void 0 : scaleDef.range) !== void 0;
  if (times && !rangeProvided) {
    range2 = domain.map((d) => d * times);
    rangeProvided = true;
  }
  let rangeMin = scaleDef == null ? void 0 : scaleDef.rangeMin, rangeMax = scaleDef == null ? void 0 : scaleDef.rangeMax;
  if (!rangeProvided && maxDistinct) {
    range2 = [rangeMin !== void 0 ? rangeMin : CHN_MIN, rangeMax !== void 0 ? rangeMax : CHN_MAX];
  } else if (!rangeProvided && !maxDistinct) {
    let p = QuantPreferredRange2[channel] || QuantPreferredRange2[extraChannelType];
    range2 = [firstDefined(rangeMin, p[0], CHN_MIN), firstDefined(rangeMax, p[1], CHN_MAX)];
  }
  if ((channel === PAN_chn2 || extraChannelType === PAN_chn2) && !rangeProvided && domain.length == 3) {
    range2.splice(1, 0, 0);
  }
  if ((channel === PITCH_chn2 || extraChannelType === PITCH_chn2) && !range2.every((d) => jType(d) === "Number")) {
    range2 = range2.map(noteToFreq2);
  }
  range2 = range2.map((d) => {
    if (d < CHN_CAP_MIN) {
      console.warn(`The range value of ${d} is less than the possible ${channel} value ${CHN_CAP_MIN}. The scale is capped to the minimum possible value.`);
      return CHN_CAP_MIN;
    } else if (d > CHN_CAP_MAX) {
      console.warn(`The range value of ${d} is greater than the possible ${channel} value ${CHN_CAP_MAX}. The scale is capped to the maximum possible value.`);
      return CHN_CAP_MAX;
    } else {
      return d;
    }
  });
  if (!rangeProvided) {
    if (domain[0] < domain[1] && polarity === NEG2) {
      range2 = range2.reverse();
    } else if (domain[0] > domain[1] && polarity === POS3) {
      range2 = range2.reverse();
    }
  }
  scaleProperties.range = encoding == null ? void 0 : encoding.range;
  let scaleFunction = time().domain(domain).range(range2);
  let finalScaleFunction = (d) => {
    return scaleFunction(timeLevelFunction(d));
  };
  finalScaleFunction.properties = scaleProperties;
  return finalScaleFunction;
}
function makeTimeLevelFunction(timeLevel) {
  if (!timeLevel)
    return (d) => {
      return new Date(d);
    };
  else {
    if (timeLevel === "year") {
      return (d) => {
        let dt = new Date(d);
        return new Date(dt.getFullYear(), 0, 0, 0, 0, 0, 0);
      };
    } else if (timeLevel === "month") {
      return (d) => {
        let dt = new Date(d);
        return new Date(dt.getFullYear(), dt.getMonth(), 0, 0, 0, 0, 0);
      };
    } else if (timeLevel === "date") {
      return (d) => {
        let dt = new Date(d);
        return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), 0, 0, 0, 0);
      };
    } else if (timeLevel === "hour") {
      return (d) => {
        let dt = new Date(d);
        return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), 0, 0, 0);
      };
    } else if (timeLevel === "minute") {
      return (d) => {
        let dt = new Date(d);
        return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes(), 0, 0);
      };
    } else if (timeLevel === "second") {
      return (d) => {
        let dt = new Date(d);
        return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes(), dt.getSeconds(), 0);
      };
    } else if (timeLevel === "millisecond") {
      return (d) => {
        let dt = new Date(d);
        return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes(), dt.getSeconds(), dt.getMilliseconds());
      };
    } else {
      return (d) => {
        return new Date(d);
      };
    }
  }
}
function makeTimeUnitFunction(timeUnit, names2) {
  if (!timeUnit)
    return (d) => {
      return new Date(d);
    };
  else {
    if (timeUnit === "year") {
      return (d) => {
        return new Date(d).getFullYear();
      };
    } else if (timeUnit === "month") {
      names2 = names2 || "number";
      if (names2 == "number")
        names2 = timeUnitDomainDefs.monthNumber;
      else if (names2 == "number1")
        names2 = timeUnitDomainDefs.monthNumber1;
      else if (names2 == "short")
        names2 = timeUnitDomainDefs.monthShort;
      else if (names2 == "long")
        names2 = timeUnitDomainDefs.month;
      return (d) => {
        return names2[new Date(d).getMonth()];
      };
    } else if (timeUnit === "day") {
      names2 = names2 || timeUnitDomainDefs.dayLong;
      if (names2 == "number")
        names2 = timeUnitDomainDefs.dayNumber;
      else if (names2 == "number1")
        names2 = timeUnitDomainDefs.dayNumber1;
      else if (names2 == "numberFromMon")
        names2 = timeUnitDomainDefs.dayNumberFromMon;
      else if (names2 == "numberFromMon1")
        names2 = timeUnitDomainDefs.dayNumberFromMon1;
      else if (names2 == "short")
        names2 = timeUnitDomainDefs.dayShort;
      return (d) => {
        return names2[new Date(d).getDay()];
      };
    } else if (timeUnit === "date") {
      return (d) => {
        return new Date(d).getDate();
      };
    } else if (timeUnit === "hour") {
      return (d) => {
        return new Date(d).getHours();
      };
    } else if (timeUnit === "hour12") {
      return (d) => {
        return new Date(d).getHours() % 12;
      };
    } else if (timeUnit === "minute") {
      return (d) => {
        return new Date(d).getMinutes();
      };
    } else if (timeUnit === "second") {
      return (d) => {
        return new Date(d).getSeconds();
      };
    } else if (timeUnit === "millisecond") {
      return (d) => {
        return new Date(d).getMilliseconds();
      };
    } else {
      return (d) => {
        return new Date(d);
      };
    }
  }
}
function timeUnitDomain(orgDomain, timeUnit, names2) {
  if (timeUnit === "year") {
    return [new Date(orgDomain[0]).getDay(), new Date(orgDomain[1]).getDay()];
  } else if (timeUnit === "month") {
    names2 = names2 || "number";
    if (names2 == "number")
      names2 = timeUnitDomainDefs.monthNumber;
    else if (names2 == "number1")
      names2 = timeUnitDomainDefs.monthNumber1;
    else if (names2 == "short")
      names2 = timeUnitDomainDefs.monthShort;
    else if (names2 == "long")
      names2 = timeUnitDomainDefs.month;
    return names2;
  } else if (timeUnit === "day") {
    names2 = names2 || timeUnitDomainDefs.dayLong;
    if (names2 == "number")
      names2 = timeUnitDomainDefs.dayNumber;
    else if (names2 == "number1")
      names2 = timeUnitDomainDefs.dayNumber1;
    else if (names2 == "numberFromMon")
      names2 = timeUnitDomainDefs.dayNumberFromMon;
    else if (names2 == "numberFromMon1")
      names2 = timeUnitDomainDefs.dayNumberFromMon1;
    else if (names2 == "short")
      names2 = timeUnitDomainDefs.dayShort;
    return names2;
  } else if (timeUnit === "date") {
    return timeUnitDomainDefs.date;
  } else if (timeUnit === "hour") {
    return timeUnitDomainDefs.hour;
  } else if (timeUnit === "hour12") {
    return timeUnitDomainDefs.hour;
  } else if (timeUnit === "minute") {
    return timeUnitDomainDefs.minute;
  } else if (timeUnit === "second") {
    return timeUnitDomainDefs.second;
  } else if (timeUnit === "millisecond") {
    return timeUnitDomainDefs.millisecond;
  }
}
var timeUnitDomainDefs = {
  monthNumber: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  monthNumber1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
  monthShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  monthLong: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  dayNumber: [0, 1, 2, 3, 4, 5, 6],
  dayNumber1: [1, 2, 3, 4, 5, 6, 7],
  dayNumberFromMon: [6, 0, 1, 2, 3, 4, 5],
  dayNumberFromMon1: [7, 1, 2, 3, 4, 5, 6],
  dayLong: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  dayShort: ["Sun", "Mon", "Tues", "Wed", "Thur", "Fri", "Sat"],
  date: aRange(0, 31, true),
  hour: aRange(0, 24, false),
  hour12: aRange(0, 12, false),
  minute: aRange(0, 60, false),
  second: aRange(0, 60, false),
  millisecond: aRange(0, 100, false)
};

// node_modules/erie-web/src/scale/audio-graph-scale-time.js
function makeTimeChannelScale(channel, _encoding, values2, info, scaleType, beat) {
  var _a5, _b2;
  let encoding = deepcopy2(_encoding);
  let scaleDef = encoding == null ? void 0 : encoding.scale;
  if (encoding.type === NOM2 && !scaleDef.timing) {
    scaleDef.timing = REL_TIMING;
  }
  let isRelative = scaleDef.timing === REL_TIMING, isSimultaneous = scaleDef.timing === SIM_TIMING, band = (scaleDef == null ? void 0 : scaleDef.band) || DEF_DUR, length = (scaleDef == null ? void 0 : scaleDef.length) || 5;
  if (beat == null ? void 0 : beat.converter) {
    band = beat.converter((scaleDef == null ? void 0 : scaleDef.band) || 1), length = beat.converter(length);
  }
  if (((_a5 = encoding == null ? void 0 : encoding.scale) == null ? void 0 : _a5.range) === void 0 && (scaleDef == null ? void 0 : scaleDef.band) !== void 0) {
    encoding.scale.range = [0, length - band];
  } else if (((_b2 = encoding == null ? void 0 : encoding.scale) == null ? void 0 : _b2.range) === void 0) {
    encoding.scale.range = [0, length];
  }
  let scale1;
  if (isRelative) {
    scale1 = (t12) => {
      return "after_previous";
    };
    scale1.properties = {
      channel,
      timing: REL_TIMING
    };
  } else if (isSimultaneous) {
    scale1 = (t12) => {
      return 0;
    };
    scale1.properties = {
      channel,
      timing: SIM_TIMING
    };
  } else if ((scaleType == null ? void 0 : scaleType.encodingType) === QUANT2) {
    scale1 = makeQuantitativeScaleFunction(TIME_chn2, encoding, values2, info);
  } else if ((scaleType == null ? void 0 : scaleType.encodingType) === TMP2) {
    scale1 = makeTemporalScaleFunction(TIME_chn2, encoding, values2, info);
  } else if ((scaleType == null ? void 0 : scaleType.encodingType) === ORD2) {
    scale1 = makeOrdinalScaleFunction(TIME_chn2, encoding, values2, info);
  } else if ((scaleType == null ? void 0 : scaleType.encodingType) === NOM2) {
    scale1 = makeNominalScaleFunction(TIME_chn2, encoding, values2, info);
  } else if ((scaleType == null ? void 0 : scaleType.encodingType) === STATIC2) {
    scale1 = makeStaticScaleFunction(TIME_chn2, encoding, values2, info);
  }
  if (!scale1) {
    console.error("Wrong scale definition for the time channel", scaleDef);
  }
  let scaleFunction = (t12, t2) => {
    if (t2 !== void 0) {
      return {
        start: (beat == null ? void 0 : beat.roundStart) ? beat == null ? void 0 : beat.roundStart(scale1(t12)) : scale1(t12),
        end: (beat == null ? void 0 : beat.roundDuration) ? beat == null ? void 0 : beat.roundDuration(scale1(t2)) : scale1(t2)
      };
    } else {
      return {
        start: (beat == null ? void 0 : beat.roundStart) ? beat == null ? void 0 : beat.roundStart(scale1(t12)) : scale1(t12),
        duration: (beat == null ? void 0 : beat.roundDuration) ? beat == null ? void 0 : beat.roundDuration(band) : band
      };
    }
  };
  scaleFunction.properties = scale1.properties;
  scaleFunction.properties.length = length;
  return scaleFunction;
}

// node_modules/erie-web/src/scale/audio-graph-scale-field.js
function makeFieldedScaleFunction(channel, encoding, values2, info, data2) {
  let scaleProperties = {
    channel
  };
  let mapper = {};
  let findKey = encoding.scale.range.field;
  let encKey = encoding.field[0];
  for (const datum of data2) {
    let r = datum[findKey];
    if (channel === PITCH_chn2 && jType(r) !== "Number") {
      r = noteToFreq2(r);
    }
    mapper[datum[encKey]] = r;
  }
  scaleProperties.rangeProvided = true;
  scaleProperties.domain = Object.keys(mapper);
  scaleProperties.range = Object.values(mapper);
  let scaleFunction = (k) => {
    return mapper[k];
  };
  scaleFunction.properties = scaleProperties;
  return scaleFunction;
}

// node_modules/erie-web/src/scale/audio-graph-scale-wrap.js
function getAudioScales(channel, encoding, values2, beat, data2) {
  var _a5, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j2, _k2, _l2, _m2, _n, _o2, _p2, _q2, _r2;
  let polarity = ((_a5 = encoding.scale) == null ? void 0 : _a5.polarity) || POS3;
  let maxDistinct = (_b2 = encoding.scale) == null ? void 0 : _b2.maxDistinct;
  if (maxDistinct === void 0)
    maxDistinct = true;
  let scaleId = encoding.id;
  let times = (_c2 = encoding.scale) == null ? void 0 : _c2.times;
  let zero = ((_d2 = encoding.scale) == null ? void 0 : _d2.zero) !== void 0 ? (_e2 = encoding.scale) == null ? void 0 : _e2.zero : false;
  let domainMax, domainMin;
  if (jType(channel) !== "Array" && values2) {
    let domainSorted = values2.toSorted(asc);
    domainMax = domainSorted[domainSorted.length - 1];
    domainMin = domainSorted[0];
  } else if (values2) {
    let domainSorted = values2[0].concat(values2[1]).toSorted(asc);
    domainMax = domainSorted[domainSorted.length - 1];
    domainMin = domainSorted[0];
  }
  let nice = (_f2 = encoding.scale) == null ? void 0 : _f2.nice;
  let info = { polarity, maxDistinct, times, zero, domainMax, domainMin, nice };
  let _scale;
  let scaleType = getScaleType(channel, encoding, values2);
  if (scaleType.fieldRange) {
    _scale = makeFieldedScaleFunction(channel, encoding, values2, info, data2);
  } else if (scaleType.isTime) {
    _scale = makeTimeChannelScale(channel, encoding, values2, info, scaleType, beat);
  } else if (scaleType.isSpeech) {
    _scale = makeSpeechChannelScale(channel, encoding, values2, info);
  } else {
    if (scaleType.encodingType === QUANT2) {
      _scale = makeQuantitativeScaleFunction(channel, encoding, values2, info);
    } else if (scaleType.encodingType === TMP2) {
      _scale = makeTemporalScaleFunction(channel, encoding, values2, info);
    } else if (scaleType.encodingType === ORD2) {
      _scale = makeOrdinalScaleFunction(channel, encoding, values2, info);
    } else if (scaleType.encodingType === NOM2) {
      _scale = makeNominalScaleFunction(channel, encoding, values2, info);
    } else if (scaleType.encodingType === STATIC2) {
      _scale = makeStaticScaleFunction(channel, encoding, values2, info);
    }
  }
  if (_scale) {
    let scale2;
    if (channel === PITCH_chn2 && encoding.roundToNote) {
      scale2 = (d) => {
        return roundToNoteScale(_scale(d));
      };
    } else if (TapChannels.includes(channel)) {
      let pause = { rate: ((_g2 = encoding.scale) == null ? void 0 : _g2.pauseRate) !== void 0 ? (_h2 = encoding.scale) == null ? void 0 : _h2.pauseRate : DEF_TAP_PAUSE_RATE };
      if ((_i = encoding.scale) == null ? void 0 : _i.pauseLength)
        pause = { length: (_j2 = encoding.scale) == null ? void 0 : _j2.pauseLength };
      if (channel === TAPCNT_chn2) {
        scale2 = (d) => {
          var _a6;
          return {
            value: _scale(d),
            tapLength: (_a6 = encoding.scale) == null ? void 0 : _a6.band,
            pause,
            beat
          };
        };
      } else if (channel === TAPSPD_chn2) {
        let tapSpeedValues = values2.map((d) => _scale(d));
        let tapBand = ((_k2 = encoding.scale) == null ? void 0 : _k2.band) || (beat ? DEF_TAP_DUR_BEAT : DEF_TAP_DUR);
        let maxTapSpeed = round(Math.max(...tapSpeedValues) * tapBand, 0);
        let tappingUnit = tapBand / (maxTapSpeed + (maxTapSpeed - 1) * (pause.rate !== void 0 ? pause.rate : DEF_TAP_PAUSE_RATE));
        let maxTappingLength = ((_l2 = encoding.scale) == null ? void 0 : _l2.maxTappingLength) !== void 0 ? (_m2 = encoding.scale) == null ? void 0 : _m2.maxTappingLength : beat ? DEF_TAPPING_DUR_BEAT : MAX_TAPPING_DUR;
        if (tappingUnit > maxTappingLength)
          tappingUnit = maxTappingLength;
        tappingUnit = round(tappingUnit, -2);
        scale2 = (d) => {
          var _a6, _b3;
          return {
            value: _scale(d),
            tapDuration: (_a6 = encoding.scale) == null ? void 0 : _a6.band,
            tappingUnit,
            singleTappingPosition: ((_b3 = encoding.scale) == null ? void 0 : _b3.singleTappingPosition) || SINGLE_TAP_MIDDLE,
            beat
          };
        };
      }
    } else if (channel === DUR_chn2 && beat) {
      scale2 = (d) => beat.converter(_scale(d));
    } else {
      scale2 = _scale;
    }
    if (scale2.properties) {
      Object.assign(scale2.properties, scaleType);
    } else if (_scale.properties) {
      scale2.properties = {};
      Object.assign(scale2.properties, _scale.properties);
      Object.assign(scale2.properties, scaleType);
    }
    if (((_n = encoding.scale) == null ? void 0 : _n.description) || ((_o2 = encoding.scale) == null ? void 0 : _o2.description) === void 0) {
      scale2.properties.descriptionDetail = (_p2 = encoding.scale) == null ? void 0 : _p2.description;
    } else {
      scale2.properties.descriptionDetail = null;
    }
    if ((_q2 = encoding.scale) == null ? void 0 : _q2.title) {
      scale2.properties.title = (_r2 = encoding.scale) == null ? void 0 : _r2.title;
    } else {
      scale2.properties.title = listString(unique(scale2.properties.field), ", ", false);
    }
    if (encoding.format) {
      scale2.properties.format = encoding.format;
    }
    if (encoding.formatType) {
      scale2.properties.formatType = encoding.formatType;
    } else if (encoding.format) {
      scale2.properties.formatType = "number";
    }
    if (scaleId) {
      scale2.scaleId = scaleId;
    }
    return scale2;
  } else {
    console.error(`The encoding definition for ${channel} channel is illegal:`, encoding);
    return null;
  }
}
function getScaleType(channel, encoding, values2) {
  var _a5, _b2;
  let isTime = TimeChannels.includes(channel) || TimeChannels.includes(channel[0]);
  let isSpeech = SpeechChannels.includes(channel);
  let encodingType = encoding.type;
  if (!encodingType) {
    if (encoding.value)
      encodingType = STATIC2;
    else
      encodingType = detectType(values2);
  }
  let field = encoding.original_field || encoding.field;
  let binned = encoding.binned;
  let aggregate2 = encoding.aggregate;
  let fieldRange = ((_b2 = (_a5 = encoding.scale) == null ? void 0 : _a5.range) == null ? void 0 : _b2.field) || null;
  return { isTime, isSpeech, encodingType, field, binned, aggregate: aggregate2, fieldRange };
}

// node_modules/erie-web/src/scale/audio-graph-time-convert.js
function makeBeatFunction(tempo) {
  return (beat) => {
    return beat * 60 / tempo;
  };
}
function makeBeatRounder(tempo, r) {
  return (sec) => {
    if (sec.constructor.name !== "Number")
      return sec;
    let beats = sec / tempo * 60;
    return Math.round(beats / r) * r;
  };
}

// node_modules/erie-web/src/compile/audio-graph-update-scale.js
function tidyUpScaleDefinitions(scaleDefinitions, normalizedSpecs, sequenceConfig) {
  var _a5, _b2;
  let sequenceScaleConsistency = (sequenceConfig == null ? void 0 : sequenceConfig.sequenceScaleConsistency) || {};
  let forceSequenceScaleConsistency = (sequenceConfig == null ? void 0 : sequenceConfig.forceSequenceScaleConsistency) || {};
  let removals = [];
  for (const stream of normalizedSpecs) {
    if (stream.stream) {
      Object.keys(stream.stream.encoding).forEach((channel) => {
        let match;
        if (sequenceScaleConsistency[channel] && !forceSequenceScaleConsistency[channel]) {
          match = findScaleMatch(scaleDefinitions, stream.stream.encoding[channel], false, !forceSequenceScaleConsistency[channel]);
        } else if (forceSequenceScaleConsistency[channel]) {
          match = findScaleMatch(scaleDefinitions, stream.stream.encoding[channel], false, forceSequenceScaleConsistency[channel]);
        }
        if (match) {
          if (match.id !== stream.stream.encoding[channel].scale.id) {
            match.field.push(stream.stream.encoding[channel].field);
            removals.push(stream.stream.encoding[channel].scale.id);
            Object.keys(stream.stream.encoding[channel].scale).forEach((prop) => {
              if (!match.scale[prop])
                match.scale[prop] = stream.stream.encoding[channel].scale[prop];
            });
            stream.stream.encoding[channel].scale.id = match.id;
          }
        }
      });
    } else if (stream.overlay) {
      for (const overlayStream of stream.overlay) {
        let overlayScaleConsistency = ((_a5 = stream == null ? void 0 : stream.config) == null ? void 0 : _a5.overlayScaleConsistency) || (sequenceConfig == null ? void 0 : sequenceConfig.overlayScaleConsistency) || {};
        let forceOverlayScaleConsistency = ((_b2 = stream == null ? void 0 : stream.config) == null ? void 0 : _b2.forceOverlayScaleConsistency) || (sequenceConfig == null ? void 0 : sequenceConfig.forceOverlayScaleConsistency) || {};
        Object.keys(overlayStream.encoding).forEach((channel) => {
          let match;
          if (sequenceScaleConsistency[channel] && !forceSequenceScaleConsistency[channel]) {
            match = findScaleMatch(scaleDefinitions, overlayStream.encoding[channel], true, !forceSequenceScaleConsistency[channel]);
          } else if (forceSequenceScaleConsistency[channel]) {
            match = findScaleMatch(scaleDefinitions, overlayStream.encoding[channel], true, forceSequenceScaleConsistency[channel]);
          } else if (overlayScaleConsistency[channel] && !forceOverlayScaleConsistency[channel]) {
            match = findScaleMatch(scaleDefinitions, overlayStream.encoding[channel], false, !forceOverlayScaleConsistency[channel]);
          } else if (forceOverlayScaleConsistency[channel]) {
            match = findScaleMatch(scaleDefinitions, overlayStream.encoding[channel], false, forceOverlayScaleConsistency[channel]);
          }
          if (match) {
            if (match.id !== overlayStream.encoding[channel].scale.id) {
              match.field.push(overlayStream.encoding[channel].field);
              removals.push(overlayStream.encoding[channel].scale.id);
              Object.keys(overlayStream.encoding[channel].scale).forEach((prop) => {
                if (!match.scale[prop])
                  match.scale[prop] = overlayStream.encoding[channel].scale[prop];
              });
              overlayStream.encoding[channel].scale.id = match.id;
            }
          }
        });
      }
    }
  }
  return removals;
}
function findScaleMatch(scaleDefinitions, encoding, matchParent, matchData) {
  let thisDef;
  for (const def of scaleDefinitions) {
    if (def.id === encoding.scale.id)
      thisDef = def;
  }
  for (const def of scaleDefinitions) {
    if (def.channel === thisDef.channel && def.type === thisDef.type) {
      if (def.channel === TIME_chn2 && def.scale.timing !== thisDef.scale.timing)
        continue;
      if (matchData && matchParent) {
        if (def.dataName === thisDef.dataName && def.parentID === thisDef.parentID)
          return def;
      } else if (!matchData && matchParent) {
        if (def.parentID === thisDef.parentID)
          return def;
      } else if (matchData && !matchParent) {
        if (def.dataName === thisDef.dataName)
          return def;
      } else {
        return def;
      }
    }
    if (def.id === encoding.scale.id)
      return def;
  }
  return null;
}
async function getChannelType(loaded_datasets, spec, untyped_channels) {
  let data2 = loaded_datasets[spec.data.name];
  if (!data2 || !spec.encoding) {
    console.error("No proper layer spec provided.");
    return void 0;
  }
  for (const channel of Object.keys(spec.encoding)) {
    if (!spec.encoding[channel].type && spec.encoding[channel].value !== void 0) {
      spec.encoding[channel].type = STATIC2;
    } else if (!spec.encoding[channel].type) {
      spec.encoding[channel].type = detectType(data2.map((d) => d[spec.encoding[channel].field]));
    }
  }
  data2 = applyTransforms(data2, spec);
  for (const channel of Object.keys(spec.encoding)) {
    if (!spec.encoding[channel].type && spec.encoding[channel].value !== void 0) {
      spec.encoding[channel].type = STATIC2;
    } else if (!spec.encoding[channel].type) {
      spec.encoding[channel].type = detectType(data2.map((d) => d[spec.encoding[channel].field]));
    }
  }
}
async function makeScales(scaleHash, normalized, loaded_datasets, config) {
  let scaleInfo = deepcopy2(scaleHash);
  Object.keys(scaleInfo).forEach((scaleId) => {
    scaleInfo[scaleId].collected = [];
  });
  let beat;
  if (config == null ? void 0 : config.timeUnit) {
    if (config.timeUnit.unit === "beat") {
      beat = {
        converter: makeBeatFunction(config.timeUnit.tempo || 100)
      };
      let roundStart = true, roundDuration = false;
      if (config.timeUnit.rounding) {
        roundStart = config.timeUnit.rounding !== "never";
        roundDuration = config.timeUnit.rounding === "always";
      }
      if (roundStart) {
        beat.roundStart = makeBeatRounder(config.timeUnit.tempo || 100, config.timeUnit.roundingBy || 1);
      }
      if (roundDuration) {
        beat.roundDuration = makeBeatRounder(config.timeUnit.tempo || 100, config.timeUnit.roundingBy || 1);
      }
    }
  }
  for (const stream of normalized) {
    if (stream.stream) {
      let data2 = loaded_datasets[stream.stream.data.name];
      data2 = applyTransforms(data2, stream.stream);
      let encoding = stream.stream.encoding;
      for (const cname of Object.keys(encoding)) {
        let scaleId = encoding[cname].scale.id;
        scaleInfo[scaleId].data = data2;
        if (encoding[cname].field) {
          let collectionKey = stream.stream.data.name + "_" + encoding[cname].field;
          if (!scaleInfo[scaleId].collected.includes(collectionKey)) {
            scaleInfoUpdater(encoding[cname], scaleInfo, data2);
            scaleInfo[scaleId].collected.push(collectionKey);
          }
        } else if (encoding[cname].value !== void 0) {
          scaleInfo[scaleId].type = STATIC2;
          scaleInfo[scaleId].value = encoding[cname].value;
        }
        if (encoding[cname].format) {
          scaleInfo[scaleId].format = encoding[cname].format;
        }
        if (encoding[cname].formatType) {
          scaleInfo[scaleId].formatType = encoding[cname].formatType;
        }
      }
    } else if (stream.overlay) {
      for (const overlay of stream.overlay) {
        let data2 = loaded_datasets[overlay.data.name];
        data2 = applyTransforms(data2, overlay);
        let encoding = overlay.encoding;
        for (const cname of Object.keys(encoding)) {
          let scaleId = encoding[cname].scale.id;
          scaleInfo[scaleId].data = data2;
          if (encoding[cname].field) {
            let collectionKey = overlay.data.name + "_" + encoding[cname].field;
            if (!scaleInfo[scaleId].collected.includes(collectionKey)) {
              scaleInfoUpdater(encoding[cname], scaleInfo, data2);
              scaleInfo[scaleId].collected.push(collectionKey);
            }
          } else if (encoding[cname].value !== void 0) {
            scaleInfo[scaleId].type = STATIC2;
            scaleInfo[scaleId].value = encoding[cname].value;
          }
          if (encoding[cname].format) {
            scaleInfo[scaleId].format = encoding[cname].format;
          }
          if (encoding[cname].formatType) {
            scaleInfo[scaleId].formatType = encoding[cname].formatType;
          }
        }
      }
    }
  }
  let scaleFunctions = {};
  for (const scaleId of Object.keys(scaleInfo)) {
    let scaleDef = scaleInfo[scaleId];
    let channel = scaleDef.channel;
    let o = {};
    Object.assign(o, scaleDef);
    scaleFunctions[scaleId] = getAudioScales(channel, o, scaleDef.values, beat, scaleDef.data);
  }
  if (beat)
    scaleFunctions.__beat = beat;
  return scaleFunctions;
}
function scaleInfoUpdater(channel, scaleInfo, data2) {
  let field = channel.field;
  let scaleId = channel.scale.id;
  if (scaleInfo[scaleId]) {
    if (!scaleInfo[scaleId].values)
      scaleInfo[scaleId].values = [];
    let datums = [];
    if (jType(field) === "Array") {
      field.forEach((f) => {
        datums.push(...data2.map((d, i2) => d[f]));
      });
    } else {
      datums.push(...data2.map((d, i2) => d[field]));
    }
    if (scaleInfo[scaleId].type === TMP2) {
      datums = datums.map((d) => new Date(d));
    }
    scaleInfo[scaleId].values.push(...datums);
  }
}

// node_modules/erie-web/src/audio-graph.js
var isRecorded = false;
function readyRecording() {
  var _a5;
  (_a5 = document == null ? void 0 : document.body) == null ? void 0 : _a5.addEventListener("erieOnRecorderReady", (e) => {
    isRecorded = true;
  });
}
async function compileAuidoGraph(audio_spec, options) {
  var _a5;
  let { normalized, datasets, tick, scaleDefinitions, sequenceConfig, synths, samplings, waves } = await normalizeSpecification(audio_spec);
  let loaded_datasets = {};
  let scalesToRemove = [];
  for (const stream of normalized) {
    if (stream.stream) {
      await getDataWrap(stream.stream.data, loaded_datasets, datasets);
      let untyped_channels = [];
      Object.keys(stream.stream.encoding).forEach((channel) => {
        if (!stream.stream.encoding[channel].type)
          untyped_channels.push(channel);
      });
      if (untyped_channels.length > 0) {
        await getChannelType(loaded_datasets, stream.stream, untyped_channels);
      }
      scalesToRemove.push(...tidyUpScaleDefinitions(scaleDefinitions, normalized, sequenceConfig));
    } else if (stream.overlay) {
      for (const overlay of stream.overlay) {
        await getDataWrap(overlay.data, loaded_datasets, datasets);
        let untyped_channels = [];
        Object.keys(overlay.encoding).forEach((channel) => {
          if (!overlay.encoding[channel].type)
            untyped_channels.push(channel);
        });
        if (untyped_channels.length > 0) {
          await getChannelType(loaded_datasets, overlay, untyped_channels);
        }
      }
      let c = {};
      Object.assign(c, sequenceConfig);
      Object.assign(c, stream.config || {});
      scalesToRemove.push(...tidyUpScaleDefinitions(scaleDefinitions, normalized, c));
    }
  }
  let scaleHash = toHashedObject(scaleDefinitions, "id");
  for (const sid of scalesToRemove) {
    delete scaleHash[sid];
  }
  let scales = await makeScales(scaleHash, normalized, loaded_datasets, sequenceConfig);
  let sequence = new SequenceStream();
  if ((_a5 = audio_spec == null ? void 0 : audio_spec.config) == null ? void 0 : _a5.recording) {
    sequence.setConfig("recording", true);
  }
  sequence.setSampling(toHashedObject(samplings, "name"));
  sequence.setSynths(toHashedObject(synths, "name"));
  sequence.setWaves(toHashedObject(waves, "name"));
  let sequenceScaleConsistency = audio_spec.config.sequenceScaleConsistency !== void 0 ? audio_spec.config.sequenceScaleConsistency : true;
  let si = 0, isSeq2 = (normalized == null ? void 0 : normalized.length) > 1;
  for (const stream of normalized) {
    if (stream.intro) {
      let speeches = [stream.intro.title, stream.intro.description].filter((d) => d !== void 0);
      let sStream = new SpeechStream(speeches.map((d) => ({ speech: d })));
      if (audio_spec.config) {
        Object.keys(audio_spec.config).forEach((key2) => {
          sStream.setConfig(key2, audio_spec.config[key2]);
        });
      }
      sequence.setIntroStream(sStream);
    } else if (stream.stream) {
      let is_repeated = isRepeatedStream(stream.stream);
      let data2 = deepcopy2(loaded_datasets[stream.stream.data.name]);
      let slag = await compileSingleLayerAuidoGraph(stream.stream, data2, audio_spec.config, tick, scales);
      if (!is_repeated) {
        sequence.addStream(slag.stream);
      } else {
        sequence.addStreams(slag.stream);
      }
      if (audio_spec.config) {
        Object.keys(audio_spec.config).forEach((key2) => {
          sequence.setConfig(key2, audio_spec.config[key2]);
        });
      }
      if (stream.stream.config) {
        Object.keys(stream.stream.config).forEach((key2) => {
          sequence.setConfig(key2, stream.stream.config[key2]);
        });
      }
      if (stream.stream.title)
        sequence.setTitle(stream.stream.title);
      if (stream.stream.description)
        sequence.setDescription(stream.stream.description);
    } else if (stream.overlay) {
      let overlays = new OverlayStream();
      let i2 = 0;
      for (const overlay of stream.overlay) {
        let data2 = deepcopy2(loaded_datasets[overlay.data.name]);
        let config = deepcopy2(audio_spec.config);
        Object.assign(config, overlay.config);
        let overlayStrm = await compileSingleLayerAuidoGraph(overlay, data2, config, tick, scales);
        if (overlay.name)
          overlayStrm.stream.setName(overlay.name);
        if (overlay.title)
          overlayStrm.stream.setTitle(overlay.title);
        if (overlay.description)
          overlayStrm.stream.setDescription(overlay.description);
        overlays.addStream(overlayStrm.stream);
        i2++;
      }
      overlays.setName(stream.name);
      overlays.setTitle(stream.title);
      overlays.setDescription(stream.description);
      if (audio_spec.config) {
        Object.keys(audio_spec.config).forEach((key2) => {
          overlays.setConfig(key2, audio_spec.config[key2]);
        });
      }
      if (stream.overlay.config) {
        Object.keys(stream.overlay.config).forEach((key2) => {
          overlays.setConfig(key2, stream.overlay.config[key2]);
        });
      }
      sequence.addStream(overlays);
    }
    si++;
  }
  if (audio_spec.config) {
    Object.keys(audio_spec.config).forEach((key2) => {
      sequence.setConfig(key2, audio_spec.config[key2]);
    });
  }
  if (window == null ? void 0 : window.erieRecorderReady) {
    isRecorded = true;
  }
  sequence.setConfig("isRecorded", isRecorded);
  sequence.setConfig("options", options);
  return sequence;
}

// node_modules/erie-web/src/base.js
var ErieSampleBaseUrl = "audio_sample/";
function setSampleBaseUrl(url) {
  ErieSampleBaseUrl = url;
}
export {
  Aggregate,
  Bin,
  Calculate,
  Channel,
  Config,
  Data,
  Dataset,
  Datasets,
  Density,
  DurationChannel,
  ErieFilters,
  ErieSampleBaseUrl,
  Filter,
  Fold,
  LoudnessChannel,
  ModulationChannel,
  Overlay,
  PanChannel,
  PitchChannel,
  PostReverbChannel,
  RepeatChannel,
  SampledTone,
  Sampling,
  Sequence2 as Sequence,
  SpeechAfterChannel,
  SpeechBeforeChannel,
  Stream,
  Synth,
  SynthTone2 as SynthTone,
  TapCountChannel,
  TapSpeedChannel,
  Tick,
  Time2Channel,
  TimeChannel,
  Tone,
  Transform,
  Wave,
  WaveTone,
  compileAuidoGraph,
  readyRecording,
  registerFilter,
  setSampleBaseUrl
};
//# sourceMappingURL=erie-web.js.map
